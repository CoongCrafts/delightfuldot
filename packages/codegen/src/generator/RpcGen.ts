import { rpcCalls } from '@delightfuldot/specs';
import { RpcCallName, RpcCallSpec, RpcModuleName } from '@delightfuldot/specs/types';
import { registry, RpcMethods } from '@delightfuldot/types';
import { isJsPrimitive } from '@delightfuldot/utils';
import { ApiGen, TypesGen } from '../generator';
import { commentBlock } from './utils';

const HIDDEN_RPCS = ['rpc_methods'];

export class RpcGen extends ApiGen {
  constructor(
    readonly typesGen: TypesGen,
    readonly rpcMethods: string[],
  ) {
    super(typesGen);
    rpcMethods.push(...HIDDEN_RPCS);
  }

  generate() {
    const methodsByModule = this.rpcMethods
      .map((one) => one.split('_'))
      .filter((parts) => parts.length > 1)
      .reduce(
        (o, [module, ...methodParts]) => {
          const method = methodParts.join('_');

          // ignore if rpc name does not confront with the general convention
          if (!method) {
            return o;
          }

          return {
            ...o,
            [module]: o[module] ? [...o[module], method] : [method],
          };
        },
        {} as Record<string, string[]>,
      );

    let rpcCallsOut = '';
    Object.keys(methodsByModule).forEach((module) => {
      const methods = methodsByModule[module];
      // TODO add alias info to docs block!
      rpcCallsOut += `${module}: {
  ${methods.map((method) => this.#generateMethodDef(module, method)).join(',\n')},
  
  [method: string]: AsyncMethod,
},`;
    });

    const toImportKnownTypes = ['GenericRpcCalls', 'AsyncMethod', ...this.knownTypes];
    const toImportCodecsTypes = [...this.codecTypes];
    const toImportChainTypes = [...this.chainTypes];
    // TODO include & define external types

    return `
// Generated by @delightfuldot/codegen

import { ${toImportKnownTypes.join(', ')} } from "@delightfuldot/types";
import type { ${toImportCodecsTypes.join(', ')} } from "@delightfuldot/codecs";
import type { ${toImportChainTypes.join(', ')} } from "./types";

export interface RpcCalls extends GenericRpcCalls {
  ${rpcCallsOut}
}
`;
  }

  #generateMethodDef(module: string, method: string) {
    const methodDef = this.#findMethodDef(module, method);

    const defaultDocs = `@rpcname: ${module}_${method}`;

    if (methodDef) {
      const { params, docs = [], type } = methodDef!;

      this.addOutType(type);
      this.addOutType(params.map((one) => one.type));

      return `${commentBlock(docs, '\n', defaultDocs)}${method}(${params.map(
        ({ name, type, isOptional }) => `${name}${isOptional ? '?' : ''}: ${type}`,
      )}): Promise<${type}>`;
    }

    return `${commentBlock(defaultDocs)}${method}: AsyncMethod`;
  }

  #findMethodDef(module: RpcModuleName, method: RpcCallName): RpcCallSpec | undefined {
    const knownModule = rpcCalls[module] || {};
    const targetCall = knownModule[method];

    if (targetCall) {
      return targetCall;
    }

    const callName = `${module}_${method}`;
    for (const moduleName in rpcCalls) {
      for (const rpcName in rpcCalls[moduleName]) {
        const rpcCall = rpcCalls[moduleName][rpcName];
        if (rpcCall.name === callName) {
          return rpcCall;
        }

        const alias = rpcCall.alias;
        if (alias && alias.includes(callName)) {
          return rpcCall;
        }
      }
    }
  }

  // TODO docs! external types to define
  outTypes: Set<string> = new Set<string>();
  // known types that're not codecs or chain types defined in @delightfuldot/types
  knownTypes: Set<string> = new Set<string>();
  // TODO docs! known types that has a corresponding codec defined in @delightfuldot/codecs
  codecTypes: Set<string> = new Set<string>();
  // TODO docs! types from chain
  chainTypes: Set<string> = new Set<string>();

  addOutType(type: string | string[]) {
    if (Array.isArray(type)) {
      type.forEach((one) => this.addOutType(one));
      return;
    }

    if (isJsPrimitive(type)) {
      return;
    }

    // TODO handle for generic wrapper types
    const matchArray = type.match(/^Array<(.+)>$/);
    if (matchArray) {
      console.log(matchArray[1]);
      this.addOutType(matchArray[1]);
      return;
    }

    if (this.typesGen.usedNameTypes.has(type)) {
      this.chainTypes.add(type);
      return;
    }

    try {
      this.registry.findCodec(type);
      this.codecTypes.add(type);
    } catch (e) {}

    if (registry.has(type)) {
      this.knownTypes.add(type);
    } else {
      this.outTypes.add(type);
    }
  }
}
