import { findAliasRpcSpec, findRpcSpec, RpcModuleName } from '@delightfuldot/specs';
import { RpcCallSpec } from '@delightfuldot/specs/types';
import { registry } from '@delightfuldot/types';
import { isJsPrimitive } from '@delightfuldot/utils';
import { ApiGen, TypesGen } from '../generator';
import { beautifySourceCode, commentBlock } from './utils';

const HIDDEN_RPCS = [
  // Ref: https://github.com/paritytech/polkadot-sdk/blob/43415ef58c143b985e09015cd000dbd65f6d3997/substrate/client/rpc-servers/src/lib.rs#L152C9-L158
  'rpc_methods',
];

export class RpcGen extends ApiGen {
  constructor(
    readonly typesGen: TypesGen,
    readonly rpcMethods: string[],
  ) {
    super(typesGen);
    HIDDEN_RPCS.filter((one) => !rpcMethods.includes(one)).forEach((one) => rpcMethods.push(one));
    rpcMethods.sort();
  }

  generate() {
    const specsByModule = this.rpcMethods
      .filter((one) => !findAliasRpcSpec(one)) // we'll ignore alias rpc for now if defined in the specs! TODO should we generate alias rpc as well?
      .map((one) => {
        const spec = findRpcSpec(one);
        if (spec) {
          return spec;
        }

        const [module, ...methodParts] = one.split('_');
        const method = methodParts.join('_');

        return {
          params: [],
          type: 'AsyncMethod',
          module,
          method,
        } as RpcCallSpec;
      })
      .reduce(
        (o, spec) => {
          const { module, method } = spec;

          // ignore if rpc name does not confront with the general convention
          if (!module || !method) {
            return o;
          }

          return {
            ...o,
            [module]: o[module] ? [...o[module], spec] : [spec],
          };
        },
        {} as Record<RpcModuleName, RpcCallSpec[]>,
      );
    let rpcCallsOut = '';
    Object.keys(specsByModule).forEach((module) => {
      const specs = specsByModule[module];
      // TODO add alias info to docs block!
      rpcCallsOut += `${module}: {
      ${specs.map((spec) => this.#generateMethodDef(spec)).join(',\n')},

      [method: string]: AsyncMethod,
    },`;
    });

    const toImportKnownTypes = ['GenericRpcCalls', 'AsyncMethod', ...this.knownTypes];
    const toImportCodecsTypes = [...this.codecTypes];
    const toImportChainTypes = [...this.chainTypes];
    // TODO include & define external types

    return beautifySourceCode(`
    // Generated by @delightfuldot/codegen

    import { ${toImportKnownTypes.join(', ')} } from "@delightfuldot/types";
    import type { ${toImportCodecsTypes.join(', ')} } from "@delightfuldot/codecs";
    import type { ${toImportChainTypes.join(', ')} } from "./types";

    export interface RpcCalls extends GenericRpcCalls {
      ${rpcCallsOut}
    }
    `);
  }

  #generateMethodDef(spec: RpcCallSpec) {
    const { name, type, module, method, docs = [], params } = spec;

    const rpcName = name || `${module}_${method}`;
    const defaultDocs = `@rpcname: ${rpcName}`;

    if (type === 'AsyncMethod' && params.length === 0) {
      return `${commentBlock(defaultDocs)}${method}: AsyncMethod`;
    }

    this.addOutType(type);
    this.addOutType(params.map((one) => one.type));

    return `${commentBlock(docs, '\n', defaultDocs)}${method}(${params.map(
      ({ name, type, isOptional }) => `${name}${isOptional ? '?' : ''}: ${type}`,
    )}): Promise<${type}>`;
  }

  // TODO docs! external types to define explicitly
  outTypes: Set<string> = new Set<string>();
  // known types that're not codecs or chain types defined in @delightfuldot/types
  knownTypes: Set<string> = new Set<string>();
  // TODO docs! known types that has a corresponding codec defined in @delightfuldot/codecs
  codecTypes: Set<string> = new Set<string>();
  // TODO docs! types from chain
  chainTypes: Set<string> = new Set<string>();

  addOutType(type: string | string[]) {
    if (Array.isArray(type)) {
      type.forEach((one) => this.addOutType(one));
      return;
    }

    if (isJsPrimitive(type)) {
      return;
    }

    // TODO handle for generic wrapper types
    const matchArray = type.match(/^Array<(.+)>$/);
    if (matchArray) {
      this.addOutType(matchArray[1]);
      return;
    }

    if (this.typesGen.usedNameTypes.has(type)) {
      this.chainTypes.add(type);
      return;
    }

    try {
      this.registry.findCodec(type);
      this.codecTypes.add(type);
    } catch (e) {}

    if (registry.has(type)) {
      this.knownTypes.add(type);
    } else {
      this.outTypes.add(type);
    }
  }
}
