import { findAliasRpcSpec, findRpcSpec, isUnsubscribeMethod, RpcModuleName } from '@delightfuldot/specs';
import { RpcCallSpec } from '@delightfuldot/specs/types';
import { isJsPrimitive } from '@delightfuldot/utils';
import { ApiGen, TypesGen } from '../generator';
import { beautifySourceCode, commentBlock, WRAPPER_TYPE_REGEX } from './utils';

const HIDDEN_RPCS = [
  // Ref: https://github.com/paritytech/polkadot-sdk/blob/43415ef58c143b985e09015cd000dbd65f6d3997/substrate/client/rpc-servers/src/lib.rs#L152C9-L158
  'rpc_methods',
];

export class RpcGen extends ApiGen {
  constructor(
    readonly typesGen: TypesGen,
    readonly rpcMethods: string[],
  ) {
    super(typesGen);
    HIDDEN_RPCS.filter((one) => !rpcMethods.includes(one)).forEach((one) => rpcMethods.push(one));
    rpcMethods.sort();
  }

  generate() {
    this.typesGen.clearCache();
    this.typesGen.typeImports.addKnownType('GenericRpcCalls', 'AsyncMethod', 'Unsub', 'Callback');

    const specsByModule = this.rpcMethods
      .filter((one) => !findAliasRpcSpec(one)) // we'll ignore  alias rpc for now if defined in the specs! TODO should we generate alias rpc as well?
      .filter((one) => !isUnsubscribeMethod(one)) // we'll ignore unsubscribe method as well
      .map((one) => {
        const spec = findRpcSpec(one);
        if (spec) {
          return spec;
        }

        const [module, ...methodParts] = one.split('_');
        const method = methodParts.join('_');

        return {
          params: [],
          type: 'AsyncMethod',
          module,
          method,
        } as RpcCallSpec;
      })
      .reduce(
        (o, spec) => {
          const { module, method } = spec;

          // ignore if rpc name does not confront with the general convention
          if (!module || !method) {
            return o;
          }

          return {
            ...o,
            [module]: o[module] ? [...o[module], spec] : [spec],
          };
        },
        {} as Record<RpcModuleName, RpcCallSpec[]>,
      );
    let rpcCallsOut = '';
    Object.keys(specsByModule).forEach((module) => {
      const specs = specsByModule[module];
      // TODO add alias info to docs block!
      rpcCallsOut += `${module}: {
      ${specs.map((spec) => this.#generateMethodDef(spec)).join(',\n')},

      [method: string]: AsyncMethod,
    },`;
    });

    // TODO include & define external types

    return beautifySourceCode(`
// Generated by @delightfuldot/codegen

${this.typesGen.typeImports.toImports()}

export interface RpcCalls extends GenericRpcCalls {
  ${rpcCallsOut}
}
    `);
  }

  #generateMethodDef(spec: RpcCallSpec) {
    const { name, type, module, method, docs = [], params, pubsub } = spec;

    const rpcName = name || `${module}_${method}`;
    let defaultDocs = [`@rpcname: ${rpcName}`];

    if (type === 'AsyncMethod' && params.length === 0) {
      return `${commentBlock(defaultDocs)}${method}: AsyncMethod`;
    }

    this.addTypeImport(type, false);
    params.forEach(({ type, isScale }) => {
      this.addTypeImport(type, !!isScale);
    });

    const isSubscription = !!pubsub;

    const paramsOut = params.map(
      ({ name, type, isOptional, isScale }) =>
        `${name}${isOptional ? '?' : ''}: ${this.getGeneratedTypeName(type, !!isScale)}`,
    );

    const typeOut = this.getGeneratedTypeName(type, false);

    if (isSubscription) {
      defaultDocs = [`@pubsub: ${pubsub?.join(', ')}`];

      paramsOut.push(`callback: Callback<${typeOut}>`);
      return `${commentBlock(docs, '\n', defaultDocs)}${method}(${paramsOut.join(', ')}): Promise<Unsub>`;
    } else {
      return `${commentBlock(docs, '\n', defaultDocs)}${method}(${paramsOut.join(', ')}): Promise<${typeOut}>`;
    }
  }

  // TODO check typeIn, typeOut if param type, or rpc type isScale
  addTypeImport(type: string | string[], toTypeIn = true) {
    if (Array.isArray(type)) {
      type.forEach((one) => this.addTypeImport(one, toTypeIn));
      return;
    }

    type = type.trim();

    if (isJsPrimitive(type)) {
      return;
    }

    // TODO handle for generic wrapper types
    const matchArray = type.match(WRAPPER_TYPE_REGEX);
    if (matchArray) {
      const [_, $1, $2] = matchArray;
      this.addTypeImport($1, toTypeIn);
      this.addTypeImport(
        $2.split(',').map((one) => one.trim()),
        toTypeIn,
      );
      return;
    }

    if (type.includes(' | ')) {
      this.addTypeImport(
        type.split(' | ').map((one) => one.trim()),
        toTypeIn,
      );
      return;
    }

    try {
      const { typeIn, typeOut } = this.registry.findCodecType(type);
      this.typesGen.typeImports.addCodecType(toTypeIn ? typeIn : typeOut);
      return;
    } catch (e) {}

    this.typesGen.addTypeImport(type);
  }

  getGeneratedTypeName(type: string, toTypeIn = true) {
    try {
      const { typeIn, typeOut } = this.registry.findCodecType(type);
      return toTypeIn ? typeIn : typeOut;
    } catch (e) {}

    return type;
  }
}
