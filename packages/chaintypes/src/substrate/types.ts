// Generated by @delightfuldot/codegen

import type {
  Bytes,
  FixedBytes,
  FixedArray,
  AccountId32Like,
  H256,
  Digest,
  DigestItem,
  Perbill,
  FixedU128,
  FixedU64,
  Perquintill,
  Header,
  MultiAddress,
  PerU16,
  Percent,
  Data,
  Permill,
  FixedI64,
} from '@delightfuldot/codecs';
export type {
  Bytes,
  FixedBytes,
  FixedArray,
  AccountId32Like,
  H256,
  Digest,
  DigestItem,
  Perbill,
  FixedU128,
  FixedU64,
  Perquintill,
  Header,
  MultiAddress,
  PerU16,
  Percent,
  Data,
  Permill,
  FixedI64,
} from '@delightfuldot/codecs';

export type AccountId = AccountId32Like;

export type FrameSystemAccountInfo = {
  nonce: number;
  consumers: number;
  providers: number;
  sufficients: number;
  data: PalletBalancesAccountData;
};

export type PalletBalancesAccountData = {
  free: bigint;
  reserved: bigint;
  frozen: bigint;
  flags: PalletBalancesExtraFlags;
};

export type PalletBalancesExtraFlags = bigint;

export type FrameSupportDispatchPerDispatchClass = {
  normal: SpWeightsWeightV2Weight;
  operational: SpWeightsWeightV2Weight;
  mandatory: SpWeightsWeightV2Weight;
};

export type SpWeightsWeightV2Weight = { refTime: bigint; proofSize: bigint };

export type FrameSystemEventRecord = {
  phase: FrameSystemPhase;
  event: KitchensinkRuntimeRuntimeEvent;
  topics: Array<H256>;
};

export type KitchensinkRuntimeRuntimeEvent =
  | { tag: 'System'; value: FrameSystemEvent }
  | { tag: 'Utility'; value: PalletUtilityEvent }
  | { tag: 'Indices'; value: PalletIndicesEvent }
  | { tag: 'Balances'; value: PalletBalancesEvent }
  | { tag: 'TransactionPayment'; value: PalletTransactionPaymentEvent }
  | { tag: 'AssetTxPayment'; value: PalletAssetTxPaymentEvent }
  | { tag: 'AssetConversionTxPayment'; value: PalletAssetConversionTxPaymentEvent }
  | { tag: 'ElectionProviderMultiPhase'; value: PalletElectionProviderMultiPhaseEvent }
  | { tag: 'Staking'; value: PalletStakingPalletEvent }
  | { tag: 'Session'; value: PalletSessionEvent }
  | { tag: 'Democracy'; value: PalletDemocracyEvent }
  | { tag: 'Council'; value: PalletCollectiveEvent }
  | { tag: 'TechnicalCommittee'; value: PalletCollectiveEvent }
  | { tag: 'Elections'; value: PalletElectionsPhragmenEvent }
  | { tag: 'TechnicalMembership'; value: PalletMembershipEvent }
  | { tag: 'Grandpa'; value: PalletGrandpaEvent }
  | { tag: 'Treasury'; value: PalletTreasuryEvent }
  | { tag: 'AssetRate'; value: PalletAssetRateEvent }
  | { tag: 'Contracts'; value: PalletContractsEvent }
  | { tag: 'Sudo'; value: PalletSudoEvent }
  | { tag: 'ImOnline'; value: PalletImOnlineEvent }
  | { tag: 'Offences'; value: PalletOffencesEvent }
  | { tag: 'Identity'; value: PalletIdentityEvent }
  | { tag: 'Society'; value: PalletSocietyEvent }
  | { tag: 'Recovery'; value: PalletRecoveryEvent }
  | { tag: 'Vesting'; value: PalletVestingEvent }
  | { tag: 'Scheduler'; value: PalletSchedulerEvent }
  | { tag: 'Glutton'; value: PalletGluttonEvent }
  | { tag: 'Preimage'; value: PalletPreimageEvent }
  | { tag: 'Proxy'; value: PalletProxyEvent }
  | { tag: 'Multisig'; value: PalletMultisigEvent }
  | { tag: 'Bounties'; value: PalletBountiesEvent }
  | { tag: 'Tips'; value: PalletTipsEvent }
  | { tag: 'Assets'; value: PalletAssetsEvent }
  | { tag: 'PoolAssets'; value: PalletAssetsEvent }
  | { tag: 'Lottery'; value: PalletLotteryEvent }
  | { tag: 'Nis'; value: PalletNisEvent }
  | { tag: 'Uniques'; value: PalletUniquesEvent }
  | { tag: 'Nfts'; value: PalletNftsEvent }
  | { tag: 'NftFractionalization'; value: PalletNftFractionalizationEvent }
  | { tag: 'Salary'; value: PalletSalaryEvent }
  | { tag: 'CoreFellowship'; value: PalletCoreFellowshipEvent }
  | { tag: 'TransactionStorage'; value: PalletTransactionStorageEvent }
  | { tag: 'VoterList'; value: PalletBagsListEvent }
  | { tag: 'StateTrieMigration'; value: PalletStateTrieMigrationEvent }
  | { tag: 'ChildBounties'; value: PalletChildBountiesEvent }
  | { tag: 'Referenda'; value: PalletReferendaEvent }
  | { tag: 'Remark'; value: PalletRemarkEvent }
  | { tag: 'ConvictionVoting'; value: PalletConvictionVotingEvent }
  | { tag: 'Whitelist'; value: PalletWhitelistEvent }
  | { tag: 'AllianceMotion'; value: PalletCollectiveEvent }
  | { tag: 'Alliance'; value: PalletAllianceEvent }
  | { tag: 'NominationPools'; value: PalletNominationPoolsEvent }
  | { tag: 'RankedPolls'; value: PalletReferendaEvent002 }
  | { tag: 'RankedCollective'; value: PalletRankedCollectiveEvent }
  | { tag: 'AssetConversion'; value: PalletAssetConversionEvent }
  | { tag: 'FastUnstake'; value: PalletFastUnstakeEvent }
  | { tag: 'MessageQueue'; value: PalletMessageQueueEvent }
  | { tag: 'Pov'; value: FrameBenchmarkingPalletPovEvent }
  | { tag: 'TxPause'; value: PalletTxPauseEvent }
  | { tag: 'SafeMode'; value: PalletSafeModeEvent }
  | { tag: 'Statement'; value: PalletStatementEvent }
  | { tag: 'Broker'; value: PalletBrokerEvent };

/**
 * Event for the System pallet.
 **/
export type FrameSystemEvent =
  | { tag: 'ExtrinsicSuccess'; value: { dispatchInfo: FrameSupportDispatchDispatchInfo } }
  | {
      tag: 'ExtrinsicFailed';
      value: { dispatchError: SpRuntimeDispatchError; dispatchInfo: FrameSupportDispatchDispatchInfo };
    }
  | { tag: 'CodeUpdated' }
  | { tag: 'NewAccount'; value: { account: AccountId32Like } }
  | { tag: 'KilledAccount'; value: { account: AccountId32Like } }
  | { tag: 'Remarked'; value: { sender: AccountId32Like; hash: H256 } };

export type FrameSupportDispatchDispatchInfo = {
  weight: SpWeightsWeightV2Weight;
  class: FrameSupportDispatchDispatchClass;
  paysFee: FrameSupportDispatchPays;
};

export type FrameSupportDispatchDispatchClass = 'Normal' | 'Operational' | 'Mandatory';

export type FrameSupportDispatchPays = 'Yes' | 'No';

export type SpRuntimeDispatchError =
  | { tag: 'Other' }
  | { tag: 'CannotLookup' }
  | { tag: 'BadOrigin' }
  | { tag: 'Module'; value: SpRuntimeModuleError }
  | { tag: 'ConsumerRemaining' }
  | { tag: 'NoProviders' }
  | { tag: 'TooManyConsumers' }
  | { tag: 'Token'; value: SpRuntimeTokenError }
  | { tag: 'Arithmetic'; value: SpArithmeticArithmeticError }
  | { tag: 'Transactional'; value: SpRuntimeTransactionalError }
  | { tag: 'Exhausted' }
  | { tag: 'Corruption' }
  | { tag: 'Unavailable' }
  | { tag: 'RootNotAllowed' };

export type SpRuntimeModuleError = { index: number; error: FixedBytes<4> };

export type SpRuntimeTokenError =
  | 'FundsUnavailable'
  | 'OnlyProvider'
  | 'BelowMinimum'
  | 'CannotCreate'
  | 'UnknownAsset'
  | 'Frozen'
  | 'Unsupported'
  | 'CannotCreateHold'
  | 'NotExpendable'
  | 'Blocked';

export type SpArithmeticArithmeticError = 'Underflow' | 'Overflow' | 'DivisionByZero';

export type SpRuntimeTransactionalError = 'LimitReached' | 'NoLayer';

/**
 * The `Event` enum of this pallet
 **/
export type PalletUtilityEvent =
  | { tag: 'BatchInterrupted'; value: { index: number; error: SpRuntimeDispatchError } }
  | { tag: 'BatchCompleted' }
  | { tag: 'BatchCompletedWithErrors' }
  | { tag: 'ItemCompleted' }
  | { tag: 'ItemFailed'; value: { error: SpRuntimeDispatchError } }
  | { tag: 'DispatchedAs'; value: { result: [] | SpRuntimeDispatchError } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletIndicesEvent =
  | { tag: 'IndexAssigned'; value: { who: AccountId32Like; index: number } }
  | { tag: 'IndexFreed'; value: { index: number } }
  | { tag: 'IndexFrozen'; value: { index: number; who: AccountId32Like } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletBalancesEvent =
  | { tag: 'Endowed'; value: { account: AccountId32Like; freeBalance: bigint } }
  | { tag: 'DustLost'; value: { account: AccountId32Like; amount: bigint } }
  | { tag: 'Transfer'; value: { from: AccountId32Like; to: AccountId32Like; amount: bigint } }
  | { tag: 'BalanceSet'; value: { who: AccountId32Like; free: bigint } }
  | { tag: 'Reserved'; value: { who: AccountId32Like; amount: bigint } }
  | { tag: 'Unreserved'; value: { who: AccountId32Like; amount: bigint } }
  | {
      tag: 'ReserveRepatriated';
      value: {
        from: AccountId32Like;
        to: AccountId32Like;
        amount: bigint;
        destinationStatus: FrameSupportTokensMiscBalanceStatus;
      };
    }
  | { tag: 'Deposit'; value: { who: AccountId32Like; amount: bigint } }
  | { tag: 'Withdraw'; value: { who: AccountId32Like; amount: bigint } }
  | { tag: 'Slashed'; value: { who: AccountId32Like; amount: bigint } }
  | { tag: 'Minted'; value: { who: AccountId32Like; amount: bigint } }
  | { tag: 'Burned'; value: { who: AccountId32Like; amount: bigint } }
  | { tag: 'Suspended'; value: { who: AccountId32Like; amount: bigint } }
  | { tag: 'Restored'; value: { who: AccountId32Like; amount: bigint } }
  | { tag: 'Upgraded'; value: { who: AccountId32Like } }
  | { tag: 'Issued'; value: { amount: bigint } }
  | { tag: 'Rescinded'; value: { amount: bigint } }
  | { tag: 'Locked'; value: { who: AccountId32Like; amount: bigint } }
  | { tag: 'Unlocked'; value: { who: AccountId32Like; amount: bigint } }
  | { tag: 'Frozen'; value: { who: AccountId32Like; amount: bigint } }
  | { tag: 'Thawed'; value: { who: AccountId32Like; amount: bigint } };

export type FrameSupportTokensMiscBalanceStatus = 'Free' | 'Reserved';

/**
 * The `Event` enum of this pallet
 **/
export type PalletTransactionPaymentEvent = {
  tag: 'TransactionFeePaid';
  value: { who: AccountId32Like; actualFee: bigint; tip: bigint };
};

/**
 * The `Event` enum of this pallet
 **/
export type PalletAssetTxPaymentEvent = {
  tag: 'AssetTxFeePaid';
  value: { who: AccountId32Like; actualFee: bigint; tip: bigint; assetId?: number | undefined };
};

/**
 * The `Event` enum of this pallet
 **/
export type PalletAssetConversionTxPaymentEvent =
  | { tag: 'AssetTxFeePaid'; value: { who: AccountId32Like; actualFee: bigint; tip: bigint; assetId: number } }
  | { tag: 'AssetRefundFailed'; value: { nativeAmountKept: bigint } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletElectionProviderMultiPhaseEvent =
  | {
      tag: 'SolutionStored';
      value: {
        compute: PalletElectionProviderMultiPhaseElectionCompute;
        origin?: AccountId32Like | undefined;
        prevEjected: boolean;
      };
    }
  | {
      tag: 'ElectionFinalized';
      value: { compute: PalletElectionProviderMultiPhaseElectionCompute; score: SpNposElectionsElectionScore };
    }
  | { tag: 'ElectionFailed' }
  | { tag: 'Rewarded'; value: { account: AccountId32Like; value: bigint } }
  | { tag: 'Slashed'; value: { account: AccountId32Like; value: bigint } }
  | {
      tag: 'PhaseTransitioned';
      value: { from: PalletElectionProviderMultiPhasePhase; to: PalletElectionProviderMultiPhasePhase; round: number };
    };

export type PalletElectionProviderMultiPhaseElectionCompute =
  | 'OnChain'
  | 'Signed'
  | 'Unsigned'
  | 'Fallback'
  | 'Emergency';

export type SpNposElectionsElectionScore = { minimalStake: bigint; sumStake: bigint; sumStakeSquared: bigint };

export type PalletElectionProviderMultiPhasePhase =
  | { tag: 'Off' }
  | { tag: 'Signed' }
  | { tag: 'Unsigned'; value: [boolean, number] }
  | { tag: 'Emergency' };

/**
 * The `Event` enum of this pallet
 **/
export type PalletStakingPalletEvent =
  | { tag: 'EraPaid'; value: { eraIndex: number; validatorPayout: bigint; remainder: bigint } }
  | { tag: 'Rewarded'; value: { stash: AccountId32Like; amount: bigint } }
  | { tag: 'Slashed'; value: { staker: AccountId32Like; amount: bigint } }
  | { tag: 'SlashReported'; value: { validator: AccountId32Like; fraction: Perbill; slashEra: number } }
  | { tag: 'OldSlashingReportDiscarded'; value: { sessionIndex: number } }
  | { tag: 'StakersElected' }
  | { tag: 'Bonded'; value: { stash: AccountId32Like; amount: bigint } }
  | { tag: 'Unbonded'; value: { stash: AccountId32Like; amount: bigint } }
  | { tag: 'Withdrawn'; value: { stash: AccountId32Like; amount: bigint } }
  | { tag: 'Kicked'; value: { nominator: AccountId32Like; stash: AccountId32Like } }
  | { tag: 'StakingElectionFailed' }
  | { tag: 'Chilled'; value: { stash: AccountId32Like } }
  | { tag: 'PayoutStarted'; value: { eraIndex: number; validatorStash: AccountId32Like } }
  | { tag: 'ValidatorPrefsSet'; value: { stash: AccountId32Like; prefs: PalletStakingValidatorPrefs } }
  | { tag: 'SnapshotVotersSizeExceeded'; value: { size: number } }
  | { tag: 'SnapshotTargetsSizeExceeded'; value: { size: number } }
  | { tag: 'ForceEra'; value: { mode: PalletStakingForcing } };

export type PalletStakingValidatorPrefs = { commission: Perbill; blocked: boolean };

export type PalletStakingForcing = 'NotForcing' | 'ForceNew' | 'ForceNone' | 'ForceAlways';

/**
 * The `Event` enum of this pallet
 **/
export type PalletSessionEvent = { tag: 'NewSession'; value: { sessionIndex: number } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletDemocracyEvent =
  | { tag: 'Proposed'; value: { proposalIndex: number; deposit: bigint } }
  | { tag: 'Tabled'; value: { proposalIndex: number; deposit: bigint } }
  | { tag: 'ExternalTabled' }
  | { tag: 'Started'; value: { refIndex: number; threshold: PalletDemocracyVoteThreshold } }
  | { tag: 'Passed'; value: { refIndex: number } }
  | { tag: 'NotPassed'; value: { refIndex: number } }
  | { tag: 'Cancelled'; value: { refIndex: number } }
  | { tag: 'Delegated'; value: { who: AccountId32Like; target: AccountId32Like } }
  | { tag: 'Undelegated'; value: { account: AccountId32Like } }
  | { tag: 'Vetoed'; value: { who: AccountId32Like; proposalHash: H256; until: number } }
  | { tag: 'Blacklisted'; value: { proposalHash: H256 } }
  | { tag: 'Voted'; value: { voter: AccountId32Like; refIndex: number; vote: PalletDemocracyVoteAccountVote } }
  | { tag: 'Seconded'; value: { seconder: AccountId32Like; propIndex: number } }
  | { tag: 'ProposalCanceled'; value: { propIndex: number } }
  | {
      tag: 'MetadataSet';
      value: {
        /**
         * Metadata owner.
         **/
        owner: PalletDemocracyMetadataOwner;

        /**
         * Preimage hash.
         **/
        hash: H256;
      };
    }
  | {
      tag: 'MetadataCleared';
      value: {
        /**
         * Metadata owner.
         **/
        owner: PalletDemocracyMetadataOwner;

        /**
         * Preimage hash.
         **/
        hash: H256;
      };
    }
  | {
      tag: 'MetadataTransferred';
      value: {
        /**
         * Previous metadata owner.
         **/
        prevOwner: PalletDemocracyMetadataOwner;

        /**
         * New metadata owner.
         **/
        owner: PalletDemocracyMetadataOwner;

        /**
         * Preimage hash.
         **/
        hash: H256;
      };
    };

export type PalletDemocracyVoteThreshold = 'SuperMajorityApprove' | 'SuperMajorityAgainst' | 'SimpleMajority';

export type PalletDemocracyVoteAccountVote =
  | { tag: 'Standard'; value: { vote: PalletDemocracyVote; balance: bigint } }
  | { tag: 'Split'; value: { aye: bigint; nay: bigint } };

export type PalletDemocracyVote = number;

export type PalletDemocracyMetadataOwner =
  | { tag: 'External' }
  | { tag: 'Proposal'; value: number }
  | { tag: 'Referendum'; value: number };

/**
 * The `Event` enum of this pallet
 **/
export type PalletCollectiveEvent =
  | {
      tag: 'Proposed';
      value: { account: AccountId32Like; proposalIndex: number; proposalHash: H256; threshold: number };
    }
  | { tag: 'Voted'; value: { account: AccountId32Like; proposalHash: H256; voted: boolean; yes: number; no: number } }
  | { tag: 'Approved'; value: { proposalHash: H256 } }
  | { tag: 'Disapproved'; value: { proposalHash: H256 } }
  | { tag: 'Executed'; value: { proposalHash: H256; result: [] | SpRuntimeDispatchError } }
  | { tag: 'MemberExecuted'; value: { proposalHash: H256; result: [] | SpRuntimeDispatchError } }
  | { tag: 'Closed'; value: { proposalHash: H256; yes: number; no: number } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletElectionsPhragmenEvent =
  | { tag: 'NewTerm'; value: { newMembers: Array<[AccountId32Like, bigint]> } }
  | { tag: 'EmptyTerm' }
  | { tag: 'ElectionError' }
  | { tag: 'MemberKicked'; value: { member: AccountId32Like } }
  | { tag: 'Renounced'; value: { candidate: AccountId32Like } }
  | { tag: 'CandidateSlashed'; value: { candidate: AccountId32Like; amount: bigint } }
  | { tag: 'SeatHolderSlashed'; value: { seatHolder: AccountId32Like; amount: bigint } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletMembershipEvent =
  /**
   * The given member was added; see the transaction for who.
   **/
  | 'MemberAdded'
  /**
   * The given member was removed; see the transaction for who.
   **/
  | 'MemberRemoved'
  /**
   * Two members were swapped; see the transaction for who.
   **/
  | 'MembersSwapped'
  /**
   * The membership was reset; see the transaction for who the new set is.
   **/
  | 'MembersReset'
  /**
   * One of the members' keys changed.
   **/
  | 'KeyChanged'
  /**
   * Phantom member, never used.
   **/
  | 'Dummy';

/**
 * The `Event` enum of this pallet
 **/
export type PalletGrandpaEvent =
  | { tag: 'NewAuthorities'; value: { authoritySet: Array<[SpConsensusGrandpaAppPublic, bigint]> } }
  | { tag: 'Paused' }
  | { tag: 'Resumed' };

export type SpConsensusGrandpaAppPublic = SpCoreEd25519Public;

export type SpCoreEd25519Public = FixedBytes<32>;

/**
 * The `Event` enum of this pallet
 **/
export type PalletTreasuryEvent =
  | { tag: 'Proposed'; value: { proposalIndex: number } }
  | { tag: 'Spending'; value: { budgetRemaining: bigint } }
  | { tag: 'Awarded'; value: { proposalIndex: number; award: bigint; account: AccountId32Like } }
  | { tag: 'Rejected'; value: { proposalIndex: number; slashed: bigint } }
  | { tag: 'Burnt'; value: { burntFunds: bigint } }
  | { tag: 'Rollover'; value: { rolloverBalance: bigint } }
  | { tag: 'Deposit'; value: { value: bigint } }
  | { tag: 'SpendApproved'; value: { proposalIndex: number; amount: bigint; beneficiary: AccountId32Like } }
  | { tag: 'UpdatedInactive'; value: { reactivated: bigint; deactivated: bigint } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletAssetRateEvent =
  | { tag: 'AssetRateCreated'; value: { assetKind: number; rate: FixedU128 } }
  | { tag: 'AssetRateRemoved'; value: { assetKind: number } }
  | { tag: 'AssetRateUpdated'; value: { assetKind: number; old: FixedU128; new: FixedU128 } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletContractsEvent =
  | { tag: 'Instantiated'; value: { deployer: AccountId32Like; contract: AccountId32Like } }
  | {
      tag: 'Terminated';
      value: {
        /**
         * The contract that was terminated.
         **/
        contract: AccountId32Like;

        /**
         * The account that received the contracts remaining balance
         **/
        beneficiary: AccountId32Like;
      };
    }
  | { tag: 'CodeStored'; value: { codeHash: H256; depositHeld: bigint; uploader: AccountId32Like } }
  | {
      tag: 'ContractEmitted';
      value: {
        /**
         * The contract that emitted the event.
         **/
        contract: AccountId32Like;

        /**
         * Data supplied by the contract. Metadata generated during contract compilation
         * is needed to decode it.
         **/
        data: Bytes;
      };
    }
  | { tag: 'CodeRemoved'; value: { codeHash: H256; depositReleased: bigint; remover: AccountId32Like } }
  | {
      tag: 'ContractCodeUpdated';
      value: {
        /**
         * The contract that has been updated.
         **/
        contract: AccountId32Like;

        /**
         * New code hash that was set for the contract.
         **/
        newCodeHash: H256;

        /**
         * Previous code hash of the contract.
         **/
        oldCodeHash: H256;
      };
    }
  | {
      tag: 'Called';
      value: {
        /**
         * The caller of the `contract`.
         **/
        caller: PalletContractsOrigin;

        /**
         * The contract that was called.
         **/
        contract: AccountId32Like;
      };
    }
  | {
      tag: 'DelegateCalled';
      value: {
        /**
         * The contract that performed the delegate call and hence in whose context
         * the `code_hash` is executed.
         **/
        contract: AccountId32Like;

        /**
         * The code hash that was delegate called.
         **/
        codeHash: H256;
      };
    }
  | { tag: 'StorageDepositTransferredAndHeld'; value: { from: AccountId32Like; to: AccountId32Like; amount: bigint } }
  | {
      tag: 'StorageDepositTransferredAndReleased';
      value: { from: AccountId32Like; to: AccountId32Like; amount: bigint };
    };

export type PalletContractsOrigin = { tag: 'Root' } | { tag: 'Signed'; value: AccountId32Like };

export type KitchensinkRuntimeRuntime = {};

/**
 * The `Event` enum of this pallet
 **/
export type PalletSudoEvent =
  | { tag: 'Sudid'; value: { sudoResult: [] | SpRuntimeDispatchError } }
  | { tag: 'KeyChanged'; value: { oldSudoer?: AccountId32Like | undefined } }
  | { tag: 'SudoAsDone'; value: { sudoResult: [] | SpRuntimeDispatchError } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletImOnlineEvent =
  | { tag: 'HeartbeatReceived'; value: { authorityId: PalletImOnlineSr25519AppSr25519Public } }
  | { tag: 'AllGood' }
  | { tag: 'SomeOffline'; value: { offline: Array<[AccountId32Like, PalletStakingExposure]> } };

export type PalletImOnlineSr25519AppSr25519Public = SpCoreSr25519Public;

export type SpCoreSr25519Public = FixedBytes<32>;

export type PalletStakingExposure = { total: bigint; own: bigint; others: Array<PalletStakingIndividualExposure> };

export type PalletStakingIndividualExposure = { who: AccountId32Like; value: bigint };

/**
 * Events type.
 **/
export type PalletOffencesEvent = { tag: 'Offence'; value: { kind: FixedBytes<16>; timeslot: Bytes } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletIdentityEvent =
  | { tag: 'IdentitySet'; value: { who: AccountId32Like } }
  | { tag: 'IdentityCleared'; value: { who: AccountId32Like; deposit: bigint } }
  | { tag: 'IdentityKilled'; value: { who: AccountId32Like; deposit: bigint } }
  | { tag: 'JudgementRequested'; value: { who: AccountId32Like; registrarIndex: number } }
  | { tag: 'JudgementUnrequested'; value: { who: AccountId32Like; registrarIndex: number } }
  | { tag: 'JudgementGiven'; value: { target: AccountId32Like; registrarIndex: number } }
  | { tag: 'RegistrarAdded'; value: { registrarIndex: number } }
  | { tag: 'SubIdentityAdded'; value: { sub: AccountId32Like; main: AccountId32Like; deposit: bigint } }
  | { tag: 'SubIdentityRemoved'; value: { sub: AccountId32Like; main: AccountId32Like; deposit: bigint } }
  | { tag: 'SubIdentityRevoked'; value: { sub: AccountId32Like; main: AccountId32Like; deposit: bigint } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletSocietyEvent =
  | { tag: 'Founded'; value: { founder: AccountId32Like } }
  | { tag: 'Bid'; value: { candidateId: AccountId32Like; offer: bigint } }
  | { tag: 'Vouch'; value: { candidateId: AccountId32Like; offer: bigint; vouching: AccountId32Like } }
  | { tag: 'AutoUnbid'; value: { candidate: AccountId32Like } }
  | { tag: 'Unbid'; value: { candidate: AccountId32Like } }
  | { tag: 'Unvouch'; value: { candidate: AccountId32Like } }
  | { tag: 'Inducted'; value: { primary: AccountId32Like; candidates: Array<AccountId32Like> } }
  | { tag: 'SuspendedMemberJudgement'; value: { who: AccountId32Like; judged: boolean } }
  | { tag: 'CandidateSuspended'; value: { candidate: AccountId32Like } }
  | { tag: 'MemberSuspended'; value: { member: AccountId32Like } }
  | { tag: 'Challenged'; value: { member: AccountId32Like } }
  | { tag: 'Vote'; value: { candidate: AccountId32Like; voter: AccountId32Like; vote: boolean } }
  | { tag: 'DefenderVote'; value: { voter: AccountId32Like; vote: boolean } }
  | { tag: 'NewParams'; value: { params: PalletSocietyGroupParams } }
  | { tag: 'Unfounded'; value: { founder: AccountId32Like } }
  | { tag: 'Deposit'; value: { value: bigint } }
  | { tag: 'Elevated'; value: { member: AccountId32Like; rank: number } };

export type PalletSocietyGroupParams = {
  maxMembers: number;
  maxIntake: number;
  maxStrikes: number;
  candidateDeposit: bigint;
};

/**
 * Events type.
 **/
export type PalletRecoveryEvent =
  | { tag: 'RecoveryCreated'; value: { account: AccountId32Like } }
  | { tag: 'RecoveryInitiated'; value: { lostAccount: AccountId32Like; rescuerAccount: AccountId32Like } }
  | {
      tag: 'RecoveryVouched';
      value: { lostAccount: AccountId32Like; rescuerAccount: AccountId32Like; sender: AccountId32Like };
    }
  | { tag: 'RecoveryClosed'; value: { lostAccount: AccountId32Like; rescuerAccount: AccountId32Like } }
  | { tag: 'AccountRecovered'; value: { lostAccount: AccountId32Like; rescuerAccount: AccountId32Like } }
  | { tag: 'RecoveryRemoved'; value: { lostAccount: AccountId32Like } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletVestingEvent =
  | { tag: 'VestingUpdated'; value: { account: AccountId32Like; unvested: bigint } }
  | { tag: 'VestingCompleted'; value: { account: AccountId32Like } };

/**
 * Events type.
 **/
export type PalletSchedulerEvent =
  | { tag: 'Scheduled'; value: { when: number; index: number } }
  | { tag: 'Canceled'; value: { when: number; index: number } }
  | {
      tag: 'Dispatched';
      value: { task: [number, number]; id?: FixedBytes<32> | undefined; result: [] | SpRuntimeDispatchError };
    }
  | { tag: 'CallUnavailable'; value: { task: [number, number]; id?: FixedBytes<32> | undefined } }
  | { tag: 'PeriodicFailed'; value: { task: [number, number]; id?: FixedBytes<32> | undefined } }
  | { tag: 'PermanentlyOverweight'; value: { task: [number, number]; id?: FixedBytes<32> | undefined } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletGluttonEvent =
  | {
      tag: 'PalletInitialized';
      value: {
        /**
         * Whether the pallet has been re-initialized.
         **/
        reinit: boolean;
      };
    }
  | {
      tag: 'ComputationLimitSet';
      value: {
        /**
         * The computation limit.
         **/
        compute: FixedU64;
      };
    }
  | {
      tag: 'StorageLimitSet';
      value: {
        /**
         * The storage limit.
         **/
        storage: FixedU64;
      };
    };

/**
 * The `Event` enum of this pallet
 **/
export type PalletPreimageEvent =
  | { tag: 'Noted'; value: { hash: H256 } }
  | { tag: 'Requested'; value: { hash: H256 } }
  | { tag: 'Cleared'; value: { hash: H256 } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletProxyEvent =
  | { tag: 'ProxyExecuted'; value: { result: [] | SpRuntimeDispatchError } }
  | {
      tag: 'PureCreated';
      value: {
        pure: AccountId32Like;
        who: AccountId32Like;
        proxyType: KitchensinkRuntimeProxyType;
        disambiguationIndex: number;
      };
    }
  | { tag: 'Announced'; value: { real: AccountId32Like; proxy: AccountId32Like; callHash: H256 } }
  | {
      tag: 'ProxyAdded';
      value: {
        delegator: AccountId32Like;
        delegatee: AccountId32Like;
        proxyType: KitchensinkRuntimeProxyType;
        delay: number;
      };
    }
  | {
      tag: 'ProxyRemoved';
      value: {
        delegator: AccountId32Like;
        delegatee: AccountId32Like;
        proxyType: KitchensinkRuntimeProxyType;
        delay: number;
      };
    };

export type KitchensinkRuntimeProxyType = 'Any' | 'NonTransfer' | 'Governance' | 'Staking';

/**
 * The `Event` enum of this pallet
 **/
export type PalletMultisigEvent =
  | { tag: 'NewMultisig'; value: { approving: AccountId32Like; multisig: AccountId32Like; callHash: FixedBytes<32> } }
  | {
      tag: 'MultisigApproval';
      value: {
        approving: AccountId32Like;
        timepoint: PalletMultisigTimepoint;
        multisig: AccountId32Like;
        callHash: FixedBytes<32>;
      };
    }
  | {
      tag: 'MultisigExecuted';
      value: {
        approving: AccountId32Like;
        timepoint: PalletMultisigTimepoint;
        multisig: AccountId32Like;
        callHash: FixedBytes<32>;
        result: [] | SpRuntimeDispatchError;
      };
    }
  | {
      tag: 'MultisigCancelled';
      value: {
        cancelling: AccountId32Like;
        timepoint: PalletMultisigTimepoint;
        multisig: AccountId32Like;
        callHash: FixedBytes<32>;
      };
    };

export type PalletMultisigTimepoint = { height: number; index: number };

/**
 * The `Event` enum of this pallet
 **/
export type PalletBountiesEvent =
  | { tag: 'BountyProposed'; value: { index: number } }
  | { tag: 'BountyRejected'; value: { index: number; bond: bigint } }
  | { tag: 'BountyBecameActive'; value: { index: number } }
  | { tag: 'BountyAwarded'; value: { index: number; beneficiary: AccountId32Like } }
  | { tag: 'BountyClaimed'; value: { index: number; payout: bigint; beneficiary: AccountId32Like } }
  | { tag: 'BountyCanceled'; value: { index: number } }
  | { tag: 'BountyExtended'; value: { index: number } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletTipsEvent =
  | { tag: 'NewTip'; value: { tipHash: H256 } }
  | { tag: 'TipClosing'; value: { tipHash: H256 } }
  | { tag: 'TipClosed'; value: { tipHash: H256; who: AccountId32Like; payout: bigint } }
  | { tag: 'TipRetracted'; value: { tipHash: H256 } }
  | { tag: 'TipSlashed'; value: { tipHash: H256; finder: AccountId32Like; deposit: bigint } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletAssetsEvent =
  | { tag: 'Created'; value: { assetId: number; creator: AccountId32Like; owner: AccountId32Like } }
  | { tag: 'Issued'; value: { assetId: number; owner: AccountId32Like; amount: bigint } }
  | { tag: 'Transferred'; value: { assetId: number; from: AccountId32Like; to: AccountId32Like; amount: bigint } }
  | { tag: 'Burned'; value: { assetId: number; owner: AccountId32Like; balance: bigint } }
  | {
      tag: 'TeamChanged';
      value: { assetId: number; issuer: AccountId32Like; admin: AccountId32Like; freezer: AccountId32Like };
    }
  | { tag: 'OwnerChanged'; value: { assetId: number; owner: AccountId32Like } }
  | { tag: 'Frozen'; value: { assetId: number; who: AccountId32Like } }
  | { tag: 'Thawed'; value: { assetId: number; who: AccountId32Like } }
  | { tag: 'AssetFrozen'; value: { assetId: number } }
  | { tag: 'AssetThawed'; value: { assetId: number } }
  | { tag: 'AccountsDestroyed'; value: { assetId: number; accountsDestroyed: number; accountsRemaining: number } }
  | { tag: 'ApprovalsDestroyed'; value: { assetId: number; approvalsDestroyed: number; approvalsRemaining: number } }
  | { tag: 'DestructionStarted'; value: { assetId: number } }
  | { tag: 'Destroyed'; value: { assetId: number } }
  | { tag: 'ForceCreated'; value: { assetId: number; owner: AccountId32Like } }
  | { tag: 'MetadataSet'; value: { assetId: number; name: Bytes; symbol: Bytes; decimals: number; isFrozen: boolean } }
  | { tag: 'MetadataCleared'; value: { assetId: number } }
  | {
      tag: 'ApprovedTransfer';
      value: { assetId: number; source: AccountId32Like; delegate: AccountId32Like; amount: bigint };
    }
  | { tag: 'ApprovalCancelled'; value: { assetId: number; owner: AccountId32Like; delegate: AccountId32Like } }
  | {
      tag: 'TransferredApproved';
      value: {
        assetId: number;
        owner: AccountId32Like;
        delegate: AccountId32Like;
        destination: AccountId32Like;
        amount: bigint;
      };
    }
  | { tag: 'AssetStatusChanged'; value: { assetId: number } }
  | { tag: 'AssetMinBalanceChanged'; value: { assetId: number; newMinBalance: bigint } }
  | { tag: 'Touched'; value: { assetId: number; who: AccountId32Like; depositor: AccountId32Like } }
  | { tag: 'Blocked'; value: { assetId: number; who: AccountId32Like } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletLotteryEvent =
  | { tag: 'LotteryStarted' }
  | { tag: 'CallsUpdated' }
  | { tag: 'Winner'; value: { winner: AccountId32Like; lotteryBalance: bigint } }
  | { tag: 'TicketBought'; value: { who: AccountId32Like; callIndex: [number, number] } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletNisEvent =
  | { tag: 'BidPlaced'; value: { who: AccountId32Like; amount: bigint; duration: number } }
  | { tag: 'BidRetracted'; value: { who: AccountId32Like; amount: bigint; duration: number } }
  | { tag: 'BidDropped'; value: { who: AccountId32Like; amount: bigint; duration: number } }
  | {
      tag: 'Issued';
      value: {
        /**
         * The identity of the receipt.
         **/
        index: number;

        /**
         * The block number at which the receipt may be thawed.
         **/
        expiry: number;

        /**
         * The owner of the receipt.
         **/
        who: AccountId32Like;

        /**
         * The proportion of the effective total issuance which the receipt represents.
         **/
        proportion: Perquintill;

        /**
         * The amount of funds which were debited from the owner.
         **/
        amount: bigint;
      };
    }
  | {
      tag: 'Thawed';
      value: {
        /**
         * The identity of the receipt.
         **/
        index: number;

        /**
         * The owner.
         **/
        who: AccountId32Like;

        /**
         * The proportion of the effective total issuance by which the owner was debited.
         **/
        proportion: Perquintill;

        /**
         * The amount by which the owner was credited.
         **/
        amount: bigint;

        /**
         * If `true` then the receipt is done.
         **/
        dropped: boolean;
      };
    }
  | { tag: 'Funded'; value: { deficit: bigint } }
  | { tag: 'Transferred'; value: { from: AccountId32Like; to: AccountId32Like; index: number } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletUniquesEvent =
  | { tag: 'Created'; value: { collection: number; creator: AccountId32Like; owner: AccountId32Like } }
  | { tag: 'ForceCreated'; value: { collection: number; owner: AccountId32Like } }
  | { tag: 'Destroyed'; value: { collection: number } }
  | { tag: 'Issued'; value: { collection: number; item: number; owner: AccountId32Like } }
  | { tag: 'Transferred'; value: { collection: number; item: number; from: AccountId32Like; to: AccountId32Like } }
  | { tag: 'Burned'; value: { collection: number; item: number; owner: AccountId32Like } }
  | { tag: 'Frozen'; value: { collection: number; item: number } }
  | { tag: 'Thawed'; value: { collection: number; item: number } }
  | { tag: 'CollectionFrozen'; value: { collection: number } }
  | { tag: 'CollectionThawed'; value: { collection: number } }
  | { tag: 'OwnerChanged'; value: { collection: number; newOwner: AccountId32Like } }
  | {
      tag: 'TeamChanged';
      value: { collection: number; issuer: AccountId32Like; admin: AccountId32Like; freezer: AccountId32Like };
    }
  | {
      tag: 'ApprovedTransfer';
      value: { collection: number; item: number; owner: AccountId32Like; delegate: AccountId32Like };
    }
  | {
      tag: 'ApprovalCancelled';
      value: { collection: number; item: number; owner: AccountId32Like; delegate: AccountId32Like };
    }
  | { tag: 'ItemStatusChanged'; value: { collection: number } }
  | { tag: 'CollectionMetadataSet'; value: { collection: number; data: Bytes; isFrozen: boolean } }
  | { tag: 'CollectionMetadataCleared'; value: { collection: number } }
  | { tag: 'MetadataSet'; value: { collection: number; item: number; data: Bytes; isFrozen: boolean } }
  | { tag: 'MetadataCleared'; value: { collection: number; item: number } }
  | { tag: 'Redeposited'; value: { collection: number; successfulItems: Array<number> } }
  | { tag: 'AttributeSet'; value: { collection: number; maybeItem?: number | undefined; key: Bytes; value: Bytes } }
  | { tag: 'AttributeCleared'; value: { collection: number; maybeItem?: number | undefined; key: Bytes } }
  | { tag: 'OwnershipAcceptanceChanged'; value: { who: AccountId32Like; maybeCollection?: number | undefined } }
  | { tag: 'CollectionMaxSupplySet'; value: { collection: number; maxSupply: number } }
  | {
      tag: 'ItemPriceSet';
      value: { collection: number; item: number; price: bigint; whitelistedBuyer?: AccountId32Like | undefined };
    }
  | { tag: 'ItemPriceRemoved'; value: { collection: number; item: number } }
  | {
      tag: 'ItemBought';
      value: { collection: number; item: number; price: bigint; seller: AccountId32Like; buyer: AccountId32Like };
    };

/**
 * The `Event` enum of this pallet
 **/
export type PalletNftsEvent =
  | { tag: 'Created'; value: { collection: number; creator: AccountId32Like; owner: AccountId32Like } }
  | { tag: 'ForceCreated'; value: { collection: number; owner: AccountId32Like } }
  | { tag: 'Destroyed'; value: { collection: number } }
  | { tag: 'Issued'; value: { collection: number; item: number; owner: AccountId32Like } }
  | { tag: 'Transferred'; value: { collection: number; item: number; from: AccountId32Like; to: AccountId32Like } }
  | { tag: 'Burned'; value: { collection: number; item: number; owner: AccountId32Like } }
  | { tag: 'ItemTransferLocked'; value: { collection: number; item: number } }
  | { tag: 'ItemTransferUnlocked'; value: { collection: number; item: number } }
  | {
      tag: 'ItemPropertiesLocked';
      value: { collection: number; item: number; lockMetadata: boolean; lockAttributes: boolean };
    }
  | { tag: 'CollectionLocked'; value: { collection: number } }
  | { tag: 'OwnerChanged'; value: { collection: number; newOwner: AccountId32Like } }
  | {
      tag: 'TeamChanged';
      value: {
        collection: number;
        issuer?: AccountId32Like | undefined;
        admin?: AccountId32Like | undefined;
        freezer?: AccountId32Like | undefined;
      };
    }
  | {
      tag: 'TransferApproved';
      value: {
        collection: number;
        item: number;
        owner: AccountId32Like;
        delegate: AccountId32Like;
        deadline?: number | undefined;
      };
    }
  | {
      tag: 'ApprovalCancelled';
      value: { collection: number; item: number; owner: AccountId32Like; delegate: AccountId32Like };
    }
  | { tag: 'AllApprovalsCancelled'; value: { collection: number; item: number; owner: AccountId32Like } }
  | { tag: 'CollectionConfigChanged'; value: { collection: number } }
  | { tag: 'CollectionMetadataSet'; value: { collection: number; data: Bytes } }
  | { tag: 'CollectionMetadataCleared'; value: { collection: number } }
  | { tag: 'ItemMetadataSet'; value: { collection: number; item: number; data: Bytes } }
  | { tag: 'ItemMetadataCleared'; value: { collection: number; item: number } }
  | { tag: 'Redeposited'; value: { collection: number; successfulItems: Array<number> } }
  | {
      tag: 'AttributeSet';
      value: {
        collection: number;
        maybeItem?: number | undefined;
        key: Bytes;
        value: Bytes;
        namespace: PalletNftsAttributeNamespace;
      };
    }
  | {
      tag: 'AttributeCleared';
      value: {
        collection: number;
        maybeItem?: number | undefined;
        key: Bytes;
        namespace: PalletNftsAttributeNamespace;
      };
    }
  | { tag: 'ItemAttributesApprovalAdded'; value: { collection: number; item: number; delegate: AccountId32Like } }
  | { tag: 'ItemAttributesApprovalRemoved'; value: { collection: number; item: number; delegate: AccountId32Like } }
  | { tag: 'OwnershipAcceptanceChanged'; value: { who: AccountId32Like; maybeCollection?: number | undefined } }
  | { tag: 'CollectionMaxSupplySet'; value: { collection: number; maxSupply: number } }
  | { tag: 'CollectionMintSettingsUpdated'; value: { collection: number } }
  | { tag: 'NextCollectionIdIncremented'; value: { nextId?: number | undefined } }
  | {
      tag: 'ItemPriceSet';
      value: { collection: number; item: number; price: bigint; whitelistedBuyer?: AccountId32Like | undefined };
    }
  | { tag: 'ItemPriceRemoved'; value: { collection: number; item: number } }
  | {
      tag: 'ItemBought';
      value: { collection: number; item: number; price: bigint; seller: AccountId32Like; buyer: AccountId32Like };
    }
  | {
      tag: 'TipSent';
      value: { collection: number; item: number; sender: AccountId32Like; receiver: AccountId32Like; amount: bigint };
    }
  | {
      tag: 'SwapCreated';
      value: {
        offeredCollection: number;
        offeredItem: number;
        desiredCollection: number;
        desiredItem?: number | undefined;
        price?: PalletNftsPriceWithDirection | undefined;
        deadline: number;
      };
    }
  | {
      tag: 'SwapCancelled';
      value: {
        offeredCollection: number;
        offeredItem: number;
        desiredCollection: number;
        desiredItem?: number | undefined;
        price?: PalletNftsPriceWithDirection | undefined;
        deadline: number;
      };
    }
  | {
      tag: 'SwapClaimed';
      value: {
        sentCollection: number;
        sentItem: number;
        sentItemOwner: AccountId32Like;
        receivedCollection: number;
        receivedItem: number;
        receivedItemOwner: AccountId32Like;
        price?: PalletNftsPriceWithDirection | undefined;
        deadline: number;
      };
    }
  | {
      tag: 'PreSignedAttributesSet';
      value: { collection: number; item: number; namespace: PalletNftsAttributeNamespace };
    }
  | {
      tag: 'PalletAttributeSet';
      value: { collection: number; item?: number | undefined; attribute: PalletNftsPalletAttributes; value: Bytes };
    };

export type PalletNftsAttributeNamespace =
  | { tag: 'Pallet' }
  | { tag: 'CollectionOwner' }
  | { tag: 'ItemOwner' }
  | { tag: 'Account'; value: AccountId32Like };

export type PalletNftsPriceWithDirection = { amount: bigint; direction: PalletNftsPriceDirection };

export type PalletNftsPriceDirection = 'Send' | 'Receive';

export type PalletNftsPalletAttributes = { tag: 'UsedToClaim'; value: number } | { tag: 'TransferDisabled' };

/**
 * The `Event` enum of this pallet
 **/
export type PalletNftFractionalizationEvent =
  | {
      tag: 'NftFractionalized';
      value: { nftCollection: number; nft: number; fractions: bigint; asset: number; beneficiary: AccountId32Like };
    }
  | { tag: 'NftUnified'; value: { nftCollection: number; nft: number; asset: number; beneficiary: AccountId32Like } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletSalaryEvent =
  | { tag: 'Inducted'; value: { who: AccountId32Like } }
  | { tag: 'Registered'; value: { who: AccountId32Like; amount: bigint } }
  | { tag: 'Paid'; value: { who: AccountId32Like; beneficiary: AccountId32Like; amount: bigint; id: [] } }
  | { tag: 'CycleStarted'; value: { index: number } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletCoreFellowshipEvent =
  | { tag: 'ParamsChanged'; value: { params: PalletCoreFellowshipParamsType } }
  | { tag: 'ActiveChanged'; value: { who: AccountId32Like; isActive: boolean } }
  | { tag: 'Inducted'; value: { who: AccountId32Like } }
  | { tag: 'Offboarded'; value: { who: AccountId32Like } }
  | { tag: 'Promoted'; value: { who: AccountId32Like; toRank: number } }
  | { tag: 'Demoted'; value: { who: AccountId32Like; toRank: number } }
  | { tag: 'Proven'; value: { who: AccountId32Like; atRank: number } }
  | { tag: 'Requested'; value: { who: AccountId32Like; wish: PalletCoreFellowshipWish } }
  | {
      tag: 'EvidenceJudged';
      value: {
        /**
         * The member/candidate.
         **/
        who: AccountId32Like;

        /**
         * The desired outcome for which the evidence was presented.
         **/
        wish: PalletCoreFellowshipWish;

        /**
         * The evidence of efforts.
         **/
        evidence: Bytes;

        /**
         * The old rank, prior to this change.
         **/
        oldRank: number;

        /**
         * New rank. If `None` then candidate record was removed entirely.
         **/
        newRank?: number | undefined;
      };
    }
  | { tag: 'Imported'; value: { who: AccountId32Like; rank: number } };

export type PalletCoreFellowshipParamsType = {
  activeSalary: FixedArray<bigint, 9>;
  passiveSalary: FixedArray<bigint, 9>;
  demotionPeriod: FixedArray<number, 9>;
  minPromotionPeriod: FixedArray<number, 9>;
  offboardTimeout: number;
};

export type PalletCoreFellowshipWish = 'Retention' | 'Promotion';

/**
 * The `Event` enum of this pallet
 **/
export type PalletTransactionStorageEvent =
  | { tag: 'Stored'; value: { index: number } }
  | { tag: 'Renewed'; value: { index: number } }
  | { tag: 'ProofChecked' };

/**
 * The `Event` enum of this pallet
 **/
export type PalletBagsListEvent =
  | { tag: 'Rebagged'; value: { who: AccountId32Like; from: bigint; to: bigint } }
  | { tag: 'ScoreUpdated'; value: { who: AccountId32Like; newScore: bigint } };

/**
 * Inner events of this pallet.
 **/
export type PalletStateTrieMigrationEvent =
  | { tag: 'Migrated'; value: { top: number; child: number; compute: PalletStateTrieMigrationMigrationCompute } }
  | { tag: 'Slashed'; value: { who: AccountId32Like; amount: bigint } }
  | { tag: 'AutoMigrationFinished' }
  | { tag: 'Halted'; value: { error: PalletStateTrieMigrationError } };

export type PalletStateTrieMigrationMigrationCompute = 'Signed' | 'Auto';

/**
 * The `Error` enum of this pallet.
 **/
export type PalletStateTrieMigrationError =
  /**
   * Max signed limits not respected.
   **/
  | 'MaxSignedLimits'
  /**
   * A key was longer than the configured maximum.
   *
   * This means that the migration halted at the current [`Progress`] and
   * can be resumed with a larger [`crate::Config::MaxKeyLen`] value.
   * Retrying with the same [`crate::Config::MaxKeyLen`] value will not work.
   * The value should only be increased to avoid a storage migration for the currently
   * stored [`crate::Progress::LastKey`].
   **/
  | 'KeyTooLong'
  /**
   * submitter does not have enough funds.
   **/
  | 'NotEnoughFunds'
  /**
   * Bad witness data provided.
   **/
  | 'BadWitness'
  /**
   * Signed migration is not allowed because the maximum limit is not set yet.
   **/
  | 'SignedMigrationNotAllowed'
  /**
   * Bad child root provided.
   **/
  | 'BadChildRoot';

/**
 * The `Event` enum of this pallet
 **/
export type PalletChildBountiesEvent =
  | { tag: 'Added'; value: { index: number; childIndex: number } }
  | { tag: 'Awarded'; value: { index: number; childIndex: number; beneficiary: AccountId32Like } }
  | { tag: 'Claimed'; value: { index: number; childIndex: number; payout: bigint; beneficiary: AccountId32Like } }
  | { tag: 'Canceled'; value: { index: number; childIndex: number } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletReferendaEvent =
  | {
      tag: 'Submitted';
      value: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The track (and by extension proposal dispatch origin) of this referendum.
         **/
        track: number;

        /**
         * The proposal for the referendum.
         **/
        proposal: FrameSupportPreimagesBounded;
      };
    }
  | {
      tag: 'DecisionDepositPlaced';
      value: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The account who placed the deposit.
         **/
        who: AccountId32Like;

        /**
         * The amount placed by the account.
         **/
        amount: bigint;
      };
    }
  | {
      tag: 'DecisionDepositRefunded';
      value: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The account who placed the deposit.
         **/
        who: AccountId32Like;

        /**
         * The amount placed by the account.
         **/
        amount: bigint;
      };
    }
  | {
      tag: 'DepositSlashed';
      value: {
        /**
         * The account who placed the deposit.
         **/
        who: AccountId32Like;

        /**
         * The amount placed by the account.
         **/
        amount: bigint;
      };
    }
  | {
      tag: 'DecisionStarted';
      value: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The track (and by extension proposal dispatch origin) of this referendum.
         **/
        track: number;

        /**
         * The proposal for the referendum.
         **/
        proposal: FrameSupportPreimagesBounded;

        /**
         * The current tally of votes in this referendum.
         **/
        tally: PalletConvictionVotingTally;
      };
    }
  | {
      tag: 'ConfirmStarted';
      value: {
        /**
         * Index of the referendum.
         **/
        index: number;
      };
    }
  | {
      tag: 'ConfirmAborted';
      value: {
        /**
         * Index of the referendum.
         **/
        index: number;
      };
    }
  | {
      tag: 'Confirmed';
      value: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The final tally of votes in this referendum.
         **/
        tally: PalletConvictionVotingTally;
      };
    }
  | {
      tag: 'Approved';
      value: {
        /**
         * Index of the referendum.
         **/
        index: number;
      };
    }
  | {
      tag: 'Rejected';
      value: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The final tally of votes in this referendum.
         **/
        tally: PalletConvictionVotingTally;
      };
    }
  | {
      tag: 'TimedOut';
      value: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The final tally of votes in this referendum.
         **/
        tally: PalletConvictionVotingTally;
      };
    }
  | {
      tag: 'Cancelled';
      value: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The final tally of votes in this referendum.
         **/
        tally: PalletConvictionVotingTally;
      };
    }
  | {
      tag: 'Killed';
      value: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The final tally of votes in this referendum.
         **/
        tally: PalletConvictionVotingTally;
      };
    }
  | {
      tag: 'SubmissionDepositRefunded';
      value: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The account who placed the deposit.
         **/
        who: AccountId32Like;

        /**
         * The amount placed by the account.
         **/
        amount: bigint;
      };
    }
  | {
      tag: 'MetadataSet';
      value: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * Preimage hash.
         **/
        hash: H256;
      };
    }
  | {
      tag: 'MetadataCleared';
      value: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * Preimage hash.
         **/
        hash: H256;
      };
    };

export type FrameSupportPreimagesBounded =
  | { tag: 'Legacy'; value: { hash: H256 } }
  | { tag: 'Inline'; value: Bytes }
  | { tag: 'Lookup'; value: { hash: H256; len: number } };

export type KitchensinkRuntimeRuntimeCall =
  | { tag: 'System'; value: FrameSystemCall }
  | { tag: 'Utility'; value: PalletUtilityCall }
  | { tag: 'Babe'; value: PalletBabeCall }
  | { tag: 'Timestamp'; value: PalletTimestampCall }
  | { tag: 'Indices'; value: PalletIndicesCall }
  | { tag: 'Balances'; value: PalletBalancesCall }
  | { tag: 'ElectionProviderMultiPhase'; value: PalletElectionProviderMultiPhaseCall }
  | { tag: 'Staking'; value: PalletStakingPalletCall }
  | { tag: 'Session'; value: PalletSessionCall }
  | { tag: 'Democracy'; value: PalletDemocracyCall }
  | { tag: 'Council'; value: PalletCollectiveCall }
  | { tag: 'TechnicalCommittee'; value: PalletCollectiveCall }
  | { tag: 'Elections'; value: PalletElectionsPhragmenCall }
  | { tag: 'TechnicalMembership'; value: PalletMembershipCall }
  | { tag: 'Grandpa'; value: PalletGrandpaCall }
  | { tag: 'Treasury'; value: PalletTreasuryCall }
  | { tag: 'AssetRate'; value: PalletAssetRateCall }
  | { tag: 'Contracts'; value: PalletContractsCall }
  | { tag: 'Sudo'; value: PalletSudoCall }
  | { tag: 'ImOnline'; value: PalletImOnlineCall }
  | { tag: 'Identity'; value: PalletIdentityCall }
  | { tag: 'Society'; value: PalletSocietyCall }
  | { tag: 'Recovery'; value: PalletRecoveryCall }
  | { tag: 'Vesting'; value: PalletVestingCall }
  | { tag: 'Scheduler'; value: PalletSchedulerCall }
  | { tag: 'Glutton'; value: PalletGluttonCall }
  | { tag: 'Preimage'; value: PalletPreimageCall }
  | { tag: 'Proxy'; value: PalletProxyCall }
  | { tag: 'Multisig'; value: PalletMultisigCall }
  | { tag: 'Bounties'; value: PalletBountiesCall }
  | { tag: 'Tips'; value: PalletTipsCall }
  | { tag: 'Assets'; value: PalletAssetsCall }
  | { tag: 'PoolAssets'; value: PalletAssetsCall }
  | { tag: 'Lottery'; value: PalletLotteryCall }
  | { tag: 'Nis'; value: PalletNisCall }
  | { tag: 'Uniques'; value: PalletUniquesCall }
  | { tag: 'Nfts'; value: PalletNftsCall }
  | { tag: 'NftFractionalization'; value: PalletNftFractionalizationCall }
  | { tag: 'Salary'; value: PalletSalaryCall }
  | { tag: 'CoreFellowship'; value: PalletCoreFellowshipCall }
  | { tag: 'TransactionStorage'; value: PalletTransactionStorageCall }
  | { tag: 'VoterList'; value: PalletBagsListCall }
  | { tag: 'StateTrieMigration'; value: PalletStateTrieMigrationCall }
  | { tag: 'ChildBounties'; value: PalletChildBountiesCall }
  | { tag: 'Referenda'; value: PalletReferendaCall }
  | { tag: 'Remark'; value: PalletRemarkCall }
  | { tag: 'RootTesting'; value: PalletRootTestingCall }
  | { tag: 'ConvictionVoting'; value: PalletConvictionVotingCall }
  | { tag: 'Whitelist'; value: PalletWhitelistCall }
  | { tag: 'AllianceMotion'; value: PalletCollectiveCall }
  | { tag: 'Alliance'; value: PalletAllianceCall }
  | { tag: 'NominationPools'; value: PalletNominationPoolsCall }
  | { tag: 'RankedPolls'; value: PalletReferendaCall }
  | { tag: 'RankedCollective'; value: PalletRankedCollectiveCall }
  | { tag: 'AssetConversion'; value: PalletAssetConversionCall }
  | { tag: 'FastUnstake'; value: PalletFastUnstakeCall }
  | { tag: 'MessageQueue'; value: PalletMessageQueueCall }
  | { tag: 'Pov'; value: FrameBenchmarkingPalletPovCall }
  | { tag: 'TxPause'; value: PalletTxPauseCall }
  | { tag: 'SafeMode'; value: PalletSafeModeCall }
  | { tag: 'Broker'; value: PalletBrokerCall };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type FrameSystemCall =
  | { tag: 'Remark'; value: { remark: Bytes } }
  | { tag: 'SetHeapPages'; value: { pages: bigint } }
  | { tag: 'SetCode'; value: { code: Bytes } }
  | { tag: 'SetCodeWithoutChecks'; value: { code: Bytes } }
  | { tag: 'SetStorage'; value: { items: Array<[Bytes, Bytes]> } }
  | { tag: 'KillStorage'; value: { keys: Array<Bytes> } }
  | { tag: 'KillPrefix'; value: { prefix: Bytes; subkeys: number } }
  | { tag: 'RemarkWithEvent'; value: { remark: Bytes } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletUtilityCall =
  | { tag: 'Batch'; value: { calls: Array<KitchensinkRuntimeRuntimeCall> } }
  | { tag: 'AsDerivative'; value: { index: number; call: KitchensinkRuntimeRuntimeCall } }
  | { tag: 'BatchAll'; value: { calls: Array<KitchensinkRuntimeRuntimeCall> } }
  | { tag: 'DispatchAs'; value: { asOrigin: KitchensinkRuntimeOriginCaller; call: KitchensinkRuntimeRuntimeCall } }
  | { tag: 'ForceBatch'; value: { calls: Array<KitchensinkRuntimeRuntimeCall> } }
  | { tag: 'WithWeight'; value: { call: KitchensinkRuntimeRuntimeCall; weight: SpWeightsWeightV2Weight } };

export type KitchensinkRuntimeOriginCaller =
  | { tag: 'System'; value: FrameSupportDispatchRawOrigin }
  | { tag: 'Council'; value: PalletCollectiveRawOrigin }
  | { tag: 'TechnicalCommittee'; value: PalletCollectiveRawOrigin }
  | { tag: 'AllianceMotion'; value: PalletCollectiveRawOrigin }
  | { tag: 'Void'; value: SpCoreVoid };

export type FrameSupportDispatchRawOrigin =
  | { tag: 'Root' }
  | { tag: 'Signed'; value: AccountId32Like }
  | { tag: 'None' };

export type PalletCollectiveRawOrigin =
  | { tag: 'Members'; value: [number, number] }
  | { tag: 'Member'; value: AccountId32Like }
  | { tag: 'Phantom' };

export type SpCoreVoid = null;

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletBabeCall =
  | {
      tag: 'ReportEquivocation';
      value: { equivocationProof: SpConsensusSlotsEquivocationProof; keyOwnerProof: SpSessionMembershipProof };
    }
  | {
      tag: 'ReportEquivocationUnsigned';
      value: { equivocationProof: SpConsensusSlotsEquivocationProof; keyOwnerProof: SpSessionMembershipProof };
    }
  | { tag: 'PlanConfigChange'; value: { config: SpConsensusBabeDigestsNextConfigDescriptor } };

export type SpConsensusSlotsEquivocationProof = {
  offender: SpConsensusBabeAppPublic;
  slot: SpConsensusSlotsSlot;
  firstHeader: Header;
  secondHeader: Header;
};

export type SpConsensusBabeAppPublic = SpCoreSr25519Public;

export type SpConsensusSlotsSlot = bigint;

export type SpSessionMembershipProof = { session: number; trieNodes: Array<Bytes>; validatorCount: number };

export type SpConsensusBabeDigestsNextConfigDescriptor = {
  tag: 'V1';
  value: { c: [bigint, bigint]; allowedSlots: SpConsensusBabeAllowedSlots };
};

export type SpConsensusBabeAllowedSlots =
  | 'PrimarySlots'
  | 'PrimaryAndSecondaryPlainSlots'
  | 'PrimaryAndSecondaryVRFSlots';

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletTimestampCall = { tag: 'Set'; value: { now: bigint } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletIndicesCall =
  | { tag: 'Claim'; value: { index: number } }
  | { tag: 'Transfer'; value: { new: MultiAddress; index: number } }
  | { tag: 'Free'; value: { index: number } }
  | { tag: 'ForceTransfer'; value: { new: MultiAddress; index: number; freeze: boolean } }
  | { tag: 'Freeze'; value: { index: number } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletBalancesCall =
  | { tag: 'TransferAllowDeath'; value: { dest: MultiAddress; value: bigint } }
  | { tag: 'SetBalanceDeprecated'; value: { who: MultiAddress; newFree: bigint; oldReserved: bigint } }
  | { tag: 'ForceTransfer'; value: { source: MultiAddress; dest: MultiAddress; value: bigint } }
  | { tag: 'TransferKeepAlive'; value: { dest: MultiAddress; value: bigint } }
  | { tag: 'TransferAll'; value: { dest: MultiAddress; keepAlive: boolean } }
  | { tag: 'ForceUnreserve'; value: { who: MultiAddress; amount: bigint } }
  | { tag: 'UpgradeAccounts'; value: { who: Array<AccountId32Like> } }
  | { tag: 'Transfer'; value: { dest: MultiAddress; value: bigint } }
  | { tag: 'ForceSetBalance'; value: { who: MultiAddress; newFree: bigint } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletElectionProviderMultiPhaseCall =
  | {
      tag: 'SubmitUnsigned';
      value: {
        rawSolution: PalletElectionProviderMultiPhaseRawSolution;
        witness: PalletElectionProviderMultiPhaseSolutionOrSnapshotSize;
      };
    }
  | { tag: 'SetMinimumUntrustedScore'; value: { maybeNextScore?: SpNposElectionsElectionScore | undefined } }
  | { tag: 'SetEmergencyElectionResult'; value: { supports: Array<[AccountId32Like, SpNposElectionsSupport]> } }
  | { tag: 'Submit'; value: { rawSolution: PalletElectionProviderMultiPhaseRawSolution } }
  | { tag: 'GovernanceFallback'; value: { maybeMaxVoters?: number | undefined; maybeMaxTargets?: number | undefined } };

export type PalletElectionProviderMultiPhaseRawSolution = {
  solution: KitchensinkRuntimeNposSolution16;
  score: SpNposElectionsElectionScore;
  round: number;
};

export type KitchensinkRuntimeNposSolution16 = {
  votes1: Array<[number, number]>;
  votes2: Array<[number, [number, PerU16], number]>;
  votes3: Array<[number, FixedArray<[number, PerU16], 2>, number]>;
  votes4: Array<[number, FixedArray<[number, PerU16], 3>, number]>;
  votes5: Array<[number, FixedArray<[number, PerU16], 4>, number]>;
  votes6: Array<[number, FixedArray<[number, PerU16], 5>, number]>;
  votes7: Array<[number, FixedArray<[number, PerU16], 6>, number]>;
  votes8: Array<[number, FixedArray<[number, PerU16], 7>, number]>;
  votes9: Array<[number, FixedArray<[number, PerU16], 8>, number]>;
  votes10: Array<[number, FixedArray<[number, PerU16], 9>, number]>;
  votes11: Array<[number, FixedArray<[number, PerU16], 10>, number]>;
  votes12: Array<[number, FixedArray<[number, PerU16], 11>, number]>;
  votes13: Array<[number, FixedArray<[number, PerU16], 12>, number]>;
  votes14: Array<[number, FixedArray<[number, PerU16], 13>, number]>;
  votes15: Array<[number, FixedArray<[number, PerU16], 14>, number]>;
  votes16: Array<[number, FixedArray<[number, PerU16], 15>, number]>;
};

export type PalletElectionProviderMultiPhaseSolutionOrSnapshotSize = { voters: number; targets: number };

export type SpNposElectionsSupport = { total: bigint; voters: Array<[AccountId32Like, bigint]> };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletStakingPalletCall =
  | { tag: 'Bond'; value: { value: bigint; payee: PalletStakingRewardDestination } }
  | { tag: 'BondExtra'; value: { maxAdditional: bigint } }
  | { tag: 'Unbond'; value: { value: bigint } }
  | { tag: 'WithdrawUnbonded'; value: { numSlashingSpans: number } }
  | { tag: 'Validate'; value: { prefs: PalletStakingValidatorPrefs } }
  | { tag: 'Nominate'; value: { targets: Array<MultiAddress> } }
  | { tag: 'Chill' }
  | { tag: 'SetPayee'; value: { payee: PalletStakingRewardDestination } }
  | { tag: 'SetController' }
  | { tag: 'SetValidatorCount'; value: { new: number } }
  | { tag: 'IncreaseValidatorCount'; value: { additional: number } }
  | { tag: 'ScaleValidatorCount'; value: { factor: Percent } }
  | { tag: 'ForceNoEras' }
  | { tag: 'ForceNewEra' }
  | { tag: 'SetInvulnerables'; value: { invulnerables: Array<AccountId32Like> } }
  | { tag: 'ForceUnstake'; value: { stash: AccountId32Like; numSlashingSpans: number } }
  | { tag: 'ForceNewEraAlways' }
  | { tag: 'CancelDeferredSlash'; value: { era: number; slashIndices: Array<number> } }
  | { tag: 'PayoutStakers'; value: { validatorStash: AccountId32Like; era: number } }
  | { tag: 'Rebond'; value: { value: bigint } }
  | { tag: 'ReapStash'; value: { stash: AccountId32Like; numSlashingSpans: number } }
  | { tag: 'Kick'; value: { who: Array<MultiAddress> } }
  | {
      tag: 'SetStakingConfigs';
      value: {
        minNominatorBond: PalletStakingPalletConfigOp;
        minValidatorBond: PalletStakingPalletConfigOp;
        maxNominatorCount: PalletStakingPalletConfigOpU32;
        maxValidatorCount: PalletStakingPalletConfigOpU32;
        chillThreshold: PalletStakingPalletConfigOpPercent;
        minCommission: PalletStakingPalletConfigOpPerbill;
      };
    }
  | { tag: 'ChillOther'; value: { controller: AccountId32Like } }
  | { tag: 'ForceApplyMinCommission'; value: { validatorStash: AccountId32Like } }
  | { tag: 'SetMinCommission'; value: { new: Perbill } };

export type PalletStakingRewardDestination =
  | { tag: 'Staked' }
  | { tag: 'Stash' }
  | { tag: 'Controller' }
  | { tag: 'Account'; value: AccountId32Like }
  | { tag: 'None' };

export type PalletStakingPalletConfigOp = { tag: 'Noop' } | { tag: 'Set'; value: bigint } | { tag: 'Remove' };

export type PalletStakingPalletConfigOpU32 = { tag: 'Noop' } | { tag: 'Set'; value: number } | { tag: 'Remove' };

export type PalletStakingPalletConfigOpPercent = { tag: 'Noop' } | { tag: 'Set'; value: Percent } | { tag: 'Remove' };

export type PalletStakingPalletConfigOpPerbill = { tag: 'Noop' } | { tag: 'Set'; value: Perbill } | { tag: 'Remove' };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletSessionCall =
  | { tag: 'SetKeys'; value: { keys: KitchensinkRuntimeSessionKeys; proof: Bytes } }
  | { tag: 'PurgeKeys' };

export type KitchensinkRuntimeSessionKeys = {
  grandpa: SpConsensusGrandpaAppPublic;
  babe: SpConsensusBabeAppPublic;
  imOnline: PalletImOnlineSr25519AppSr25519Public;
  authorityDiscovery: SpAuthorityDiscoveryAppPublic;
};

export type SpAuthorityDiscoveryAppPublic = SpCoreSr25519Public;

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletDemocracyCall =
  | { tag: 'Propose'; value: { proposal: FrameSupportPreimagesBounded; value: bigint } }
  | { tag: 'Second'; value: { proposal: number } }
  | { tag: 'Vote'; value: { refIndex: number; vote: PalletDemocracyVoteAccountVote } }
  | { tag: 'EmergencyCancel'; value: { refIndex: number } }
  | { tag: 'ExternalPropose'; value: { proposal: FrameSupportPreimagesBounded } }
  | { tag: 'ExternalProposeMajority'; value: { proposal: FrameSupportPreimagesBounded } }
  | { tag: 'ExternalProposeDefault'; value: { proposal: FrameSupportPreimagesBounded } }
  | { tag: 'FastTrack'; value: { proposalHash: H256; votingPeriod: number; delay: number } }
  | { tag: 'VetoExternal'; value: { proposalHash: H256 } }
  | { tag: 'CancelReferendum'; value: { refIndex: number } }
  | { tag: 'Delegate'; value: { to: MultiAddress; conviction: PalletDemocracyConviction; balance: bigint } }
  | { tag: 'Undelegate' }
  | { tag: 'ClearPublicProposals' }
  | { tag: 'Unlock'; value: { target: MultiAddress } }
  | { tag: 'RemoveVote'; value: { index: number } }
  | { tag: 'RemoveOtherVote'; value: { target: MultiAddress; index: number } }
  | { tag: 'Blacklist'; value: { proposalHash: H256; maybeRefIndex?: number | undefined } }
  | { tag: 'CancelProposal'; value: { propIndex: number } }
  | { tag: 'SetMetadata'; value: { owner: PalletDemocracyMetadataOwner; maybeHash?: H256 | undefined } };

export type PalletDemocracyConviction =
  | 'None'
  | 'Locked1x'
  | 'Locked2x'
  | 'Locked3x'
  | 'Locked4x'
  | 'Locked5x'
  | 'Locked6x';

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletCollectiveCall =
  | {
      tag: 'SetMembers';
      value: { newMembers: Array<AccountId32Like>; prime?: AccountId32Like | undefined; oldCount: number };
    }
  | { tag: 'Execute'; value: { proposal: KitchensinkRuntimeRuntimeCall; lengthBound: number } }
  | { tag: 'Propose'; value: { threshold: number; proposal: KitchensinkRuntimeRuntimeCall; lengthBound: number } }
  | { tag: 'Vote'; value: { proposal: H256; index: number; approve: boolean } }
  | { tag: 'DisapproveProposal'; value: { proposalHash: H256 } }
  | {
      tag: 'Close';
      value: { proposalHash: H256; index: number; proposalWeightBound: SpWeightsWeightV2Weight; lengthBound: number };
    };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletElectionsPhragmenCall =
  | { tag: 'Vote'; value: { votes: Array<AccountId32Like>; value: bigint } }
  | { tag: 'RemoveVoter' }
  | { tag: 'SubmitCandidacy'; value: { candidateCount: number } }
  | { tag: 'RenounceCandidacy'; value: { renouncing: PalletElectionsPhragmenRenouncing } }
  | { tag: 'RemoveMember'; value: { who: MultiAddress; slashBond: boolean; rerunElection: boolean } }
  | { tag: 'CleanDefunctVoters'; value: { numVoters: number; numDefunct: number } };

export type PalletElectionsPhragmenRenouncing =
  | { tag: 'Member' }
  | { tag: 'RunnerUp' }
  | { tag: 'Candidate'; value: number };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletMembershipCall =
  | { tag: 'AddMember'; value: { who: MultiAddress } }
  | { tag: 'RemoveMember'; value: { who: MultiAddress } }
  | { tag: 'SwapMember'; value: { remove: MultiAddress; add: MultiAddress } }
  | { tag: 'ResetMembers'; value: { members: Array<AccountId32Like> } }
  | { tag: 'ChangeKey'; value: { new: MultiAddress } }
  | { tag: 'SetPrime'; value: { who: MultiAddress } }
  | { tag: 'ClearPrime' };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletGrandpaCall =
  | {
      tag: 'ReportEquivocation';
      value: { equivocationProof: SpConsensusGrandpaEquivocationProof; keyOwnerProof: SpSessionMembershipProof };
    }
  | {
      tag: 'ReportEquivocationUnsigned';
      value: { equivocationProof: SpConsensusGrandpaEquivocationProof; keyOwnerProof: SpSessionMembershipProof };
    }
  | { tag: 'NoteStalled'; value: { delay: number; bestFinalizedBlockNumber: number } };

export type SpConsensusGrandpaEquivocationProof = { setId: bigint; equivocation: SpConsensusGrandpaEquivocation };

export type SpConsensusGrandpaEquivocation =
  | { tag: 'Prevote'; value: FinalityGrandpaEquivocation }
  | { tag: 'Precommit'; value: FinalityGrandpaEquivocationPrecommit };

export type FinalityGrandpaEquivocation = {
  roundNumber: bigint;
  identity: SpConsensusGrandpaAppPublic;
  first: [FinalityGrandpaPrevote, SpConsensusGrandpaAppSignature];
  second: [FinalityGrandpaPrevote, SpConsensusGrandpaAppSignature];
};

export type FinalityGrandpaPrevote = { targetHash: H256; targetNumber: number };

export type SpConsensusGrandpaAppSignature = SpCoreEd25519Signature;

export type SpCoreEd25519Signature = FixedBytes<64>;

export type FinalityGrandpaEquivocationPrecommit = {
  roundNumber: bigint;
  identity: SpConsensusGrandpaAppPublic;
  first: [FinalityGrandpaPrecommit, SpConsensusGrandpaAppSignature];
  second: [FinalityGrandpaPrecommit, SpConsensusGrandpaAppSignature];
};

export type FinalityGrandpaPrecommit = { targetHash: H256; targetNumber: number };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletTreasuryCall =
  | { tag: 'ProposeSpend'; value: { value: bigint; beneficiary: MultiAddress } }
  | { tag: 'RejectProposal'; value: { proposalId: number } }
  | { tag: 'ApproveProposal'; value: { proposalId: number } }
  | { tag: 'Spend'; value: { amount: bigint; beneficiary: MultiAddress } }
  | { tag: 'RemoveApproval'; value: { proposalId: number } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletAssetRateCall =
  | { tag: 'Create'; value: { assetKind: number; rate: FixedU128 } }
  | { tag: 'Update'; value: { assetKind: number; rate: FixedU128 } }
  | { tag: 'Remove'; value: { assetKind: number } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletContractsCall =
  | {
      tag: 'CallOldWeight';
      value: {
        dest: MultiAddress;
        value: bigint;
        gasLimit: bigint;
        storageDepositLimit?: bigint | undefined;
        data: Bytes;
      };
    }
  | {
      tag: 'InstantiateWithCodeOldWeight';
      value: {
        value: bigint;
        gasLimit: bigint;
        storageDepositLimit?: bigint | undefined;
        code: Bytes;
        data: Bytes;
        salt: Bytes;
      };
    }
  | {
      tag: 'InstantiateOldWeight';
      value: {
        value: bigint;
        gasLimit: bigint;
        storageDepositLimit?: bigint | undefined;
        codeHash: H256;
        data: Bytes;
        salt: Bytes;
      };
    }
  | {
      tag: 'UploadCode';
      value: { code: Bytes; storageDepositLimit?: bigint | undefined; determinism: PalletContractsWasmDeterminism };
    }
  | { tag: 'RemoveCode'; value: { codeHash: H256 } }
  | { tag: 'SetCode'; value: { dest: MultiAddress; codeHash: H256 } }
  | {
      tag: 'Call';
      value: {
        dest: MultiAddress;
        value: bigint;
        gasLimit: SpWeightsWeightV2Weight;
        storageDepositLimit?: bigint | undefined;
        data: Bytes;
      };
    }
  | {
      tag: 'InstantiateWithCode';
      value: {
        value: bigint;
        gasLimit: SpWeightsWeightV2Weight;
        storageDepositLimit?: bigint | undefined;
        code: Bytes;
        data: Bytes;
        salt: Bytes;
      };
    }
  | {
      tag: 'Instantiate';
      value: {
        value: bigint;
        gasLimit: SpWeightsWeightV2Weight;
        storageDepositLimit?: bigint | undefined;
        codeHash: H256;
        data: Bytes;
        salt: Bytes;
      };
    }
  | { tag: 'Migrate'; value: { weightLimit: SpWeightsWeightV2Weight } };

export type PalletContractsWasmDeterminism = 'Enforced' | 'Relaxed';

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletSudoCall =
  | { tag: 'Sudo'; value: { call: KitchensinkRuntimeRuntimeCall } }
  | { tag: 'SudoUncheckedWeight'; value: { call: KitchensinkRuntimeRuntimeCall; weight: SpWeightsWeightV2Weight } }
  | { tag: 'SetKey'; value: { new: MultiAddress } }
  | { tag: 'SudoAs'; value: { who: MultiAddress; call: KitchensinkRuntimeRuntimeCall } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletImOnlineCall = {
  tag: 'Heartbeat';
  value: { heartbeat: PalletImOnlineHeartbeat; signature: PalletImOnlineSr25519AppSr25519Signature };
};

export type PalletImOnlineHeartbeat = {
  blockNumber: number;
  sessionIndex: number;
  authorityIndex: number;
  validatorsLen: number;
};

export type PalletImOnlineSr25519AppSr25519Signature = SpCoreSr25519Signature;

export type SpCoreSr25519Signature = FixedBytes<64>;

/**
 * Identity pallet declaration.
 **/
export type PalletIdentityCall =
  | { tag: 'AddRegistrar'; value: { account: MultiAddress } }
  | { tag: 'SetIdentity'; value: { info: PalletIdentityIdentityInfo } }
  | { tag: 'SetSubs'; value: { subs: Array<[AccountId32Like, Data]> } }
  | { tag: 'ClearIdentity' }
  | { tag: 'RequestJudgement'; value: { regIndex: number; maxFee: bigint } }
  | { tag: 'CancelRequest'; value: { regIndex: number } }
  | { tag: 'SetFee'; value: { index: number; fee: bigint } }
  | { tag: 'SetAccountId'; value: { index: number; new: MultiAddress } }
  | { tag: 'SetFields'; value: { index: number; fields: PalletIdentityBitFlags } }
  | {
      tag: 'ProvideJudgement';
      value: { regIndex: number; target: MultiAddress; judgement: PalletIdentityJudgement; identity: H256 };
    }
  | { tag: 'KillIdentity'; value: { target: MultiAddress } }
  | { tag: 'AddSub'; value: { sub: MultiAddress; data: Data } }
  | { tag: 'RenameSub'; value: { sub: MultiAddress; data: Data } }
  | { tag: 'RemoveSub'; value: { sub: MultiAddress } }
  | { tag: 'QuitSub' };

export type PalletIdentityIdentityInfo = {
  additional: Array<[Data, Data]>;
  display: Data;
  legal: Data;
  web: Data;
  riot: Data;
  email: Data;
  pgpFingerprint?: FixedBytes<20> | undefined;
  image: Data;
  twitter: Data;
};

export type PalletIdentityBitFlags = bigint;

export type PalletIdentityIdentityField =
  | 'Display'
  | 'Legal'
  | 'Web'
  | 'Riot'
  | 'Email'
  | 'PgpFingerprint'
  | 'Image'
  | 'Twitter';

export type PalletIdentityJudgement =
  | { tag: 'Unknown' }
  | { tag: 'FeePaid'; value: bigint }
  | { tag: 'Reasonable' }
  | { tag: 'KnownGood' }
  | { tag: 'OutOfDate' }
  | { tag: 'LowQuality' }
  | { tag: 'Erroneous' };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletSocietyCall =
  | { tag: 'Bid'; value: { value: bigint } }
  | { tag: 'Unbid' }
  | { tag: 'Vouch'; value: { who: MultiAddress; value: bigint; tip: bigint } }
  | { tag: 'Unvouch' }
  | { tag: 'Vote'; value: { candidate: MultiAddress; approve: boolean } }
  | { tag: 'DefenderVote'; value: { approve: boolean } }
  | { tag: 'Payout' }
  | { tag: 'WaiveRepay'; value: { amount: bigint } }
  | {
      tag: 'FoundSociety';
      value: {
        founder: MultiAddress;
        maxMembers: number;
        maxIntake: number;
        maxStrikes: number;
        candidateDeposit: bigint;
        rules: Bytes;
      };
    }
  | { tag: 'Dissolve' }
  | { tag: 'JudgeSuspendedMember'; value: { who: MultiAddress; forgive: boolean } }
  | {
      tag: 'SetParameters';
      value: { maxMembers: number; maxIntake: number; maxStrikes: number; candidateDeposit: bigint };
    }
  | { tag: 'PunishSkeptic' }
  | { tag: 'ClaimMembership' }
  | { tag: 'BestowMembership'; value: { candidate: AccountId32Like } }
  | { tag: 'KickCandidate'; value: { candidate: AccountId32Like } }
  | { tag: 'ResignCandidacy' }
  | { tag: 'DropCandidate'; value: { candidate: AccountId32Like } }
  | { tag: 'CleanupCandidacy'; value: { candidate: AccountId32Like; max: number } }
  | { tag: 'CleanupChallenge'; value: { challengeRound: number; max: number } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletRecoveryCall =
  | { tag: 'AsRecovered'; value: { account: MultiAddress; call: KitchensinkRuntimeRuntimeCall } }
  | { tag: 'SetRecovered'; value: { lost: MultiAddress; rescuer: MultiAddress } }
  | { tag: 'CreateRecovery'; value: { friends: Array<AccountId32Like>; threshold: number; delayPeriod: number } }
  | { tag: 'InitiateRecovery'; value: { account: MultiAddress } }
  | { tag: 'VouchRecovery'; value: { lost: MultiAddress; rescuer: MultiAddress } }
  | { tag: 'ClaimRecovery'; value: { account: MultiAddress } }
  | { tag: 'CloseRecovery'; value: { rescuer: MultiAddress } }
  | { tag: 'RemoveRecovery' }
  | { tag: 'CancelRecovered'; value: { account: MultiAddress } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletVestingCall =
  | { tag: 'Vest' }
  | { tag: 'VestOther'; value: { target: MultiAddress } }
  | { tag: 'VestedTransfer'; value: { target: MultiAddress; schedule: PalletVestingVestingInfo } }
  | {
      tag: 'ForceVestedTransfer';
      value: { source: MultiAddress; target: MultiAddress; schedule: PalletVestingVestingInfo };
    }
  | { tag: 'MergeSchedules'; value: { schedule1Index: number; schedule2Index: number } };

export type PalletVestingVestingInfo = { locked: bigint; perBlock: bigint; startingBlock: number };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletSchedulerCall =
  | {
      tag: 'Schedule';
      value: {
        when: number;
        maybePeriodic?: [number, number] | undefined;
        priority: number;
        call: KitchensinkRuntimeRuntimeCall;
      };
    }
  | { tag: 'Cancel'; value: { when: number; index: number } }
  | {
      tag: 'ScheduleNamed';
      value: {
        id: FixedBytes<32>;
        when: number;
        maybePeriodic?: [number, number] | undefined;
        priority: number;
        call: KitchensinkRuntimeRuntimeCall;
      };
    }
  | { tag: 'CancelNamed'; value: { id: FixedBytes<32> } }
  | {
      tag: 'ScheduleAfter';
      value: {
        after: number;
        maybePeriodic?: [number, number] | undefined;
        priority: number;
        call: KitchensinkRuntimeRuntimeCall;
      };
    }
  | {
      tag: 'ScheduleNamedAfter';
      value: {
        id: FixedBytes<32>;
        after: number;
        maybePeriodic?: [number, number] | undefined;
        priority: number;
        call: KitchensinkRuntimeRuntimeCall;
      };
    };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletGluttonCall =
  | { tag: 'InitializePallet'; value: { newCount: number; witnessCount?: number | undefined } }
  | { tag: 'SetCompute'; value: { compute: FixedU64 } }
  | { tag: 'SetStorage'; value: { storage: FixedU64 } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletPreimageCall =
  | { tag: 'NotePreimage'; value: { bytes: Bytes } }
  | { tag: 'UnnotePreimage'; value: { hash: H256 } }
  | { tag: 'RequestPreimage'; value: { hash: H256 } }
  | { tag: 'UnrequestPreimage'; value: { hash: H256 } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletProxyCall =
  | {
      tag: 'Proxy';
      value: {
        real: MultiAddress;
        forceProxyType?: KitchensinkRuntimeProxyType | undefined;
        call: KitchensinkRuntimeRuntimeCall;
      };
    }
  | { tag: 'AddProxy'; value: { delegate: MultiAddress; proxyType: KitchensinkRuntimeProxyType; delay: number } }
  | { tag: 'RemoveProxy'; value: { delegate: MultiAddress; proxyType: KitchensinkRuntimeProxyType; delay: number } }
  | { tag: 'RemoveProxies' }
  | { tag: 'CreatePure'; value: { proxyType: KitchensinkRuntimeProxyType; delay: number; index: number } }
  | {
      tag: 'KillPure';
      value: {
        spawner: MultiAddress;
        proxyType: KitchensinkRuntimeProxyType;
        index: number;
        height: number;
        extIndex: number;
      };
    }
  | { tag: 'Announce'; value: { real: MultiAddress; callHash: H256 } }
  | { tag: 'RemoveAnnouncement'; value: { real: MultiAddress; callHash: H256 } }
  | { tag: 'RejectAnnouncement'; value: { delegate: MultiAddress; callHash: H256 } }
  | {
      tag: 'ProxyAnnounced';
      value: {
        delegate: MultiAddress;
        real: MultiAddress;
        forceProxyType?: KitchensinkRuntimeProxyType | undefined;
        call: KitchensinkRuntimeRuntimeCall;
      };
    };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletMultisigCall =
  | {
      tag: 'AsMultiThreshold1';
      value: { otherSignatories: Array<AccountId32Like>; call: KitchensinkRuntimeRuntimeCall };
    }
  | {
      tag: 'AsMulti';
      value: {
        threshold: number;
        otherSignatories: Array<AccountId32Like>;
        maybeTimepoint?: PalletMultisigTimepoint | undefined;
        call: KitchensinkRuntimeRuntimeCall;
        maxWeight: SpWeightsWeightV2Weight;
      };
    }
  | {
      tag: 'ApproveAsMulti';
      value: {
        threshold: number;
        otherSignatories: Array<AccountId32Like>;
        maybeTimepoint?: PalletMultisigTimepoint | undefined;
        callHash: FixedBytes<32>;
        maxWeight: SpWeightsWeightV2Weight;
      };
    }
  | {
      tag: 'CancelAsMulti';
      value: {
        threshold: number;
        otherSignatories: Array<AccountId32Like>;
        timepoint: PalletMultisigTimepoint;
        callHash: FixedBytes<32>;
      };
    };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletBountiesCall =
  | { tag: 'ProposeBounty'; value: { value: bigint; description: Bytes } }
  | { tag: 'ApproveBounty'; value: { bountyId: number } }
  | { tag: 'ProposeCurator'; value: { bountyId: number; curator: MultiAddress; fee: bigint } }
  | { tag: 'UnassignCurator'; value: { bountyId: number } }
  | { tag: 'AcceptCurator'; value: { bountyId: number } }
  | { tag: 'AwardBounty'; value: { bountyId: number; beneficiary: MultiAddress } }
  | { tag: 'ClaimBounty'; value: { bountyId: number } }
  | { tag: 'CloseBounty'; value: { bountyId: number } }
  | { tag: 'ExtendBountyExpiry'; value: { bountyId: number; remark: Bytes } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletTipsCall =
  | { tag: 'ReportAwesome'; value: { reason: Bytes; who: MultiAddress } }
  | { tag: 'RetractTip'; value: { hash: H256 } }
  | { tag: 'TipNew'; value: { reason: Bytes; who: MultiAddress; tipValue: bigint } }
  | { tag: 'Tip'; value: { hash: H256; tipValue: bigint } }
  | { tag: 'CloseTip'; value: { hash: H256 } }
  | { tag: 'SlashTip'; value: { hash: H256 } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletAssetsCall =
  | { tag: 'Create'; value: { id: number; admin: MultiAddress; minBalance: bigint } }
  | { tag: 'ForceCreate'; value: { id: number; owner: MultiAddress; isSufficient: boolean; minBalance: bigint } }
  | { tag: 'StartDestroy'; value: { id: number } }
  | { tag: 'DestroyAccounts'; value: { id: number } }
  | { tag: 'DestroyApprovals'; value: { id: number } }
  | { tag: 'FinishDestroy'; value: { id: number } }
  | { tag: 'Mint'; value: { id: number; beneficiary: MultiAddress; amount: bigint } }
  | { tag: 'Burn'; value: { id: number; who: MultiAddress; amount: bigint } }
  | { tag: 'Transfer'; value: { id: number; target: MultiAddress; amount: bigint } }
  | { tag: 'TransferKeepAlive'; value: { id: number; target: MultiAddress; amount: bigint } }
  | { tag: 'ForceTransfer'; value: { id: number; source: MultiAddress; dest: MultiAddress; amount: bigint } }
  | { tag: 'Freeze'; value: { id: number; who: MultiAddress } }
  | { tag: 'Thaw'; value: { id: number; who: MultiAddress } }
  | { tag: 'FreezeAsset'; value: { id: number } }
  | { tag: 'ThawAsset'; value: { id: number } }
  | { tag: 'TransferOwnership'; value: { id: number; owner: MultiAddress } }
  | { tag: 'SetTeam'; value: { id: number; issuer: MultiAddress; admin: MultiAddress; freezer: MultiAddress } }
  | { tag: 'SetMetadata'; value: { id: number; name: Bytes; symbol: Bytes; decimals: number } }
  | { tag: 'ClearMetadata'; value: { id: number } }
  | { tag: 'ForceSetMetadata'; value: { id: number; name: Bytes; symbol: Bytes; decimals: number; isFrozen: boolean } }
  | { tag: 'ForceClearMetadata'; value: { id: number } }
  | {
      tag: 'ForceAssetStatus';
      value: {
        id: number;
        owner: MultiAddress;
        issuer: MultiAddress;
        admin: MultiAddress;
        freezer: MultiAddress;
        minBalance: bigint;
        isSufficient: boolean;
        isFrozen: boolean;
      };
    }
  | { tag: 'ApproveTransfer'; value: { id: number; delegate: MultiAddress; amount: bigint } }
  | { tag: 'CancelApproval'; value: { id: number; delegate: MultiAddress } }
  | { tag: 'ForceCancelApproval'; value: { id: number; owner: MultiAddress; delegate: MultiAddress } }
  | { tag: 'TransferApproved'; value: { id: number; owner: MultiAddress; destination: MultiAddress; amount: bigint } }
  | { tag: 'Touch'; value: { id: number } }
  | { tag: 'Refund'; value: { id: number; allowBurn: boolean } }
  | { tag: 'SetMinBalance'; value: { id: number; minBalance: bigint } }
  | { tag: 'TouchOther'; value: { id: number; who: MultiAddress } }
  | { tag: 'RefundOther'; value: { id: number; who: MultiAddress } }
  | { tag: 'Block'; value: { id: number; who: MultiAddress } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletLotteryCall =
  | { tag: 'BuyTicket'; value: { call: KitchensinkRuntimeRuntimeCall } }
  | { tag: 'SetCalls'; value: { calls: Array<KitchensinkRuntimeRuntimeCall> } }
  | { tag: 'StartLottery'; value: { price: bigint; length: number; delay: number; repeat: boolean } }
  | { tag: 'StopRepeat' };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletNisCall =
  | { tag: 'PlaceBid'; value: { amount: bigint; duration: number } }
  | { tag: 'RetractBid'; value: { amount: bigint; duration: number } }
  | { tag: 'FundDeficit' }
  | { tag: 'ThawPrivate'; value: { index: number; maybeProportion?: Perquintill | undefined } }
  | { tag: 'ThawCommunal'; value: { index: number } }
  | { tag: 'Communify'; value: { index: number } }
  | { tag: 'Privatize'; value: { index: number } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletUniquesCall =
  | { tag: 'Create'; value: { collection: number; admin: MultiAddress } }
  | { tag: 'ForceCreate'; value: { collection: number; owner: MultiAddress; freeHolding: boolean } }
  | { tag: 'Destroy'; value: { collection: number; witness: PalletUniquesDestroyWitness } }
  | { tag: 'Mint'; value: { collection: number; item: number; owner: MultiAddress } }
  | { tag: 'Burn'; value: { collection: number; item: number; checkOwner?: MultiAddress | undefined } }
  | { tag: 'Transfer'; value: { collection: number; item: number; dest: MultiAddress } }
  | { tag: 'Redeposit'; value: { collection: number; items: Array<number> } }
  | { tag: 'Freeze'; value: { collection: number; item: number } }
  | { tag: 'Thaw'; value: { collection: number; item: number } }
  | { tag: 'FreezeCollection'; value: { collection: number } }
  | { tag: 'ThawCollection'; value: { collection: number } }
  | { tag: 'TransferOwnership'; value: { collection: number; owner: MultiAddress } }
  | { tag: 'SetTeam'; value: { collection: number; issuer: MultiAddress; admin: MultiAddress; freezer: MultiAddress } }
  | { tag: 'ApproveTransfer'; value: { collection: number; item: number; delegate: MultiAddress } }
  | {
      tag: 'CancelApproval';
      value: { collection: number; item: number; maybeCheckDelegate?: MultiAddress | undefined };
    }
  | {
      tag: 'ForceItemStatus';
      value: {
        collection: number;
        owner: MultiAddress;
        issuer: MultiAddress;
        admin: MultiAddress;
        freezer: MultiAddress;
        freeHolding: boolean;
        isFrozen: boolean;
      };
    }
  | { tag: 'SetAttribute'; value: { collection: number; maybeItem?: number | undefined; key: Bytes; value: Bytes } }
  | { tag: 'ClearAttribute'; value: { collection: number; maybeItem?: number | undefined; key: Bytes } }
  | { tag: 'SetMetadata'; value: { collection: number; item: number; data: Bytes; isFrozen: boolean } }
  | { tag: 'ClearMetadata'; value: { collection: number; item: number } }
  | { tag: 'SetCollectionMetadata'; value: { collection: number; data: Bytes; isFrozen: boolean } }
  | { tag: 'ClearCollectionMetadata'; value: { collection: number } }
  | { tag: 'SetAcceptOwnership'; value: { maybeCollection?: number | undefined } }
  | { tag: 'SetCollectionMaxSupply'; value: { collection: number; maxSupply: number } }
  | {
      tag: 'SetPrice';
      value: {
        collection: number;
        item: number;
        price?: bigint | undefined;
        whitelistedBuyer?: MultiAddress | undefined;
      };
    }
  | { tag: 'BuyItem'; value: { collection: number; item: number; bidPrice: bigint } };

export type PalletUniquesDestroyWitness = { items: number; itemMetadatas: number; attributes: number };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletNftsCall =
  | { tag: 'Create'; value: { admin: MultiAddress; config: PalletNftsCollectionConfig } }
  | { tag: 'ForceCreate'; value: { owner: MultiAddress; config: PalletNftsCollectionConfig } }
  | { tag: 'Destroy'; value: { collection: number; witness: PalletNftsDestroyWitness } }
  | {
      tag: 'Mint';
      value: {
        collection: number;
        item: number;
        mintTo: MultiAddress;
        witnessData?: PalletNftsMintWitness | undefined;
      };
    }
  | {
      tag: 'ForceMint';
      value: { collection: number; item: number; mintTo: MultiAddress; itemConfig: PalletNftsItemConfig };
    }
  | { tag: 'Burn'; value: { collection: number; item: number } }
  | { tag: 'Transfer'; value: { collection: number; item: number; dest: MultiAddress } }
  | { tag: 'Redeposit'; value: { collection: number; items: Array<number> } }
  | { tag: 'LockItemTransfer'; value: { collection: number; item: number } }
  | { tag: 'UnlockItemTransfer'; value: { collection: number; item: number } }
  | { tag: 'LockCollection'; value: { collection: number; lockSettings: PalletNftsBitFlags } }
  | { tag: 'TransferOwnership'; value: { collection: number; owner: MultiAddress } }
  | {
      tag: 'SetTeam';
      value: {
        collection: number;
        issuer?: MultiAddress | undefined;
        admin?: MultiAddress | undefined;
        freezer?: MultiAddress | undefined;
      };
    }
  | { tag: 'ForceCollectionOwner'; value: { collection: number; owner: MultiAddress } }
  | { tag: 'ForceCollectionConfig'; value: { collection: number; config: PalletNftsCollectionConfig } }
  | {
      tag: 'ApproveTransfer';
      value: { collection: number; item: number; delegate: MultiAddress; maybeDeadline?: number | undefined };
    }
  | { tag: 'CancelApproval'; value: { collection: number; item: number; delegate: MultiAddress } }
  | { tag: 'ClearAllTransferApprovals'; value: { collection: number; item: number } }
  | {
      tag: 'LockItemProperties';
      value: { collection: number; item: number; lockMetadata: boolean; lockAttributes: boolean };
    }
  | {
      tag: 'SetAttribute';
      value: {
        collection: number;
        maybeItem?: number | undefined;
        namespace: PalletNftsAttributeNamespace;
        key: Bytes;
        value: Bytes;
      };
    }
  | {
      tag: 'ForceSetAttribute';
      value: {
        setAs?: AccountId32Like | undefined;
        collection: number;
        maybeItem?: number | undefined;
        namespace: PalletNftsAttributeNamespace;
        key: Bytes;
        value: Bytes;
      };
    }
  | {
      tag: 'ClearAttribute';
      value: {
        collection: number;
        maybeItem?: number | undefined;
        namespace: PalletNftsAttributeNamespace;
        key: Bytes;
      };
    }
  | { tag: 'ApproveItemAttributes'; value: { collection: number; item: number; delegate: MultiAddress } }
  | {
      tag: 'CancelItemAttributesApproval';
      value: {
        collection: number;
        item: number;
        delegate: MultiAddress;
        witness: PalletNftsCancelAttributesApprovalWitness;
      };
    }
  | { tag: 'SetMetadata'; value: { collection: number; item: number; data: Bytes } }
  | { tag: 'ClearMetadata'; value: { collection: number; item: number } }
  | { tag: 'SetCollectionMetadata'; value: { collection: number; data: Bytes } }
  | { tag: 'ClearCollectionMetadata'; value: { collection: number } }
  | { tag: 'SetAcceptOwnership'; value: { maybeCollection?: number | undefined } }
  | { tag: 'SetCollectionMaxSupply'; value: { collection: number; maxSupply: number } }
  | { tag: 'UpdateMintSettings'; value: { collection: number; mintSettings: PalletNftsMintSettings } }
  | {
      tag: 'SetPrice';
      value: {
        collection: number;
        item: number;
        price?: bigint | undefined;
        whitelistedBuyer?: MultiAddress | undefined;
      };
    }
  | { tag: 'BuyItem'; value: { collection: number; item: number; bidPrice: bigint } }
  | { tag: 'PayTips'; value: { tips: Array<PalletNftsItemTip> } }
  | {
      tag: 'CreateSwap';
      value: {
        offeredCollection: number;
        offeredItem: number;
        desiredCollection: number;
        maybeDesiredItem?: number | undefined;
        maybePrice?: PalletNftsPriceWithDirection | undefined;
        duration: number;
      };
    }
  | { tag: 'CancelSwap'; value: { offeredCollection: number; offeredItem: number } }
  | {
      tag: 'ClaimSwap';
      value: {
        sendCollection: number;
        sendItem: number;
        receiveCollection: number;
        receiveItem: number;
        witnessPrice?: PalletNftsPriceWithDirection | undefined;
      };
    }
  | {
      tag: 'MintPreSigned';
      value: { mintData: PalletNftsPreSignedMint; signature: SpRuntimeMultiSignature; signer: AccountId32Like };
    }
  | {
      tag: 'SetAttributesPreSigned';
      value: { data: PalletNftsPreSignedAttributes; signature: SpRuntimeMultiSignature; signer: AccountId32Like };
    };

export type PalletNftsCollectionConfig = {
  settings: PalletNftsBitFlags;
  maxSupply?: number | undefined;
  mintSettings: PalletNftsMintSettings;
};

export type PalletNftsBitFlags = bigint;

export type PalletNftsCollectionSetting =
  | 'TransferableItems'
  | 'UnlockedMetadata'
  | 'UnlockedAttributes'
  | 'UnlockedMaxSupply'
  | 'DepositRequired';

export type PalletNftsMintSettings = {
  mintType: PalletNftsMintType;
  price?: bigint | undefined;
  startBlock?: number | undefined;
  endBlock?: number | undefined;
  defaultItemSettings: PalletNftsBitFlagsItemSetting;
};

export type PalletNftsMintType = { tag: 'Issuer' } | { tag: 'Public' } | { tag: 'HolderOf'; value: number };

export type PalletNftsBitFlagsItemSetting = bigint;

export type PalletNftsItemSetting = 'Transferable' | 'UnlockedMetadata' | 'UnlockedAttributes';

export type PalletNftsDestroyWitness = { itemMetadatas: number; itemConfigs: number; attributes: number };

export type PalletNftsMintWitness = { ownedItem?: number | undefined; mintPrice?: bigint | undefined };

export type PalletNftsItemConfig = { settings: PalletNftsBitFlagsItemSetting };

export type PalletNftsCancelAttributesApprovalWitness = { accountAttributes: number };

export type PalletNftsItemTip = { collection: number; item: number; receiver: AccountId32Like; amount: bigint };

export type PalletNftsPreSignedMint = {
  collection: number;
  item: number;
  attributes: Array<[Bytes, Bytes]>;
  metadata: Bytes;
  onlyAccount?: AccountId32Like | undefined;
  deadline: number;
  mintPrice?: bigint | undefined;
};

export type SpRuntimeMultiSignature =
  | { tag: 'Ed25519'; value: SpCoreEd25519Signature }
  | { tag: 'Sr25519'; value: SpCoreSr25519Signature }
  | { tag: 'Ecdsa'; value: SpCoreEcdsaSignature };

export type SpCoreEcdsaSignature = FixedBytes<65>;

export type PalletNftsPreSignedAttributes = {
  collection: number;
  item: number;
  attributes: Array<[Bytes, Bytes]>;
  namespace: PalletNftsAttributeNamespace;
  deadline: number;
};

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletNftFractionalizationCall =
  | {
      tag: 'Fractionalize';
      value: { nftCollectionId: number; nftId: number; assetId: number; beneficiary: MultiAddress; fractions: bigint };
    }
  | { tag: 'Unify'; value: { nftCollectionId: number; nftId: number; assetId: number; beneficiary: MultiAddress } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletSalaryCall =
  | { tag: 'Init' }
  | { tag: 'Bump' }
  | { tag: 'Induct' }
  | { tag: 'Register' }
  | { tag: 'Payout' }
  | { tag: 'PayoutOther'; value: { beneficiary: AccountId32Like } }
  | { tag: 'CheckPayment' };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletCoreFellowshipCall =
  | { tag: 'Bump'; value: { who: AccountId32Like } }
  | { tag: 'SetParams'; value: { params: PalletCoreFellowshipParamsType } }
  | { tag: 'SetActive'; value: { isActive: boolean } }
  | { tag: 'Approve'; value: { who: AccountId32Like; atRank: number } }
  | { tag: 'Induct'; value: { who: AccountId32Like } }
  | { tag: 'Promote'; value: { who: AccountId32Like; toRank: number } }
  | { tag: 'Offboard'; value: { who: AccountId32Like } }
  | { tag: 'SubmitEvidence'; value: { wish: PalletCoreFellowshipWish; evidence: Bytes } }
  | { tag: 'Import' };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletTransactionStorageCall =
  | { tag: 'Store'; value: { data: Bytes } }
  | { tag: 'Renew'; value: { block: number; index: number } }
  | { tag: 'CheckProof'; value: { proof: SpTransactionStorageProofTransactionStorageProof } };

export type SpTransactionStorageProofTransactionStorageProof = { chunk: Bytes; proof: Array<Bytes> };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletBagsListCall =
  | { tag: 'Rebag'; value: { dislocated: MultiAddress } }
  | { tag: 'PutInFrontOf'; value: { lighter: MultiAddress } }
  | { tag: 'PutInFrontOfOther'; value: { heavier: MultiAddress; lighter: MultiAddress } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletStateTrieMigrationCall =
  | { tag: 'ControlAutoMigration'; value: { maybeConfig?: PalletStateTrieMigrationMigrationLimits | undefined } }
  | {
      tag: 'ContinueMigrate';
      value: {
        limits: PalletStateTrieMigrationMigrationLimits;
        realSizeUpper: number;
        witnessTask: PalletStateTrieMigrationMigrationTask;
      };
    }
  | { tag: 'MigrateCustomTop'; value: { keys: Array<Bytes>; witnessSize: number } }
  | { tag: 'MigrateCustomChild'; value: { root: Bytes; childKeys: Array<Bytes>; totalSize: number } }
  | { tag: 'SetSignedMaxLimits'; value: { limits: PalletStateTrieMigrationMigrationLimits } }
  | {
      tag: 'ForceSetProgress';
      value: { progressTop: PalletStateTrieMigrationProgress; progressChild: PalletStateTrieMigrationProgress };
    };

export type PalletStateTrieMigrationMigrationLimits = { size: number; item: number };

export type PalletStateTrieMigrationMigrationTask = {
  progressTop: PalletStateTrieMigrationProgress;
  progressChild: PalletStateTrieMigrationProgress;
  size: number;
  topItems: number;
  childItems: number;
};

export type PalletStateTrieMigrationProgress =
  | { tag: 'ToStart' }
  | { tag: 'LastKey'; value: Bytes }
  | { tag: 'Complete' };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletChildBountiesCall =
  | { tag: 'AddChildBounty'; value: { parentBountyId: number; value: bigint; description: Bytes } }
  | {
      tag: 'ProposeCurator';
      value: { parentBountyId: number; childBountyId: number; curator: MultiAddress; fee: bigint };
    }
  | { tag: 'AcceptCurator'; value: { parentBountyId: number; childBountyId: number } }
  | { tag: 'UnassignCurator'; value: { parentBountyId: number; childBountyId: number } }
  | { tag: 'AwardChildBounty'; value: { parentBountyId: number; childBountyId: number; beneficiary: MultiAddress } }
  | { tag: 'ClaimChildBounty'; value: { parentBountyId: number; childBountyId: number } }
  | { tag: 'CloseChildBounty'; value: { parentBountyId: number; childBountyId: number } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletReferendaCall =
  | {
      tag: 'Submit';
      value: {
        proposalOrigin: KitchensinkRuntimeOriginCaller;
        proposal: FrameSupportPreimagesBounded;
        enactmentMoment: FrameSupportScheduleDispatchTime;
      };
    }
  | { tag: 'PlaceDecisionDeposit'; value: { index: number } }
  | { tag: 'RefundDecisionDeposit'; value: { index: number } }
  | { tag: 'Cancel'; value: { index: number } }
  | { tag: 'Kill'; value: { index: number } }
  | { tag: 'NudgeReferendum'; value: { index: number } }
  | { tag: 'OneFewerDeciding'; value: { track: number } }
  | { tag: 'RefundSubmissionDeposit'; value: { index: number } }
  | { tag: 'SetMetadata'; value: { index: number; maybeHash?: H256 | undefined } };

export type FrameSupportScheduleDispatchTime = { tag: 'At'; value: number } | { tag: 'After'; value: number };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletRemarkCall = { tag: 'Store'; value: { remark: Bytes } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletRootTestingCall = { tag: 'FillBlock'; value: { ratio: Perbill } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletConvictionVotingCall =
  | { tag: 'Vote'; value: { pollIndex: number; vote: PalletConvictionVotingVoteAccountVote } }
  | {
      tag: 'Delegate';
      value: { class: number; to: MultiAddress; conviction: PalletConvictionVotingConviction; balance: bigint };
    }
  | { tag: 'Undelegate'; value: { class: number } }
  | { tag: 'Unlock'; value: { class: number; target: MultiAddress } }
  | { tag: 'RemoveVote'; value: { class?: number | undefined; index: number } }
  | { tag: 'RemoveOtherVote'; value: { target: MultiAddress; class: number; index: number } };

export type PalletConvictionVotingVoteAccountVote =
  | { tag: 'Standard'; value: { vote: PalletConvictionVotingVote; balance: bigint } }
  | { tag: 'Split'; value: { aye: bigint; nay: bigint } }
  | { tag: 'SplitAbstain'; value: { aye: bigint; nay: bigint; abstain: bigint } };

export type PalletConvictionVotingVote = number;

export type PalletConvictionVotingConviction =
  | 'None'
  | 'Locked1x'
  | 'Locked2x'
  | 'Locked3x'
  | 'Locked4x'
  | 'Locked5x'
  | 'Locked6x';

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletWhitelistCall =
  | { tag: 'WhitelistCall'; value: { callHash: H256 } }
  | { tag: 'RemoveWhitelistedCall'; value: { callHash: H256 } }
  | {
      tag: 'DispatchWhitelistedCall';
      value: { callHash: H256; callEncodedLen: number; callWeightWitness: SpWeightsWeightV2Weight };
    }
  | { tag: 'DispatchWhitelistedCallWithPreimage'; value: { call: KitchensinkRuntimeRuntimeCall } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletAllianceCall =
  | { tag: 'Propose'; value: { threshold: number; proposal: KitchensinkRuntimeRuntimeCall; lengthBound: number } }
  | { tag: 'Vote'; value: { proposal: H256; index: number; approve: boolean } }
  | { tag: 'InitMembers'; value: { fellows: Array<AccountId32Like>; allies: Array<AccountId32Like> } }
  | { tag: 'Disband'; value: { witness: PalletAllianceDisbandWitness } }
  | { tag: 'SetRule'; value: { rule: PalletAllianceCid } }
  | { tag: 'Announce'; value: { announcement: PalletAllianceCid } }
  | { tag: 'RemoveAnnouncement'; value: { announcement: PalletAllianceCid } }
  | { tag: 'JoinAlliance' }
  | { tag: 'NominateAlly'; value: { who: MultiAddress } }
  | { tag: 'ElevateAlly'; value: { ally: MultiAddress } }
  | { tag: 'GiveRetirementNotice' }
  | { tag: 'Retire' }
  | { tag: 'KickMember'; value: { who: MultiAddress } }
  | { tag: 'AddUnscrupulousItems'; value: { items: Array<PalletAllianceUnscrupulousItem> } }
  | { tag: 'RemoveUnscrupulousItems'; value: { items: Array<PalletAllianceUnscrupulousItem> } }
  | {
      tag: 'Close';
      value: { proposalHash: H256; index: number; proposalWeightBound: SpWeightsWeightV2Weight; lengthBound: number };
    }
  | { tag: 'AbdicateFellowStatus' };

export type PalletAllianceDisbandWitness = { fellowMembers: number; allyMembers: number };

export type PalletAllianceCid = { version: PalletAllianceVersion; codec: bigint; hash: PalletAllianceMultihash };

export type PalletAllianceVersion = 'V0' | 'V1';

export type PalletAllianceMultihash = { code: bigint; digest: Bytes };

export type PalletAllianceUnscrupulousItem =
  | { tag: 'AccountId'; value: AccountId32Like }
  | { tag: 'Website'; value: Bytes };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletNominationPoolsCall =
  | { tag: 'Join'; value: { amount: bigint; poolId: number } }
  | { tag: 'BondExtra'; value: { extra: PalletNominationPoolsBondExtra } }
  | { tag: 'ClaimPayout' }
  | { tag: 'Unbond'; value: { memberAccount: MultiAddress; unbondingPoints: bigint } }
  | { tag: 'PoolWithdrawUnbonded'; value: { poolId: number; numSlashingSpans: number } }
  | { tag: 'WithdrawUnbonded'; value: { memberAccount: MultiAddress; numSlashingSpans: number } }
  | { tag: 'Create'; value: { amount: bigint; root: MultiAddress; nominator: MultiAddress; bouncer: MultiAddress } }
  | {
      tag: 'CreateWithPoolId';
      value: { amount: bigint; root: MultiAddress; nominator: MultiAddress; bouncer: MultiAddress; poolId: number };
    }
  | { tag: 'Nominate'; value: { poolId: number; validators: Array<AccountId32Like> } }
  | { tag: 'SetState'; value: { poolId: number; state: PalletNominationPoolsPoolState } }
  | { tag: 'SetMetadata'; value: { poolId: number; metadata: Bytes } }
  | {
      tag: 'SetConfigs';
      value: {
        minJoinBond: PalletNominationPoolsConfigOp;
        minCreateBond: PalletNominationPoolsConfigOp;
        maxPools: PalletNominationPoolsConfigOpU32;
        maxMembers: PalletNominationPoolsConfigOpU32;
        maxMembersPerPool: PalletNominationPoolsConfigOpU32;
        globalMaxCommission: PalletNominationPoolsConfigOpPerbill;
      };
    }
  | {
      tag: 'UpdateRoles';
      value: {
        poolId: number;
        newRoot: PalletNominationPoolsConfigOp004;
        newNominator: PalletNominationPoolsConfigOp004;
        newBouncer: PalletNominationPoolsConfigOp004;
      };
    }
  | { tag: 'Chill'; value: { poolId: number } }
  | { tag: 'BondExtraOther'; value: { member: MultiAddress; extra: PalletNominationPoolsBondExtra } }
  | { tag: 'SetClaimPermission'; value: { permission: PalletNominationPoolsClaimPermission } }
  | { tag: 'ClaimPayoutOther'; value: { other: AccountId32Like } }
  | { tag: 'SetCommission'; value: { poolId: number; newCommission?: [Perbill, AccountId32Like] | undefined } }
  | { tag: 'SetCommissionMax'; value: { poolId: number; maxCommission: Perbill } }
  | { tag: 'SetCommissionChangeRate'; value: { poolId: number; changeRate: PalletNominationPoolsCommissionChangeRate } }
  | { tag: 'ClaimCommission'; value: { poolId: number } };

export type PalletNominationPoolsBondExtra = { tag: 'FreeBalance'; value: bigint } | { tag: 'Rewards' };

export type PalletNominationPoolsPoolState = 'Open' | 'Blocked' | 'Destroying';

export type PalletNominationPoolsConfigOp = { tag: 'Noop' } | { tag: 'Set'; value: bigint } | { tag: 'Remove' };

export type PalletNominationPoolsConfigOpU32 = { tag: 'Noop' } | { tag: 'Set'; value: number } | { tag: 'Remove' };

export type PalletNominationPoolsConfigOpPerbill = { tag: 'Noop' } | { tag: 'Set'; value: Perbill } | { tag: 'Remove' };

export type PalletNominationPoolsConfigOp004 =
  | { tag: 'Noop' }
  | { tag: 'Set'; value: AccountId32Like }
  | { tag: 'Remove' };

export type PalletNominationPoolsClaimPermission =
  | 'Permissioned'
  | 'PermissionlessCompound'
  | 'PermissionlessWithdraw'
  | 'PermissionlessAll';

export type PalletNominationPoolsCommissionChangeRate = { maxIncrease: Perbill; minDelay: number };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletRankedCollectiveCall =
  | { tag: 'AddMember'; value: { who: MultiAddress } }
  | { tag: 'PromoteMember'; value: { who: MultiAddress } }
  | { tag: 'DemoteMember'; value: { who: MultiAddress } }
  | { tag: 'RemoveMember'; value: { who: MultiAddress; minRank: number } }
  | { tag: 'Vote'; value: { poll: number; aye: boolean } }
  | { tag: 'CleanupPoll'; value: { pollIndex: number; max: number } };

/**
 * Pallet's callable functions.
 **/
export type PalletAssetConversionCall =
  | {
      tag: 'CreatePool';
      value: { asset1: PalletAssetConversionNativeOrAssetId; asset2: PalletAssetConversionNativeOrAssetId };
    }
  | {
      tag: 'AddLiquidity';
      value: {
        asset1: PalletAssetConversionNativeOrAssetId;
        asset2: PalletAssetConversionNativeOrAssetId;
        amount1Desired: bigint;
        amount2Desired: bigint;
        amount1Min: bigint;
        amount2Min: bigint;
        mintTo: AccountId32Like;
      };
    }
  | {
      tag: 'RemoveLiquidity';
      value: {
        asset1: PalletAssetConversionNativeOrAssetId;
        asset2: PalletAssetConversionNativeOrAssetId;
        lpTokenBurn: bigint;
        amount1MinReceive: bigint;
        amount2MinReceive: bigint;
        withdrawTo: AccountId32Like;
      };
    }
  | {
      tag: 'SwapExactTokensForTokens';
      value: {
        path: Array<PalletAssetConversionNativeOrAssetId>;
        amountIn: bigint;
        amountOutMin: bigint;
        sendTo: AccountId32Like;
        keepAlive: boolean;
      };
    }
  | {
      tag: 'SwapTokensForExactTokens';
      value: {
        path: Array<PalletAssetConversionNativeOrAssetId>;
        amountOut: bigint;
        amountInMax: bigint;
        sendTo: AccountId32Like;
        keepAlive: boolean;
      };
    };

export type PalletAssetConversionNativeOrAssetId = { tag: 'Native' } | { tag: 'Asset'; value: number };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletFastUnstakeCall =
  | { tag: 'RegisterFastUnstake' }
  | { tag: 'Deregister' }
  | { tag: 'Control'; value: { erasToCheck: number } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletMessageQueueCall =
  | { tag: 'ReapPage'; value: { messageOrigin: number; pageIndex: number } }
  | {
      tag: 'ExecuteOverweight';
      value: { messageOrigin: number; page: number; index: number; weightLimit: SpWeightsWeightV2Weight };
    };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type FrameBenchmarkingPalletPovCall =
  /**
   * See [`Pallet::emit_event`].
   **/
  | 'emit_event'
  /**
   * See [`Pallet::noop`].
   **/
  | 'noop';

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletTxPauseCall =
  | { tag: 'Pause'; value: { fullName: [Bytes, Bytes] } }
  | { tag: 'Unpause'; value: { ident: [Bytes, Bytes] } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletSafeModeCall =
  | { tag: 'Enter' }
  | { tag: 'ForceEnter' }
  | { tag: 'Extend' }
  | { tag: 'ForceExtend' }
  | { tag: 'ForceExit' }
  | { tag: 'ForceSlashDeposit'; value: { account: AccountId32Like; block: number } }
  | { tag: 'ReleaseDeposit'; value: { account: AccountId32Like; block: number } }
  | { tag: 'ForceReleaseDeposit'; value: { account: AccountId32Like; block: number } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletBrokerCall =
  | { tag: 'Configure'; value: { config: PalletBrokerConfigRecord } }
  | { tag: 'Reserve'; value: { workload: Array<PalletBrokerScheduleItem> } }
  | { tag: 'Unreserve'; value: { itemIndex: number } }
  | { tag: 'SetLease'; value: { task: number; until: number } }
  | { tag: 'StartSales'; value: { initialPrice: bigint; coreCount: number } }
  | { tag: 'Purchase'; value: { priceLimit: bigint } }
  | { tag: 'Renew'; value: { core: number } }
  | { tag: 'Transfer'; value: { regionId: PalletBrokerRegionId; newOwner: AccountId32Like } }
  | { tag: 'Partition'; value: { regionId: PalletBrokerRegionId; pivot: number } }
  | { tag: 'Interlace'; value: { regionId: PalletBrokerRegionId; pivot: PalletBrokerCoreMask } }
  | { tag: 'Assign'; value: { regionId: PalletBrokerRegionId; task: number; finality: PalletBrokerFinality } }
  | { tag: 'Pool'; value: { regionId: PalletBrokerRegionId; payee: AccountId32Like; finality: PalletBrokerFinality } }
  | { tag: 'ClaimRevenue'; value: { regionId: PalletBrokerRegionId; maxTimeslices: number } }
  | { tag: 'PurchaseCredit'; value: { amount: bigint; beneficiary: AccountId32Like } }
  | { tag: 'DropRegion'; value: { regionId: PalletBrokerRegionId } }
  | { tag: 'DropContribution'; value: { regionId: PalletBrokerRegionId } }
  | { tag: 'DropHistory'; value: { when: number } }
  | { tag: 'DropRenewal'; value: { core: number; when: number } }
  | { tag: 'RequestCoreCount'; value: { coreCount: number } };

export type PalletBrokerConfigRecord = {
  advanceNotice: number;
  interludeLength: number;
  leadinLength: number;
  regionLength: number;
  idealBulkProportion: Perbill;
  limitCoresOffered?: number | undefined;
  renewalBump: Perbill;
  contributionTimeout: number;
};

export type PalletBrokerScheduleItem = {
  mask: PalletBrokerCoreMask;
  assignment: PalletBrokerCoretimeInterfaceCoreAssignment;
};

export type PalletBrokerCoreMask = FixedBytes<10>;

export type PalletBrokerCoretimeInterfaceCoreAssignment =
  | { tag: 'Idle' }
  | { tag: 'Pool' }
  | { tag: 'Task'; value: number };

export type PalletBrokerRegionId = { begin: number; core: number; mask: PalletBrokerCoreMask };

export type PalletBrokerFinality = 'Provisional' | 'Final';

export type PalletConvictionVotingTally = { ayes: bigint; nays: bigint; support: bigint };

/**
 * The `Event` enum of this pallet
 **/
export type PalletRemarkEvent = { tag: 'Stored'; value: { sender: AccountId32Like; contentHash: H256 } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletConvictionVotingEvent =
  | { tag: 'Delegated'; value: [AccountId32Like, AccountId32Like] }
  | { tag: 'Undelegated'; value: AccountId32Like };

/**
 * The `Event` enum of this pallet
 **/
export type PalletWhitelistEvent =
  | { tag: 'CallWhitelisted'; value: { callHash: H256 } }
  | { tag: 'WhitelistedCallRemoved'; value: { callHash: H256 } }
  | {
      tag: 'WhitelistedCallDispatched';
      value: { callHash: H256; result: FrameSupportDispatchPostDispatchInfo | SpRuntimeDispatchErrorWithPostInfo };
    };

export type FrameSupportDispatchPostDispatchInfo = {
  actualWeight?: SpWeightsWeightV2Weight | undefined;
  paysFee: FrameSupportDispatchPays;
};

export type SpRuntimeDispatchErrorWithPostInfo = {
  postInfo: FrameSupportDispatchPostDispatchInfo;
  error: SpRuntimeDispatchError;
};

/**
 * The `Event` enum of this pallet
 **/
export type PalletAllianceEvent =
  | { tag: 'NewRuleSet'; value: { rule: PalletAllianceCid } }
  | { tag: 'Announced'; value: { announcement: PalletAllianceCid } }
  | { tag: 'AnnouncementRemoved'; value: { announcement: PalletAllianceCid } }
  | { tag: 'MembersInitialized'; value: { fellows: Array<AccountId32Like>; allies: Array<AccountId32Like> } }
  | {
      tag: 'NewAllyJoined';
      value: { ally: AccountId32Like; nominator?: AccountId32Like | undefined; reserved?: bigint | undefined };
    }
  | { tag: 'AllyElevated'; value: { ally: AccountId32Like } }
  | { tag: 'MemberRetirementPeriodStarted'; value: { member: AccountId32Like } }
  | { tag: 'MemberRetired'; value: { member: AccountId32Like; unreserved?: bigint | undefined } }
  | { tag: 'MemberKicked'; value: { member: AccountId32Like; slashed?: bigint | undefined } }
  | { tag: 'UnscrupulousItemAdded'; value: { items: Array<PalletAllianceUnscrupulousItem> } }
  | { tag: 'UnscrupulousItemRemoved'; value: { items: Array<PalletAllianceUnscrupulousItem> } }
  | { tag: 'AllianceDisbanded'; value: { fellowMembers: number; allyMembers: number; unreserved: number } }
  | { tag: 'FellowAbdicated'; value: { fellow: AccountId32Like } };

/**
 * Events of this pallet.
 **/
export type PalletNominationPoolsEvent =
  | { tag: 'Created'; value: { depositor: AccountId32Like; poolId: number } }
  | { tag: 'Bonded'; value: { member: AccountId32Like; poolId: number; bonded: bigint; joined: boolean } }
  | { tag: 'PaidOut'; value: { member: AccountId32Like; poolId: number; payout: bigint } }
  | {
      tag: 'Unbonded';
      value: { member: AccountId32Like; poolId: number; balance: bigint; points: bigint; era: number };
    }
  | { tag: 'Withdrawn'; value: { member: AccountId32Like; poolId: number; balance: bigint; points: bigint } }
  | { tag: 'Destroyed'; value: { poolId: number } }
  | { tag: 'StateChanged'; value: { poolId: number; newState: PalletNominationPoolsPoolState } }
  | { tag: 'MemberRemoved'; value: { poolId: number; member: AccountId32Like } }
  | {
      tag: 'RolesUpdated';
      value: {
        root?: AccountId32Like | undefined;
        bouncer?: AccountId32Like | undefined;
        nominator?: AccountId32Like | undefined;
      };
    }
  | { tag: 'PoolSlashed'; value: { poolId: number; balance: bigint } }
  | { tag: 'UnbondingPoolSlashed'; value: { poolId: number; era: number; balance: bigint } }
  | { tag: 'PoolCommissionUpdated'; value: { poolId: number; current?: [Perbill, AccountId32Like] | undefined } }
  | { tag: 'PoolMaxCommissionUpdated'; value: { poolId: number; maxCommission: Perbill } }
  | {
      tag: 'PoolCommissionChangeRateUpdated';
      value: { poolId: number; changeRate: PalletNominationPoolsCommissionChangeRate };
    }
  | { tag: 'PoolCommissionClaimed'; value: { poolId: number; commission: bigint } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletReferendaEvent002 =
  | {
      tag: 'Submitted';
      value: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The track (and by extension proposal dispatch origin) of this referendum.
         **/
        track: number;

        /**
         * The proposal for the referendum.
         **/
        proposal: FrameSupportPreimagesBounded;
      };
    }
  | {
      tag: 'DecisionDepositPlaced';
      value: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The account who placed the deposit.
         **/
        who: AccountId32Like;

        /**
         * The amount placed by the account.
         **/
        amount: bigint;
      };
    }
  | {
      tag: 'DecisionDepositRefunded';
      value: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The account who placed the deposit.
         **/
        who: AccountId32Like;

        /**
         * The amount placed by the account.
         **/
        amount: bigint;
      };
    }
  | {
      tag: 'DepositSlashed';
      value: {
        /**
         * The account who placed the deposit.
         **/
        who: AccountId32Like;

        /**
         * The amount placed by the account.
         **/
        amount: bigint;
      };
    }
  | {
      tag: 'DecisionStarted';
      value: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The track (and by extension proposal dispatch origin) of this referendum.
         **/
        track: number;

        /**
         * The proposal for the referendum.
         **/
        proposal: FrameSupportPreimagesBounded;

        /**
         * The current tally of votes in this referendum.
         **/
        tally: PalletRankedCollectiveTally;
      };
    }
  | {
      tag: 'ConfirmStarted';
      value: {
        /**
         * Index of the referendum.
         **/
        index: number;
      };
    }
  | {
      tag: 'ConfirmAborted';
      value: {
        /**
         * Index of the referendum.
         **/
        index: number;
      };
    }
  | {
      tag: 'Confirmed';
      value: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The final tally of votes in this referendum.
         **/
        tally: PalletRankedCollectiveTally;
      };
    }
  | {
      tag: 'Approved';
      value: {
        /**
         * Index of the referendum.
         **/
        index: number;
      };
    }
  | {
      tag: 'Rejected';
      value: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The final tally of votes in this referendum.
         **/
        tally: PalletRankedCollectiveTally;
      };
    }
  | {
      tag: 'TimedOut';
      value: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The final tally of votes in this referendum.
         **/
        tally: PalletRankedCollectiveTally;
      };
    }
  | {
      tag: 'Cancelled';
      value: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The final tally of votes in this referendum.
         **/
        tally: PalletRankedCollectiveTally;
      };
    }
  | {
      tag: 'Killed';
      value: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The final tally of votes in this referendum.
         **/
        tally: PalletRankedCollectiveTally;
      };
    }
  | {
      tag: 'SubmissionDepositRefunded';
      value: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * The account who placed the deposit.
         **/
        who: AccountId32Like;

        /**
         * The amount placed by the account.
         **/
        amount: bigint;
      };
    }
  | {
      tag: 'MetadataSet';
      value: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * Preimage hash.
         **/
        hash: H256;
      };
    }
  | {
      tag: 'MetadataCleared';
      value: {
        /**
         * Index of the referendum.
         **/
        index: number;

        /**
         * Preimage hash.
         **/
        hash: H256;
      };
    };

export type PalletRankedCollectiveTally = { bareAyes: number; ayes: number; nays: number };

/**
 * The `Event` enum of this pallet
 **/
export type PalletRankedCollectiveEvent =
  | { tag: 'MemberAdded'; value: { who: AccountId32Like } }
  | { tag: 'RankChanged'; value: { who: AccountId32Like; rank: number } }
  | { tag: 'MemberRemoved'; value: { who: AccountId32Like; rank: number } }
  | {
      tag: 'Voted';
      value: {
        who: AccountId32Like;
        poll: number;
        vote: PalletRankedCollectiveVoteRecord;
        tally: PalletRankedCollectiveTally;
      };
    };

export type PalletRankedCollectiveVoteRecord = { tag: 'Aye'; value: number } | { tag: 'Nay'; value: number };

/**
 * The `Event` enum of this pallet
 **/
export type PalletAssetConversionEvent =
  | {
      tag: 'PoolCreated';
      value: {
        /**
         * The account that created the pool.
         **/
        creator: AccountId32Like;

        /**
         * The pool id associated with the pool. Note that the order of the assets may not be
         * the same as the order specified in the create pool extrinsic.
         **/
        poolId: [PalletAssetConversionNativeOrAssetId, PalletAssetConversionNativeOrAssetId];

        /**
         * The account ID of the pool.
         **/
        poolAccount: AccountId32Like;

        /**
         * The id of the liquidity tokens that will be minted when assets are added to this
         * pool.
         **/
        lpToken: number;
      };
    }
  | {
      tag: 'LiquidityAdded';
      value: {
        /**
         * The account that the liquidity was taken from.
         **/
        who: AccountId32Like;

        /**
         * The account that the liquidity tokens were minted to.
         **/
        mintTo: AccountId32Like;

        /**
         * The pool id of the pool that the liquidity was added to.
         **/
        poolId: [PalletAssetConversionNativeOrAssetId, PalletAssetConversionNativeOrAssetId];

        /**
         * The amount of the first asset that was added to the pool.
         **/
        amount1Provided: bigint;

        /**
         * The amount of the second asset that was added to the pool.
         **/
        amount2Provided: bigint;

        /**
         * The id of the lp token that was minted.
         **/
        lpToken: number;

        /**
         * The amount of lp tokens that were minted of that id.
         **/
        lpTokenMinted: bigint;
      };
    }
  | {
      tag: 'LiquidityRemoved';
      value: {
        /**
         * The account that the liquidity tokens were burned from.
         **/
        who: AccountId32Like;

        /**
         * The account that the assets were transferred to.
         **/
        withdrawTo: AccountId32Like;

        /**
         * The pool id that the liquidity was removed from.
         **/
        poolId: [PalletAssetConversionNativeOrAssetId, PalletAssetConversionNativeOrAssetId];

        /**
         * The amount of the first asset that was removed from the pool.
         **/
        amount1: bigint;

        /**
         * The amount of the second asset that was removed from the pool.
         **/
        amount2: bigint;

        /**
         * The id of the lp token that was burned.
         **/
        lpToken: number;

        /**
         * The amount of lp tokens that were burned of that id.
         **/
        lpTokenBurned: bigint;

        /**
         * Liquidity withdrawal fee (%).
         **/
        withdrawalFee: Permill;
      };
    }
  | {
      tag: 'SwapExecuted';
      value: {
        /**
         * Which account was the instigator of the swap.
         **/
        who: AccountId32Like;

        /**
         * The account that the assets were transferred to.
         **/
        sendTo: AccountId32Like;

        /**
         * The route of asset ids that the swap went through.
         * E.g. A -> Dot -> B
         **/
        path: Array<PalletAssetConversionNativeOrAssetId>;

        /**
         * The amount of the first asset that was swapped.
         **/
        amountIn: bigint;

        /**
         * The amount of the second asset that was received.
         **/
        amountOut: bigint;
      };
    }
  | {
      tag: 'Transfer';
      value: {
        /**
         * The account that the assets were transferred from.
         **/
        from: AccountId32Like;

        /**
         * The account that the assets were transferred to.
         **/
        to: AccountId32Like;

        /**
         * The asset that was transferred.
         **/
        asset: PalletAssetConversionNativeOrAssetId;

        /**
         * The amount of the asset that was transferred.
         **/
        amount: bigint;
      };
    };

/**
 * The `Event` enum of this pallet
 **/
export type PalletFastUnstakeEvent =
  | { tag: 'Unstaked'; value: { stash: AccountId32Like; result: [] | SpRuntimeDispatchError } }
  | { tag: 'Slashed'; value: { stash: AccountId32Like; amount: bigint } }
  | { tag: 'BatchChecked'; value: { eras: Array<number> } }
  | { tag: 'BatchFinished'; value: { size: number } }
  | { tag: 'InternalError' };

/**
 * The `Event` enum of this pallet
 **/
export type PalletMessageQueueEvent =
  | {
      tag: 'ProcessingFailed';
      value: { id: FixedBytes<32>; origin: number; error: FrameSupportMessagesProcessMessageError };
    }
  | {
      tag: 'Processed';
      value: { id: FixedBytes<32>; origin: number; weightUsed: SpWeightsWeightV2Weight; success: boolean };
    }
  | {
      tag: 'OverweightEnqueued';
      value: { id: FixedBytes<32>; origin: number; pageIndex: number; messageIndex: number };
    }
  | { tag: 'PageReaped'; value: { origin: number; index: number } };

export type FrameSupportMessagesProcessMessageError =
  | { tag: 'BadFormat' }
  | { tag: 'Corrupt' }
  | { tag: 'Unsupported' }
  | { tag: 'Overweight'; value: SpWeightsWeightV2Weight }
  | { tag: 'Yield' };

/**
 * The `Event` enum of this pallet
 **/
export type FrameBenchmarkingPalletPovEvent = 'TestEvent';

/**
 * The `Event` enum of this pallet
 **/
export type PalletTxPauseEvent =
  | { tag: 'CallPaused'; value: { fullName: [Bytes, Bytes] } }
  | { tag: 'CallUnpaused'; value: { fullName: [Bytes, Bytes] } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletSafeModeEvent =
  | { tag: 'Entered'; value: { until: number } }
  | { tag: 'Extended'; value: { until: number } }
  | { tag: 'Exited'; value: { reason: PalletSafeModeExitReason } }
  | { tag: 'DepositPlaced'; value: { account: AccountId32Like; amount: bigint } }
  | { tag: 'DepositReleased'; value: { account: AccountId32Like; amount: bigint } }
  | { tag: 'DepositSlashed'; value: { account: AccountId32Like; amount: bigint } }
  | { tag: 'CannotDeposit' }
  | { tag: 'CannotRelease' };

export type PalletSafeModeExitReason = 'Timeout' | 'Force';

/**
 * The `Event` enum of this pallet
 **/
export type PalletStatementEvent = {
  tag: 'NewStatement';
  value: { account: AccountId32Like; statement: SpStatementStoreStatement };
};

export type SpStatementStoreStatement = {
  proof?: SpStatementStoreProof | undefined;
  decryptionKey?: FixedBytes<32> | undefined;
  channel?: FixedBytes<32> | undefined;
  priority?: number | undefined;
  numTopics: number;
  topics: FixedArray<FixedBytes<32>, 4>;
  data?: Bytes | undefined;
};

export type SpStatementStoreProof =
  | { tag: 'Sr25519'; value: { signature: FixedBytes<64>; signer: FixedBytes<32> } }
  | { tag: 'Ed25519'; value: { signature: FixedBytes<64>; signer: FixedBytes<32> } }
  | { tag: 'Secp256k1Ecdsa'; value: { signature: FixedBytes<65>; signer: FixedBytes<33> } }
  | { tag: 'OnChain'; value: { who: FixedBytes<32>; blockHash: FixedBytes<32>; eventIndex: bigint } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletBrokerEvent =
  | {
      tag: 'Purchased';
      value: {
        /**
         * The identity of the purchaser.
         **/
        who: AccountId32Like;

        /**
         * The identity of the Region.
         **/
        regionId: PalletBrokerRegionId;

        /**
         * The price paid for this Region.
         **/
        price: bigint;

        /**
         * The duration of the Region.
         **/
        duration: number;
      };
    }
  | {
      tag: 'Renewable';
      value: {
        /**
         * The core whose workload can be renewed.
         **/
        core: number;

        /**
         * The price at which the workload can be renewed.
         **/
        price: bigint;

        /**
         * The time at which the workload would recommence of this renewal. The call to renew
         * cannot happen before the beginning of the interlude prior to the sale for regions
         * which begin at this time.
         **/
        begin: number;

        /**
         * The actual workload which can be renewed.
         **/
        workload: Array<PalletBrokerScheduleItem>;
      };
    }
  | {
      tag: 'Renewed';
      value: {
        /**
         * The identity of the renewer.
         **/
        who: AccountId32Like;

        /**
         * The price paid for this renewal.
         **/
        price: bigint;

        /**
         * The index of the core on which the `workload` was previously scheduled.
         **/
        oldCore: number;

        /**
         * The index of the core on which the renewed `workload` has been scheduled.
         **/
        core: number;

        /**
         * The time at which the `workload` will begin on the `core`.
         **/
        begin: number;

        /**
         * The number of timeslices for which this `workload` is newly scheduled.
         **/
        duration: number;

        /**
         * The workload which was renewed.
         **/
        workload: Array<PalletBrokerScheduleItem>;
      };
    }
  | {
      tag: 'Transferred';
      value: {
        /**
         * The Region which has been transferred.
         **/
        regionId: PalletBrokerRegionId;

        /**
         * The duration of the Region.
         **/
        duration: number;

        /**
         * The old owner of the Region.
         **/
        oldOwner: AccountId32Like;

        /**
         * The new owner of the Region.
         **/
        owner: AccountId32Like;
      };
    }
  | {
      tag: 'Partitioned';
      value: {
        /**
         * The Region which was split.
         **/
        oldRegionId: PalletBrokerRegionId;

        /**
         * The new Regions into which it became.
         **/
        newRegionIds: [PalletBrokerRegionId, PalletBrokerRegionId];
      };
    }
  | {
      tag: 'Interlaced';
      value: {
        /**
         * The Region which was interlaced.
         **/
        oldRegionId: PalletBrokerRegionId;

        /**
         * The new Regions into which it became.
         **/
        newRegionIds: [PalletBrokerRegionId, PalletBrokerRegionId];
      };
    }
  | {
      tag: 'Assigned';
      value: {
        /**
         * The Region which was assigned.
         **/
        regionId: PalletBrokerRegionId;

        /**
         * The duration of the assignment.
         **/
        duration: number;

        /**
         * The task to which the Region was assigned.
         **/
        task: number;
      };
    }
  | {
      tag: 'Pooled';
      value: {
        /**
         * The Region which was added to the Instantaneous Coretime Pool.
         **/
        regionId: PalletBrokerRegionId;

        /**
         * The duration of the Region.
         **/
        duration: number;
      };
    }
  | {
      tag: 'CoreCountRequested';
      value: {
        /**
         * The number of cores requested.
         **/
        coreCount: number;
      };
    }
  | {
      tag: 'CoreCountChanged';
      value: {
        /**
         * The new number of cores available for scheduling.
         **/
        coreCount: number;
      };
    }
  | {
      tag: 'ReservationMade';
      value: {
        /**
         * The index of the reservation.
         **/
        index: number;

        /**
         * The workload of the reservation.
         **/
        workload: Array<PalletBrokerScheduleItem>;
      };
    }
  | {
      tag: 'ReservationCancelled';
      value: {
        /**
         * The index of the reservation which was cancelled.
         **/
        index: number;

        /**
         * The workload of the now cancelled reservation.
         **/
        workload: Array<PalletBrokerScheduleItem>;
      };
    }
  | {
      tag: 'SaleInitialized';
      value: {
        /**
         * The local block number at which the sale will/did start.
         **/
        saleStart: number;

        /**
         * The length in blocks of the Leadin Period (where the price is decreasing).
         **/
        leadinLength: number;

        /**
         * The price of Bulk Coretime at the beginning of the Leadin Period.
         **/
        startPrice: bigint;

        /**
         * The price of Bulk Coretime after the Leadin Period.
         **/
        regularPrice: bigint;

        /**
         * The first timeslice of the Regions which are being sold in this sale.
         **/
        regionBegin: number;

        /**
         * The timeslice on which the Regions which are being sold in the sale terminate.
         * (i.e. One after the last timeslice which the Regions control.)
         **/
        regionEnd: number;

        /**
         * The number of cores we want to sell, ideally. Selling this amount would result in
         * no change to the price for the next sale.
         **/
        idealCoresSold: number;

        /**
         * Number of cores which are/have been offered for sale.
         **/
        coresOffered: number;
      };
    }
  | {
      tag: 'Leased';
      value: {
        /**
         * The task to which a core will be assigned.
         **/
        task: number;

        /**
         * The timeslice contained in the sale period after which this lease will
         * self-terminate (and therefore the earliest timeslice at which the lease may no
         * longer apply).
         **/
        until: number;
      };
    }
  | {
      tag: 'LeaseEnding';
      value: {
        /**
         * The task to which a core was assigned.
         **/
        task: number;

        /**
         * The timeslice at which the task will no longer be scheduled.
         **/
        when: number;
      };
    }
  | {
      tag: 'SalesStarted';
      value: {
        /**
         * The nominal price of an Region of Bulk Coretime.
         **/
        price: bigint;

        /**
         * The maximum number of cores which this pallet will attempt to assign.
         **/
        coreCount: number;
      };
    }
  | {
      tag: 'RevenueClaimBegun';
      value: {
        /**
         * The region to be claimed for.
         **/
        region: PalletBrokerRegionId;

        /**
         * The maximum number of timeslices which should be searched for claimed.
         **/
        maxTimeslices: number;
      };
    }
  | {
      tag: 'RevenueClaimItem';
      value: {
        /**
         * The timeslice whose claim is being processed.
         **/
        when: number;

        /**
         * The amount which was claimed at this timeslice.
         **/
        amount: bigint;
      };
    }
  | {
      tag: 'RevenueClaimPaid';
      value: {
        /**
         * The account to whom revenue has been paid.
         **/
        who: AccountId32Like;

        /**
         * The total amount of revenue claimed and paid.
         **/
        amount: bigint;

        /**
         * The next region which should be claimed for the continuation of this contribution.
         **/
        next?: PalletBrokerRegionId | undefined;
      };
    }
  | {
      tag: 'CreditPurchased';
      value: {
        /**
         * The account which purchased the credit.
         **/
        who: AccountId32Like;

        /**
         * The Relay-chain account to which the credit will be made.
         **/
        beneficiary: AccountId32Like;

        /**
         * The amount of credit purchased.
         **/
        amount: bigint;
      };
    }
  | {
      tag: 'RegionDropped';
      value: {
        /**
         * The Region which no longer exists.
         **/
        regionId: PalletBrokerRegionId;

        /**
         * The duration of the Region.
         **/
        duration: number;
      };
    }
  | {
      tag: 'ContributionDropped';
      value: {
        /**
         * The Region whose contribution is no longer exists.
         **/
        regionId: PalletBrokerRegionId;
      };
    }
  | {
      tag: 'HistoryInitialized';
      value: {
        /**
         * The timeslice whose history has been initialized.
         **/
        when: number;

        /**
         * The amount of privately contributed Coretime to the Instantaneous Coretime Pool.
         **/
        privatePoolSize: number;

        /**
         * The amount of Coretime contributed to the Instantaneous Coretime Pool by the
         * Polkadot System.
         **/
        systemPoolSize: number;
      };
    }
  | {
      tag: 'HistoryDropped';
      value: {
        /**
         * The timeslice whose history is no longer available.
         **/
        when: number;

        /**
         * The amount of revenue the system has taken.
         **/
        revenue: bigint;
      };
    }
  | {
      tag: 'HistoryIgnored';
      value: {
        /**
         * The timeslice whose history is was ignored.
         **/
        when: number;

        /**
         * The amount of revenue which was ignored.
         **/
        revenue: bigint;
      };
    }
  | {
      tag: 'ClaimsReady';
      value: {
        /**
         * The timeslice whose history is available.
         **/
        when: number;

        /**
         * The amount of revenue the Polkadot System has already taken.
         **/
        systemPayout: bigint;

        /**
         * The total amount of revenue remaining to be claimed.
         **/
        privatePayout: bigint;
      };
    }
  | {
      tag: 'CoreAssigned';
      value: {
        /**
         * The index of the Core which has been assigned.
         **/
        core: number;

        /**
         * The Relay-chain block at which this assignment should take effect.
         **/
        when: number;

        /**
         * The workload to be done on the Core.
         **/
        assignment: Array<[PalletBrokerCoretimeInterfaceCoreAssignment, number]>;
      };
    }
  | {
      tag: 'AllowedRenewalDropped';
      value: {
        /**
         * The timeslice whose renewal is no longer available.
         **/
        when: number;

        /**
         * The core whose workload is no longer available to be renewed for `when`.
         **/
        core: number;
      };
    };

export type FrameSystemPhase =
  | { tag: 'ApplyExtrinsic'; value: number }
  | { tag: 'Finalization' }
  | { tag: 'Initialization' };

export type FrameSystemLastRuntimeUpgradeInfo = { specVersion: number; specName: string };

export type FrameSystemLimitsBlockWeights = {
  baseBlock: SpWeightsWeightV2Weight;
  maxBlock: SpWeightsWeightV2Weight;
  perClass: FrameSupportDispatchPerDispatchClassWeightsPerClass;
};

export type FrameSupportDispatchPerDispatchClassWeightsPerClass = {
  normal: FrameSystemLimitsWeightsPerClass;
  operational: FrameSystemLimitsWeightsPerClass;
  mandatory: FrameSystemLimitsWeightsPerClass;
};

export type FrameSystemLimitsWeightsPerClass = {
  baseExtrinsic: SpWeightsWeightV2Weight;
  maxExtrinsic?: SpWeightsWeightV2Weight | undefined;
  maxTotal?: SpWeightsWeightV2Weight | undefined;
  reserved?: SpWeightsWeightV2Weight | undefined;
};

export type FrameSystemLimitsBlockLength = { max: FrameSupportDispatchPerDispatchClassU32 };

export type FrameSupportDispatchPerDispatchClassU32 = { normal: number; operational: number; mandatory: number };

export type SpWeightsRuntimeDbWeight = { read: bigint; write: bigint };

export type SpVersionRuntimeVersion = {
  specName: string;
  implName: string;
  authoringVersion: number;
  specVersion: number;
  implVersion: number;
  apis: Array<[FixedBytes<8>, number]>;
  transactionVersion: number;
  stateVersion: number;
};

/**
 * Error for the System pallet
 **/
export type FrameSystemError =
  /**
   * The name of specification does not match between the current runtime
   * and the new runtime.
   **/
  | 'InvalidSpecName'
  /**
   * The specification version is not allowed to decrease between the current runtime
   * and the new runtime.
   **/
  | 'SpecVersionNeedsToIncrease'
  /**
   * Failed to extract the runtime version from the new runtime.
   *
   * Either calling `Core_version` or decoding `RuntimeVersion` failed.
   **/
  | 'FailedToExtractRuntimeVersion'
  /**
   * Suicide called when the account has non-default composite data.
   **/
  | 'NonDefaultComposite'
  /**
   * There is a non-zero reference count preventing the account from being purged.
   **/
  | 'NonZeroRefCount'
  /**
   * The origin filter prevent the call to be dispatched.
   **/
  | 'CallFiltered';

/**
 * The `Error` enum of this pallet.
 **/
export type PalletUtilityError =
  /**
   * Too many calls batched.
   **/
  'TooManyCalls';

export type SpConsensusBabeDigestsPreDigest =
  | { tag: 'Primary'; value: SpConsensusBabeDigestsPrimaryPreDigest }
  | { tag: 'SecondaryPlain'; value: SpConsensusBabeDigestsSecondaryPlainPreDigest }
  | { tag: 'SecondaryVRF'; value: SpConsensusBabeDigestsSecondaryVRFPreDigest };

export type SpConsensusBabeDigestsPrimaryPreDigest = {
  authorityIndex: number;
  slot: SpConsensusSlotsSlot;
  vrfSignature: SpCoreSr25519VrfVrfSignature;
};

export type SpCoreSr25519VrfVrfSignature = { output: FixedBytes<32>; proof: FixedBytes<64> };

export type SpConsensusBabeDigestsSecondaryPlainPreDigest = { authorityIndex: number; slot: SpConsensusSlotsSlot };

export type SpConsensusBabeDigestsSecondaryVRFPreDigest = {
  authorityIndex: number;
  slot: SpConsensusSlotsSlot;
  vrfSignature: SpCoreSr25519VrfVrfSignature;
};

export type SpConsensusBabeBabeEpochConfiguration = { c: [bigint, bigint]; allowedSlots: SpConsensusBabeAllowedSlots };

/**
 * The `Error` enum of this pallet.
 **/
export type PalletBabeError =
  /**
   * An equivocation proof provided as part of an equivocation report is invalid.
   **/
  | 'InvalidEquivocationProof'
  /**
   * A key ownership proof provided as part of an equivocation report is invalid.
   **/
  | 'InvalidKeyOwnershipProof'
  /**
   * A given equivocation report is valid but already previously reported.
   **/
  | 'DuplicateOffenceReport'
  /**
   * Submitted configuration is invalid.
   **/
  | 'InvalidConfiguration';

/**
 * The `Error` enum of this pallet.
 **/
export type PalletIndicesError =
  /**
   * The index was not already assigned.
   **/
  | 'NotAssigned'
  /**
   * The index is assigned to another account.
   **/
  | 'NotOwner'
  /**
   * The index was not available.
   **/
  | 'InUse'
  /**
   * The source and destination accounts are identical.
   **/
  | 'NotTransfer'
  /**
   * The index is permanent and may not be freed/changed.
   **/
  | 'Permanent';

export type PalletBalancesBalanceLock = { id: FixedBytes<8>; amount: bigint; reasons: PalletBalancesReasons };

export type PalletBalancesReasons = 'Fee' | 'Misc' | 'All';

export type PalletBalancesReserveData = { id: FixedBytes<8>; amount: bigint };

export type PalletBalancesIdAmount = { id: KitchensinkRuntimeRuntimeHoldReason; amount: bigint };

export type KitchensinkRuntimeRuntimeHoldReason =
  | { tag: 'Contracts'; value: PalletContractsHoldReason }
  | { tag: 'Nis'; value: PalletNisHoldReason }
  | { tag: 'NftFractionalization'; value: PalletNftFractionalizationHoldReason }
  | { tag: 'SafeMode'; value: PalletSafeModeHoldReason };

export type PalletContractsHoldReason = 'CodeUploadDepositReserve' | 'StorageDepositReserve';

export type PalletNisHoldReason = 'NftReceipt';

export type PalletNftFractionalizationHoldReason = 'Fractionalized';

export type PalletSafeModeHoldReason = 'EnterOrExtend';

export type PalletBalancesIdAmount002 = { id: []; amount: bigint };

/**
 * The `Error` enum of this pallet.
 **/
export type PalletBalancesError =
  /**
   * Vesting balance too high to send value.
   **/
  | 'VestingBalance'
  /**
   * Account liquidity restrictions prevent withdrawal.
   **/
  | 'LiquidityRestrictions'
  /**
   * Balance too low to send value.
   **/
  | 'InsufficientBalance'
  /**
   * Value too low to create account due to existential deposit.
   **/
  | 'ExistentialDeposit'
  /**
   * Transfer/payment would kill account.
   **/
  | 'Expendability'
  /**
   * A vesting schedule already exists for this account.
   **/
  | 'ExistingVestingSchedule'
  /**
   * Beneficiary account must pre-exist.
   **/
  | 'DeadAccount'
  /**
   * Number of named reserves exceed `MaxReserves`.
   **/
  | 'TooManyReserves'
  /**
   * Number of holds exceed `MaxHolds`.
   **/
  | 'TooManyHolds'
  /**
   * Number of freezes exceed `MaxFreezes`.
   **/
  | 'TooManyFreezes';

export type PalletTransactionPaymentReleases = 'V1Ancient' | 'V2';

export type PalletElectionProviderMultiPhaseReadySolution = {
  supports: Array<[AccountId32Like, SpNposElectionsSupport]>;
  score: SpNposElectionsElectionScore;
  compute: PalletElectionProviderMultiPhaseElectionCompute;
};

export type PalletElectionProviderMultiPhaseRoundSnapshot = {
  voters: Array<[AccountId32Like, bigint, Array<AccountId32Like>]>;
  targets: Array<AccountId32Like>;
};

export type PalletElectionProviderMultiPhaseSignedSignedSubmission = {
  who: AccountId32Like;
  deposit: bigint;
  rawSolution: PalletElectionProviderMultiPhaseRawSolution;
  callFee: bigint;
};

/**
 * Error of the pallet that can be returned in response to dispatches.
 **/
export type PalletElectionProviderMultiPhaseError =
  /**
   * Submission was too early.
   **/
  | 'PreDispatchEarlySubmission'
  /**
   * Wrong number of winners presented.
   **/
  | 'PreDispatchWrongWinnerCount'
  /**
   * Submission was too weak, score-wise.
   **/
  | 'PreDispatchWeakSubmission'
  /**
   * The queue was full, and the solution was not better than any of the existing ones.
   **/
  | 'SignedQueueFull'
  /**
   * The origin failed to pay the deposit.
   **/
  | 'SignedCannotPayDeposit'
  /**
   * Witness data to dispatchable is invalid.
   **/
  | 'SignedInvalidWitness'
  /**
   * The signed submission consumes too much weight
   **/
  | 'SignedTooMuchWeight'
  /**
   * OCW submitted solution for wrong round
   **/
  | 'OcwCallWrongEra'
  /**
   * Snapshot metadata should exist but didn't.
   **/
  | 'MissingSnapshotMetadata'
  /**
   * `Self::insert_submission` returned an invalid index.
   **/
  | 'InvalidSubmissionIndex'
  /**
   * The call is not allowed at this point.
   **/
  | 'CallNotAllowed'
  /**
   * The fallback failed
   **/
  | 'FallbackFailed'
  /**
   * Some bound not met
   **/
  | 'BoundNotMet'
  /**
   * Submitted solution has too many winners
   **/
  | 'TooManyWinners';

export type PalletStakingStakingLedger = {
  stash: AccountId32Like;
  total: bigint;
  active: bigint;
  unlocking: Array<PalletStakingUnlockChunk>;
  claimedRewards: Array<number>;
};

export type PalletStakingUnlockChunk = { value: bigint; era: number };

export type PalletStakingNominations = { targets: Array<AccountId32Like>; submittedIn: number; suppressed: boolean };

export type PalletStakingActiveEraInfo = { index: number; start?: bigint | undefined };

export type PalletStakingEraRewardPoints = { total: number; individual: Array<[AccountId32Like, number]> };

export type PalletStakingUnappliedSlash = {
  validator: AccountId32Like;
  own: bigint;
  others: Array<[AccountId32Like, bigint]>;
  reporters: Array<AccountId32Like>;
  payout: bigint;
};

export type PalletStakingSlashingSlashingSpans = {
  spanIndex: number;
  lastStart: number;
  lastNonzeroSlash: number;
  prior: Array<number>;
};

export type PalletStakingSlashingSpanRecord = { slashed: bigint; paidOut: bigint };

/**
 * The `Error` enum of this pallet.
 **/
export type PalletStakingPalletError =
  /**
   * Not a controller account.
   **/
  | 'NotController'
  /**
   * Not a stash account.
   **/
  | 'NotStash'
  /**
   * Stash is already bonded.
   **/
  | 'AlreadyBonded'
  /**
   * Controller is already paired.
   **/
  | 'AlreadyPaired'
  /**
   * Targets cannot be empty.
   **/
  | 'EmptyTargets'
  /**
   * Duplicate index.
   **/
  | 'DuplicateIndex'
  /**
   * Slash record index out of bounds.
   **/
  | 'InvalidSlashIndex'
  /**
   * Cannot have a validator or nominator role, with value less than the minimum defined by
   * governance (see `MinValidatorBond` and `MinNominatorBond`). If unbonding is the
   * intention, `chill` first to remove one's role as validator/nominator.
   **/
  | 'InsufficientBond'
  /**
   * Can not schedule more unlock chunks.
   **/
  | 'NoMoreChunks'
  /**
   * Can not rebond without unlocking chunks.
   **/
  | 'NoUnlockChunk'
  /**
   * Attempting to target a stash that still has funds.
   **/
  | 'FundedTarget'
  /**
   * Invalid era to reward.
   **/
  | 'InvalidEraToReward'
  /**
   * Invalid number of nominations.
   **/
  | 'InvalidNumberOfNominations'
  /**
   * Items are not sorted and unique.
   **/
  | 'NotSortedAndUnique'
  /**
   * Rewards for this era have already been claimed for this validator.
   **/
  | 'AlreadyClaimed'
  /**
   * Incorrect previous history depth input provided.
   **/
  | 'IncorrectHistoryDepth'
  /**
   * Incorrect number of slashing spans provided.
   **/
  | 'IncorrectSlashingSpans'
  /**
   * Internal state has become somehow corrupted and the operation cannot continue.
   **/
  | 'BadState'
  /**
   * Too many nomination targets supplied.
   **/
  | 'TooManyTargets'
  /**
   * A nomination target was supplied that was blocked or otherwise not a validator.
   **/
  | 'BadTarget'
  /**
   * The user has enough bond and thus cannot be chilled forcefully by an external person.
   **/
  | 'CannotChillOther'
  /**
   * There are too many nominators in the system. Governance needs to adjust the staking
   * settings to keep things safe for the runtime.
   **/
  | 'TooManyNominators'
  /**
   * There are too many validator candidates in the system. Governance needs to adjust the
   * staking settings to keep things safe for the runtime.
   **/
  | 'TooManyValidators'
  /**
   * Commission is too low. Must be at least `MinCommission`.
   **/
  | 'CommissionTooLow'
  /**
   * Some bound is not met.
   **/
  | 'BoundNotMet';

export type SpCoreCryptoKeyTypeId = FixedBytes<4>;

/**
 * Error for the session pallet.
 **/
export type PalletSessionError =
  /**
   * Invalid ownership proof.
   **/
  | 'InvalidProof'
  /**
   * No associated validator ID for account.
   **/
  | 'NoAssociatedValidatorId'
  /**
   * Registered duplicate key.
   **/
  | 'DuplicatedKey'
  /**
   * No keys are associated with this account.
   **/
  | 'NoKeys'
  /**
   * Key setting account is not live, so it's impossible to associate keys.
   **/
  | 'NoAccount';

export type PalletDemocracyReferendumInfo =
  | { tag: 'Ongoing'; value: PalletDemocracyReferendumStatus }
  | { tag: 'Finished'; value: { approved: boolean; end: number } };

export type PalletDemocracyReferendumStatus = {
  end: number;
  proposal: FrameSupportPreimagesBounded;
  threshold: PalletDemocracyVoteThreshold;
  delay: number;
  tally: PalletDemocracyTally;
};

export type PalletDemocracyTally = { ayes: bigint; nays: bigint; turnout: bigint };

export type PalletDemocracyVoteVoting =
  | {
      tag: 'Direct';
      value: {
        votes: Array<[number, PalletDemocracyVoteAccountVote]>;
        delegations: PalletDemocracyDelegations;
        prior: PalletDemocracyVotePriorLock;
      };
    }
  | {
      tag: 'Delegating';
      value: {
        balance: bigint;
        target: AccountId32Like;
        conviction: PalletDemocracyConviction;
        delegations: PalletDemocracyDelegations;
        prior: PalletDemocracyVotePriorLock;
      };
    };

export type PalletDemocracyDelegations = { votes: bigint; capital: bigint };

export type PalletDemocracyVotePriorLock = [number, bigint];

/**
 * The `Error` enum of this pallet.
 **/
export type PalletDemocracyError =
  /**
   * Value too low
   **/
  | 'ValueLow'
  /**
   * Proposal does not exist
   **/
  | 'ProposalMissing'
  /**
   * Cannot cancel the same proposal twice
   **/
  | 'AlreadyCanceled'
  /**
   * Proposal already made
   **/
  | 'DuplicateProposal'
  /**
   * Proposal still blacklisted
   **/
  | 'ProposalBlacklisted'
  /**
   * Next external proposal not simple majority
   **/
  | 'NotSimpleMajority'
  /**
   * Invalid hash
   **/
  | 'InvalidHash'
  /**
   * No external proposal
   **/
  | 'NoProposal'
  /**
   * Identity may not veto a proposal twice
   **/
  | 'AlreadyVetoed'
  /**
   * Vote given for invalid referendum
   **/
  | 'ReferendumInvalid'
  /**
   * No proposals waiting
   **/
  | 'NoneWaiting'
  /**
   * The given account did not vote on the referendum.
   **/
  | 'NotVoter'
  /**
   * The actor has no permission to conduct the action.
   **/
  | 'NoPermission'
  /**
   * The account is already delegating.
   **/
  | 'AlreadyDelegating'
  /**
   * Too high a balance was provided that the account cannot afford.
   **/
  | 'InsufficientFunds'
  /**
   * The account is not currently delegating.
   **/
  | 'NotDelegating'
  /**
   * The account currently has votes attached to it and the operation cannot succeed until
   * these are removed, either through `unvote` or `reap_vote`.
   **/
  | 'VotesExist'
  /**
   * The instant referendum origin is currently disallowed.
   **/
  | 'InstantNotAllowed'
  /**
   * Delegation to oneself makes no sense.
   **/
  | 'Nonsense'
  /**
   * Invalid upper bound.
   **/
  | 'WrongUpperBound'
  /**
   * Maximum number of votes reached.
   **/
  | 'MaxVotesReached'
  /**
   * Maximum number of items reached.
   **/
  | 'TooMany'
  /**
   * Voting period too low
   **/
  | 'VotingPeriodLow'
  /**
   * The preimage does not exist.
   **/
  | 'PreimageNotExist';

export type PalletCollectiveVotes = {
  index: number;
  threshold: number;
  ayes: Array<AccountId32Like>;
  nays: Array<AccountId32Like>;
  end: number;
};

/**
 * The `Error` enum of this pallet.
 **/
export type PalletCollectiveError =
  /**
   * Account is not a member
   **/
  | 'NotMember'
  /**
   * Duplicate proposals not allowed
   **/
  | 'DuplicateProposal'
  /**
   * Proposal must exist
   **/
  | 'ProposalMissing'
  /**
   * Mismatched index
   **/
  | 'WrongIndex'
  /**
   * Duplicate vote ignored
   **/
  | 'DuplicateVote'
  /**
   * Members are already initialized!
   **/
  | 'AlreadyInitialized'
  /**
   * The close call was made too early, before the end of the voting.
   **/
  | 'TooEarly'
  /**
   * There can only be a maximum of `MaxProposals` active proposals.
   **/
  | 'TooManyProposals'
  /**
   * The given weight bound for the proposal was too low.
   **/
  | 'WrongProposalWeight'
  /**
   * The given length bound for the proposal was too low.
   **/
  | 'WrongProposalLength'
  /**
   * Prime account is not a member
   **/
  | 'PrimeAccountNotMember';

export type PalletElectionsPhragmenSeatHolder = { who: AccountId32Like; stake: bigint; deposit: bigint };

export type PalletElectionsPhragmenVoter = { votes: Array<AccountId32Like>; stake: bigint; deposit: bigint };

/**
 * The `Error` enum of this pallet.
 **/
export type PalletElectionsPhragmenError =
  /**
   * Cannot vote when no candidates or members exist.
   **/
  | 'UnableToVote'
  /**
   * Must vote for at least one candidate.
   **/
  | 'NoVotes'
  /**
   * Cannot vote more than candidates.
   **/
  | 'TooManyVotes'
  /**
   * Cannot vote more than maximum allowed.
   **/
  | 'MaximumVotesExceeded'
  /**
   * Cannot vote with stake less than minimum balance.
   **/
  | 'LowBalance'
  /**
   * Voter can not pay voting bond.
   **/
  | 'UnableToPayBond'
  /**
   * Must be a voter.
   **/
  | 'MustBeVoter'
  /**
   * Duplicated candidate submission.
   **/
  | 'DuplicatedCandidate'
  /**
   * Too many candidates have been created.
   **/
  | 'TooManyCandidates'
  /**
   * Member cannot re-submit candidacy.
   **/
  | 'MemberSubmit'
  /**
   * Runner cannot re-submit candidacy.
   **/
  | 'RunnerUpSubmit'
  /**
   * Candidate does not have enough funds.
   **/
  | 'InsufficientCandidateFunds'
  /**
   * Not a member.
   **/
  | 'NotMember'
  /**
   * The provided count of number of candidates is incorrect.
   **/
  | 'InvalidWitnessData'
  /**
   * The provided count of number of votes is incorrect.
   **/
  | 'InvalidVoteCount'
  /**
   * The renouncing origin presented a wrong `Renouncing` parameter.
   **/
  | 'InvalidRenouncing'
  /**
   * Prediction regarding replacement after member removal is wrong.
   **/
  | 'InvalidReplacement';

/**
 * The `Error` enum of this pallet.
 **/
export type PalletMembershipError =
  /**
   * Already a member.
   **/
  | 'AlreadyMember'
  /**
   * Not a member.
   **/
  | 'NotMember'
  /**
   * Too many members.
   **/
  | 'TooManyMembers';

export type PalletGrandpaStoredState =
  | { tag: 'Live' }
  | { tag: 'PendingPause'; value: { scheduledAt: number; delay: number } }
  | { tag: 'Paused' }
  | { tag: 'PendingResume'; value: { scheduledAt: number; delay: number } };

export type PalletGrandpaStoredPendingChange = {
  scheduledAt: number;
  delay: number;
  nextAuthorities: Array<[SpConsensusGrandpaAppPublic, bigint]>;
  forced?: number | undefined;
};

/**
 * The `Error` enum of this pallet.
 **/
export type PalletGrandpaError =
  /**
   * Attempt to signal GRANDPA pause when the authority set isn't live
   * (either paused or already pending pause).
   **/
  | 'PauseFailed'
  /**
   * Attempt to signal GRANDPA resume when the authority set isn't paused
   * (either live or already pending resume).
   **/
  | 'ResumeFailed'
  /**
   * Attempt to signal GRANDPA change with one already pending.
   **/
  | 'ChangePending'
  /**
   * Cannot signal forced change so soon after last.
   **/
  | 'TooSoon'
  /**
   * A key ownership proof provided as part of an equivocation report is invalid.
   **/
  | 'InvalidKeyOwnershipProof'
  /**
   * An equivocation proof provided as part of an equivocation report is invalid.
   **/
  | 'InvalidEquivocationProof'
  /**
   * A given equivocation report is valid but already previously reported.
   **/
  | 'DuplicateOffenceReport';

export type PalletTreasuryProposal = {
  proposer: AccountId32Like;
  value: bigint;
  beneficiary: AccountId32Like;
  bond: bigint;
};

export type FrameSupportPalletId = FixedBytes<8>;

/**
 * Error for the treasury pallet.
 **/
export type PalletTreasuryError =
  /**
   * Proposer's balance is too low.
   **/
  | 'InsufficientProposersBalance'
  /**
   * No proposal or bounty at that index.
   **/
  | 'InvalidIndex'
  /**
   * Too many approvals in the queue.
   **/
  | 'TooManyApprovals'
  /**
   * The spend origin is valid but the amount it is allowed to spend is lower than the
   * amount to be spent.
   **/
  | 'InsufficientPermission'
  /**
   * Proposal has not been approved.
   **/
  | 'ProposalNotApproved';

/**
 * The `Error` enum of this pallet.
 **/
export type PalletAssetRateError =
  /**
   * The given asset ID is unknown.
   **/
  | 'UnknownAssetKind'
  /**
   * The given asset ID already has an assigned conversion rate and cannot be re-created.
   **/
  | 'AlreadyExists';

export type PalletContractsWasmCodeInfo = {
  owner: AccountId32Like;
  deposit: bigint;
  refcount: bigint;
  determinism: PalletContractsWasmDeterminism;
  codeLen: number;
};

export type PalletContractsStorageContractInfo = {
  trieId: Bytes;
  codeHash: H256;
  storageBytes: number;
  storageItems: number;
  storageByteDeposit: bigint;
  storageItemDeposit: bigint;
  storageBaseDeposit: bigint;
  delegateDependencies: Array<[H256, bigint]>;
};

export type PalletContractsStorageDeletionQueueManager = { insertCounter: number; deleteCounter: number };

export type PalletContractsSchedule = {
  limits: PalletContractsScheduleLimits;
  instructionWeights: PalletContractsScheduleInstructionWeights;
  hostFnWeights: PalletContractsScheduleHostFnWeights;
};

export type PalletContractsScheduleLimits = {
  eventTopics: number;
  globals: number;
  locals: number;
  parameters: number;
  memoryPages: number;
  tableSize: number;
  brTableSize: number;
  subjectLen: number;
  payloadLen: number;
  runtimeMemory: number;
};

export type PalletContractsScheduleInstructionWeights = { base: number };

export type PalletContractsScheduleHostFnWeights = {
  caller: SpWeightsWeightV2Weight;
  isContract: SpWeightsWeightV2Weight;
  codeHash: SpWeightsWeightV2Weight;
  ownCodeHash: SpWeightsWeightV2Weight;
  callerIsOrigin: SpWeightsWeightV2Weight;
  callerIsRoot: SpWeightsWeightV2Weight;
  address: SpWeightsWeightV2Weight;
  gasLeft: SpWeightsWeightV2Weight;
  balance: SpWeightsWeightV2Weight;
  valueTransferred: SpWeightsWeightV2Weight;
  minimumBalance: SpWeightsWeightV2Weight;
  blockNumber: SpWeightsWeightV2Weight;
  now: SpWeightsWeightV2Weight;
  weightToFee: SpWeightsWeightV2Weight;
  input: SpWeightsWeightV2Weight;
  inputPerByte: SpWeightsWeightV2Weight;
  rReturn: SpWeightsWeightV2Weight;
  returnPerByte: SpWeightsWeightV2Weight;
  terminate: SpWeightsWeightV2Weight;
  random: SpWeightsWeightV2Weight;
  depositEvent: SpWeightsWeightV2Weight;
  depositEventPerTopic: SpWeightsWeightV2Weight;
  depositEventPerByte: SpWeightsWeightV2Weight;
  debugMessage: SpWeightsWeightV2Weight;
  debugMessagePerByte: SpWeightsWeightV2Weight;
  setStorage: SpWeightsWeightV2Weight;
  setStoragePerNewByte: SpWeightsWeightV2Weight;
  setStoragePerOldByte: SpWeightsWeightV2Weight;
  setCodeHash: SpWeightsWeightV2Weight;
  clearStorage: SpWeightsWeightV2Weight;
  clearStoragePerByte: SpWeightsWeightV2Weight;
  containsStorage: SpWeightsWeightV2Weight;
  containsStoragePerByte: SpWeightsWeightV2Weight;
  getStorage: SpWeightsWeightV2Weight;
  getStoragePerByte: SpWeightsWeightV2Weight;
  takeStorage: SpWeightsWeightV2Weight;
  takeStoragePerByte: SpWeightsWeightV2Weight;
  transfer: SpWeightsWeightV2Weight;
  call: SpWeightsWeightV2Weight;
  delegateCall: SpWeightsWeightV2Weight;
  callTransferSurcharge: SpWeightsWeightV2Weight;
  callPerClonedByte: SpWeightsWeightV2Weight;
  instantiate: SpWeightsWeightV2Weight;
  instantiateTransferSurcharge: SpWeightsWeightV2Weight;
  instantiatePerInputByte: SpWeightsWeightV2Weight;
  instantiatePerSaltByte: SpWeightsWeightV2Weight;
  hashSha2256: SpWeightsWeightV2Weight;
  hashSha2256PerByte: SpWeightsWeightV2Weight;
  hashKeccak256: SpWeightsWeightV2Weight;
  hashKeccak256PerByte: SpWeightsWeightV2Weight;
  hashBlake2256: SpWeightsWeightV2Weight;
  hashBlake2256PerByte: SpWeightsWeightV2Weight;
  hashBlake2128: SpWeightsWeightV2Weight;
  hashBlake2128PerByte: SpWeightsWeightV2Weight;
  ecdsaRecover: SpWeightsWeightV2Weight;
  ecdsaToEthAddress: SpWeightsWeightV2Weight;
  sr25519Verify: SpWeightsWeightV2Weight;
  sr25519VerifyPerByte: SpWeightsWeightV2Weight;
  reentranceCount: SpWeightsWeightV2Weight;
  accountReentranceCount: SpWeightsWeightV2Weight;
  instantiationNonce: SpWeightsWeightV2Weight;
  addDelegateDependency: SpWeightsWeightV2Weight;
  removeDelegateDependency: SpWeightsWeightV2Weight;
};

export type PalletContractsEnvironment = {
  accountId: PalletContractsEnvironmentType;
  balance: PalletContractsEnvironmentTypeU128;
  hash: PalletContractsEnvironmentTypeH256;
  hasher: PalletContractsEnvironmentTypeBlakeTwo256;
  timestamp: PalletContractsEnvironmentTypeU64;
  blockNumber: PalletContractsEnvironmentTypeU32;
};

export type PalletContractsEnvironmentType = {};

export type PalletContractsEnvironmentTypeU128 = {};

export type PalletContractsEnvironmentTypeH256 = {};

export type PalletContractsEnvironmentTypeBlakeTwo256 = {};

export type SpRuntimeBlakeTwo256 = {};

export type PalletContractsEnvironmentTypeU64 = {};

export type PalletContractsEnvironmentTypeU32 = {};

/**
 * The `Error` enum of this pallet.
 **/
export type PalletContractsError =
  /**
   * Invalid schedule supplied, e.g. with zero weight of a basic operation.
   **/
  | 'InvalidSchedule'
  /**
   * Invalid combination of flags supplied to `seal_call` or `seal_delegate_call`.
   **/
  | 'InvalidCallFlags'
  /**
   * The executed contract exhausted its gas limit.
   **/
  | 'OutOfGas'
  /**
   * The output buffer supplied to a contract API call was too small.
   **/
  | 'OutputBufferTooSmall'
  /**
   * Performing the requested transfer failed. Probably because there isn't enough
   * free balance in the sender's account.
   **/
  | 'TransferFailed'
  /**
   * Performing a call was denied because the calling depth reached the limit
   * of what is specified in the schedule.
   **/
  | 'MaxCallDepthReached'
  /**
   * No contract was found at the specified address.
   **/
  | 'ContractNotFound'
  /**
   * The code supplied to `instantiate_with_code` exceeds the limit specified in the
   * current schedule.
   **/
  | 'CodeTooLarge'
  /**
   * No code could be found at the supplied code hash.
   **/
  | 'CodeNotFound'
  /**
   * No code info could be found at the supplied code hash.
   **/
  | 'CodeInfoNotFound'
  /**
   * A buffer outside of sandbox memory was passed to a contract API function.
   **/
  | 'OutOfBounds'
  /**
   * Input passed to a contract API function failed to decode as expected type.
   **/
  | 'DecodingFailed'
  /**
   * Contract trapped during execution.
   **/
  | 'ContractTrapped'
  /**
   * The size defined in `T::MaxValueSize` was exceeded.
   **/
  | 'ValueTooLarge'
  /**
   * Termination of a contract is not allowed while the contract is already
   * on the call stack. Can be triggered by `seal_terminate`.
   **/
  | 'TerminatedWhileReentrant'
  /**
   * `seal_call` forwarded this contracts input. It therefore is no longer available.
   **/
  | 'InputForwarded'
  /**
   * The subject passed to `seal_random` exceeds the limit.
   **/
  | 'RandomSubjectTooLong'
  /**
   * The amount of topics passed to `seal_deposit_events` exceeds the limit.
   **/
  | 'TooManyTopics'
  /**
   * The chain does not provide a chain extension. Calling the chain extension results
   * in this error. Note that this usually shouldn't happen as deploying such contracts
   * is rejected.
   **/
  | 'NoChainExtension'
  /**
   * A contract with the same AccountId already exists.
   **/
  | 'DuplicateContract'
  /**
   * A contract self destructed in its constructor.
   *
   * This can be triggered by a call to `seal_terminate`.
   **/
  | 'TerminatedInConstructor'
  /**
   * A call tried to invoke a contract that is flagged as non-reentrant.
   * The only other cause is that a call from a contract into the runtime tried to call back
   * into `pallet-contracts`. This would make the whole pallet reentrant with regard to
   * contract code execution which is not supported.
   **/
  | 'ReentranceDenied'
  /**
   * Origin doesn't have enough balance to pay the required storage deposits.
   **/
  | 'StorageDepositNotEnoughFunds'
  /**
   * More storage was created than allowed by the storage deposit limit.
   **/
  | 'StorageDepositLimitExhausted'
  /**
   * Code removal was denied because the code is still in use by at least one contract.
   **/
  | 'CodeInUse'
  /**
   * The contract ran to completion but decided to revert its storage changes.
   * Please note that this error is only returned from extrinsics. When called directly
   * or via RPC an `Ok` will be returned. In this case the caller needs to inspect the flags
   * to determine whether a reversion has taken place.
   **/
  | 'ContractReverted'
  /**
   * The contract's code was found to be invalid during validation.
   *
   * The most likely cause of this is that an API was used which is not supported by the
   * node. This happens if an older node is used with a new version of ink!. Try updating
   * your node to the newest available version.
   *
   * A more detailed error can be found on the node console if debug messages are enabled
   * by supplying `-lruntime::contracts=debug`.
   **/
  | 'CodeRejected'
  /**
   * An indetermistic code was used in a context where this is not permitted.
   **/
  | 'Indeterministic'
  /**
   * A pending migration needs to complete before the extrinsic can be called.
   **/
  | 'MigrationInProgress'
  /**
   * Migrate dispatch call was attempted but no migration was performed.
   **/
  | 'NoMigrationPerformed'
  /**
   * The contract has reached its maximum number of delegate dependencies.
   **/
  | 'MaxDelegateDependenciesReached'
  /**
   * The dependency was not found in the contract's delegate dependencies.
   **/
  | 'DelegateDependencyNotFound'
  /**
   * The contract already depends on the given delegate dependency.
   **/
  | 'DelegateDependencyAlreadyExists'
  /**
   * Can not add a delegate dependency to the code hash of the contract itself.
   **/
  | 'CannotAddSelfAsDelegateDependency';

/**
 * Error for the Sudo pallet
 **/
export type PalletSudoError =
  /**
   * Sender must be the Sudo account
   **/
  'RequireSudo';

/**
 * The `Error` enum of this pallet.
 **/
export type PalletImOnlineError =
  /**
   * Non existent public key.
   **/
  | 'InvalidKey'
  /**
   * Duplicated heartbeat.
   **/
  | 'DuplicatedHeartbeat';

export type SpStakingOffenceOffenceDetails = {
  offender: [AccountId32Like, PalletStakingExposure];
  reporters: Array<AccountId32Like>;
};

export type PalletIdentityRegistration = {
  judgements: Array<[number, PalletIdentityJudgement]>;
  deposit: bigint;
  info: PalletIdentityIdentityInfo;
};

export type PalletIdentityRegistrarInfo = { account: AccountId32Like; fee: bigint; fields: PalletIdentityBitFlags };

/**
 * The `Error` enum of this pallet.
 **/
export type PalletIdentityError =
  /**
   * Too many subs-accounts.
   **/
  | 'TooManySubAccounts'
  /**
   * Account isn't found.
   **/
  | 'NotFound'
  /**
   * Account isn't named.
   **/
  | 'NotNamed'
  /**
   * Empty index.
   **/
  | 'EmptyIndex'
  /**
   * Fee is changed.
   **/
  | 'FeeChanged'
  /**
   * No identity found.
   **/
  | 'NoIdentity'
  /**
   * Sticky judgement.
   **/
  | 'StickyJudgement'
  /**
   * Judgement given.
   **/
  | 'JudgementGiven'
  /**
   * Invalid judgement.
   **/
  | 'InvalidJudgement'
  /**
   * The index is invalid.
   **/
  | 'InvalidIndex'
  /**
   * The target is invalid.
   **/
  | 'InvalidTarget'
  /**
   * Too many additional fields.
   **/
  | 'TooManyFields'
  /**
   * Maximum amount of registrars reached. Cannot add any more.
   **/
  | 'TooManyRegistrars'
  /**
   * Account ID is already named.
   **/
  | 'AlreadyClaimed'
  /**
   * Sender is not a sub-account.
   **/
  | 'NotSub'
  /**
   * Sub-account isn't owned by sender.
   **/
  | 'NotOwned'
  /**
   * The provided judgement was for a different identity.
   **/
  | 'JudgementForDifferentIdentity'
  /**
   * Error that occurs when there is an issue paying for judgement.
   **/
  | 'JudgementPaymentFailed';

export type PalletSocietyMemberRecord = {
  rank: number;
  strikes: number;
  vouching?: PalletSocietyVouchingStatus | undefined;
  index: number;
};

export type PalletSocietyVouchingStatus = 'Vouching' | 'Banned';

export type PalletSocietyPayoutRecord = { paid: bigint; payouts: Array<[number, bigint]> };

export type PalletSocietyBid = { who: AccountId32Like; kind: PalletSocietyBidKind; value: bigint };

export type PalletSocietyBidKind =
  | { tag: 'Deposit'; value: bigint }
  | { tag: 'Vouch'; value: [AccountId32Like, bigint] };

export type PalletSocietyCandidacy = {
  round: number;
  kind: PalletSocietyBidKind;
  bid: bigint;
  tally: PalletSocietyTally;
  skepticStruck: boolean;
};

export type PalletSocietyTally = { approvals: number; rejections: number };

export type PalletSocietyVote = { approve: boolean; weight: number };

export type PalletSocietyIntakeRecord = { who: AccountId32Like; bid: bigint; round: number };

/**
 * The `Error` enum of this pallet.
 **/
export type PalletSocietyError =
  /**
   * User is not a member.
   **/
  | 'NotMember'
  /**
   * User is already a member.
   **/
  | 'AlreadyMember'
  /**
   * User is suspended.
   **/
  | 'Suspended'
  /**
   * User is not suspended.
   **/
  | 'NotSuspended'
  /**
   * Nothing to payout.
   **/
  | 'NoPayout'
  /**
   * Society already founded.
   **/
  | 'AlreadyFounded'
  /**
   * Not enough in pot to accept candidate.
   **/
  | 'InsufficientPot'
  /**
   * Member is already vouching or banned from vouching again.
   **/
  | 'AlreadyVouching'
  /**
   * Member is not vouching.
   **/
  | 'NotVouchingOnBidder'
  /**
   * Cannot remove the head of the chain.
   **/
  | 'Head'
  /**
   * Cannot remove the founder.
   **/
  | 'Founder'
  /**
   * User has already made a bid.
   **/
  | 'AlreadyBid'
  /**
   * User is already a candidate.
   **/
  | 'AlreadyCandidate'
  /**
   * User is not a candidate.
   **/
  | 'NotCandidate'
  /**
   * Too many members in the society.
   **/
  | 'MaxMembers'
  /**
   * The caller is not the founder.
   **/
  | 'NotFounder'
  /**
   * The caller is not the head.
   **/
  | 'NotHead'
  /**
   * The membership cannot be claimed as the candidate was not clearly approved.
   **/
  | 'NotApproved'
  /**
   * The candidate cannot be kicked as the candidate was not clearly rejected.
   **/
  | 'NotRejected'
  /**
   * The candidacy cannot be dropped as the candidate was clearly approved.
   **/
  | 'Approved'
  /**
   * The candidacy cannot be bestowed as the candidate was clearly rejected.
   **/
  | 'Rejected'
  /**
   * The candidacy cannot be concluded as the voting is still in progress.
   **/
  | 'InProgress'
  /**
   * The candidacy cannot be pruned until a full additional intake period has passed.
   **/
  | 'TooEarly'
  /**
   * The skeptic already voted.
   **/
  | 'Voted'
  /**
   * The skeptic need not vote on candidates from expired rounds.
   **/
  | 'Expired'
  /**
   * User is not a bidder.
   **/
  | 'NotBidder'
  /**
   * There is no defender currently.
   **/
  | 'NoDefender'
  /**
   * Group doesn't exist.
   **/
  | 'NotGroup'
  /**
   * The member is already elevated to this rank.
   **/
  | 'AlreadyElevated'
  /**
   * The skeptic has already been punished for this offence.
   **/
  | 'AlreadyPunished'
  /**
   * Funds are insufficient to pay off society debts.
   **/
  | 'InsufficientFunds'
  /**
   * The candidate/defender has no stale votes to remove.
   **/
  | 'NoVotes';

export type PalletRecoveryRecoveryConfig = {
  delayPeriod: number;
  deposit: bigint;
  friends: Array<AccountId32Like>;
  threshold: number;
};

export type PalletRecoveryActiveRecovery = { created: number; deposit: bigint; friends: Array<AccountId32Like> };

/**
 * The `Error` enum of this pallet.
 **/
export type PalletRecoveryError =
  /**
   * User is not allowed to make a call on behalf of this account
   **/
  | 'NotAllowed'
  /**
   * Threshold must be greater than zero
   **/
  | 'ZeroThreshold'
  /**
   * Friends list must be greater than zero and threshold
   **/
  | 'NotEnoughFriends'
  /**
   * Friends list must be less than max friends
   **/
  | 'MaxFriends'
  /**
   * Friends list must be sorted and free of duplicates
   **/
  | 'NotSorted'
  /**
   * This account is not set up for recovery
   **/
  | 'NotRecoverable'
  /**
   * This account is already set up for recovery
   **/
  | 'AlreadyRecoverable'
  /**
   * A recovery process has already started for this account
   **/
  | 'AlreadyStarted'
  /**
   * A recovery process has not started for this rescuer
   **/
  | 'NotStarted'
  /**
   * This account is not a friend who can vouch
   **/
  | 'NotFriend'
  /**
   * The friend must wait until the delay period to vouch for this recovery
   **/
  | 'DelayPeriod'
  /**
   * This user has already vouched for this recovery
   **/
  | 'AlreadyVouched'
  /**
   * The threshold for recovering this account has not been met
   **/
  | 'Threshold'
  /**
   * There are still active recovery attempts that need to be closed
   **/
  | 'StillActive'
  /**
   * This account is already set up for recovery
   **/
  | 'AlreadyProxy'
  /**
   * Some internal state is broken.
   **/
  | 'BadState';

export type PalletVestingReleases = 'V0' | 'V1';

/**
 * Error for the vesting pallet.
 **/
export type PalletVestingError =
  /**
   * The account given is not vesting.
   **/
  | 'NotVesting'
  /**
   * The account already has `MaxVestingSchedules` count of schedules and thus
   * cannot add another one. Consider merging existing schedules in order to add another.
   **/
  | 'AtMaxVestingSchedules'
  /**
   * Amount being transferred is too low to create a vesting schedule.
   **/
  | 'AmountLow'
  /**
   * An index was out of bounds of the vesting schedules.
   **/
  | 'ScheduleIndexOutOfBounds'
  /**
   * Failed to create a new schedule because some parameter was invalid.
   **/
  | 'InvalidScheduleParams';

export type PalletSchedulerScheduled = {
  maybeId?: FixedBytes<32> | undefined;
  priority: number;
  call: FrameSupportPreimagesBounded;
  maybePeriodic?: [number, number] | undefined;
  origin: KitchensinkRuntimeOriginCaller;
};

/**
 * The `Error` enum of this pallet.
 **/
export type PalletSchedulerError =
  /**
   * Failed to schedule a call
   **/
  | 'FailedToSchedule'
  /**
   * Cannot find the scheduled call.
   **/
  | 'NotFound'
  /**
   * Given target block number is in the past.
   **/
  | 'TargetBlockNumberInPast'
  /**
   * Reschedule failed because it does not change scheduled time.
   **/
  | 'RescheduleNoChange'
  /**
   * Attempt to use a non-named function on a named task.
   **/
  | 'Named';

/**
 * The `Error` enum of this pallet.
 **/
export type PalletGluttonError =
  /**
   * The pallet was already initialized.
   *
   * Set `witness_count` to `Some` to bypass this error.
   **/
  | 'AlreadyInitialized'
  /**
   * The limit was over [`crate::RESOURCE_HARD_LIMIT`].
   **/
  | 'InsaneLimit';

export type PalletPreimageRequestStatus =
  | { tag: 'Unrequested'; value: { deposit: [AccountId32Like, bigint]; len: number } }
  | {
      tag: 'Requested';
      value: { deposit?: [AccountId32Like, bigint] | undefined; count: number; len?: number | undefined };
    };

/**
 * The `Error` enum of this pallet.
 **/
export type PalletPreimageError =
  /**
   * Preimage is too large to store on-chain.
   **/
  | 'TooBig'
  /**
   * Preimage has already been noted on-chain.
   **/
  | 'AlreadyNoted'
  /**
   * The user is not authorized to perform this action.
   **/
  | 'NotAuthorized'
  /**
   * The preimage cannot be removed since it has not yet been noted.
   **/
  | 'NotNoted'
  /**
   * A preimage may not be removed when there are outstanding requests.
   **/
  | 'Requested'
  /**
   * The preimage request cannot be removed since no outstanding requests exist.
   **/
  | 'NotRequested';

export type PalletProxyProxyDefinition = {
  delegate: AccountId32Like;
  proxyType: KitchensinkRuntimeProxyType;
  delay: number;
};

export type PalletProxyAnnouncement = { real: AccountId32Like; callHash: H256; height: number };

/**
 * The `Error` enum of this pallet.
 **/
export type PalletProxyError =
  /**
   * There are too many proxies registered or too many announcements pending.
   **/
  | 'TooMany'
  /**
   * Proxy registration not found.
   **/
  | 'NotFound'
  /**
   * Sender is not a proxy of the account to be proxied.
   **/
  | 'NotProxy'
  /**
   * A call which is incompatible with the proxy type's filter was attempted.
   **/
  | 'Unproxyable'
  /**
   * Account is already a proxy.
   **/
  | 'Duplicate'
  /**
   * Call may not be made by proxy because it may escalate its privileges.
   **/
  | 'NoPermission'
  /**
   * Announcement, if made at all, was made too recently.
   **/
  | 'Unannounced'
  /**
   * Cannot add self as proxy.
   **/
  | 'NoSelfProxy';

export type PalletMultisigMultisig = {
  when: PalletMultisigTimepoint;
  deposit: bigint;
  depositor: AccountId32Like;
  approvals: Array<AccountId32Like>;
};

/**
 * The `Error` enum of this pallet.
 **/
export type PalletMultisigError =
  /**
   * Threshold must be 2 or greater.
   **/
  | 'MinimumThreshold'
  /**
   * Call is already approved by this signatory.
   **/
  | 'AlreadyApproved'
  /**
   * Call doesn't need any (more) approvals.
   **/
  | 'NoApprovalsNeeded'
  /**
   * There are too few signatories in the list.
   **/
  | 'TooFewSignatories'
  /**
   * There are too many signatories in the list.
   **/
  | 'TooManySignatories'
  /**
   * The signatories were provided out of order; they should be ordered.
   **/
  | 'SignatoriesOutOfOrder'
  /**
   * The sender was contained in the other signatories; it shouldn't be.
   **/
  | 'SenderInSignatories'
  /**
   * Multisig operation not found when attempting to cancel.
   **/
  | 'NotFound'
  /**
   * Only the account that originally created the multisig is able to cancel it.
   **/
  | 'NotOwner'
  /**
   * No timepoint was given, yet the multisig operation is already underway.
   **/
  | 'NoTimepoint'
  /**
   * A different timepoint was given to the multisig operation that is underway.
   **/
  | 'WrongTimepoint'
  /**
   * A timepoint was given, yet no multisig operation is underway.
   **/
  | 'UnexpectedTimepoint'
  /**
   * The maximum weight information provided was too low.
   **/
  | 'MaxWeightTooLow'
  /**
   * The data to be stored is already stored.
   **/
  | 'AlreadyStored';

export type PalletBountiesBounty = {
  proposer: AccountId32Like;
  value: bigint;
  fee: bigint;
  curatorDeposit: bigint;
  bond: bigint;
  status: PalletBountiesBountyStatus;
};

export type PalletBountiesBountyStatus =
  | { tag: 'Proposed' }
  | { tag: 'Approved' }
  | { tag: 'Funded' }
  | { tag: 'CuratorProposed'; value: { curator: AccountId32Like } }
  | { tag: 'Active'; value: { curator: AccountId32Like; updateDue: number } }
  | { tag: 'PendingPayout'; value: { curator: AccountId32Like; beneficiary: AccountId32Like; unlockAt: number } };

/**
 * The `Error` enum of this pallet.
 **/
export type PalletBountiesError =
  /**
   * Proposer's balance is too low.
   **/
  | 'InsufficientProposersBalance'
  /**
   * No proposal or bounty at that index.
   **/
  | 'InvalidIndex'
  /**
   * The reason given is just too big.
   **/
  | 'ReasonTooBig'
  /**
   * The bounty status is unexpected.
   **/
  | 'UnexpectedStatus'
  /**
   * Require bounty curator.
   **/
  | 'RequireCurator'
  /**
   * Invalid bounty value.
   **/
  | 'InvalidValue'
  /**
   * Invalid bounty fee.
   **/
  | 'InvalidFee'
  /**
   * A bounty payout is pending.
   * To cancel the bounty, you must unassign and slash the curator.
   **/
  | 'PendingPayout'
  /**
   * The bounties cannot be claimed/closed because it's still in the countdown period.
   **/
  | 'Premature'
  /**
   * The bounty cannot be closed because it has active child bounties.
   **/
  | 'HasActiveChildBounty'
  /**
   * Too many approvals are already queued.
   **/
  | 'TooManyQueued';

export type PalletTipsOpenTip = {
  reason: H256;
  who: AccountId32Like;
  finder: AccountId32Like;
  deposit: bigint;
  closes?: number | undefined;
  tips: Array<[AccountId32Like, bigint]>;
  findersFee: boolean;
};

/**
 * The `Error` enum of this pallet.
 **/
export type PalletTipsError =
  /**
   * The reason given is just too big.
   **/
  | 'ReasonTooBig'
  /**
   * The tip was already found/started.
   **/
  | 'AlreadyKnown'
  /**
   * The tip hash is unknown.
   **/
  | 'UnknownTip'
  /**
   * The account attempting to retract the tip is not the finder of the tip.
   **/
  | 'NotFinder'
  /**
   * The tip cannot be claimed/closed because there are not enough tippers yet.
   **/
  | 'StillOpen'
  /**
   * The tip cannot be claimed/closed because it's still in the countdown period.
   **/
  | 'Premature';

export type PalletAssetsAssetDetails = {
  owner: AccountId32Like;
  issuer: AccountId32Like;
  admin: AccountId32Like;
  freezer: AccountId32Like;
  supply: bigint;
  deposit: bigint;
  minBalance: bigint;
  isSufficient: boolean;
  accounts: number;
  sufficients: number;
  approvals: number;
  status: PalletAssetsAssetStatus;
};

export type PalletAssetsAssetStatus = 'Live' | 'Frozen' | 'Destroying';

export type PalletAssetsAssetAccount = {
  balance: bigint;
  status: PalletAssetsAccountStatus;
  reason: PalletAssetsExistenceReason;
  extra: [];
};

export type PalletAssetsAccountStatus = 'Liquid' | 'Frozen' | 'Blocked';

export type PalletAssetsExistenceReason =
  | { tag: 'Consumer' }
  | { tag: 'Sufficient' }
  | { tag: 'DepositHeld'; value: bigint }
  | { tag: 'DepositRefunded' }
  | { tag: 'DepositFrom'; value: [AccountId32Like, bigint] };

export type PalletAssetsApproval = { amount: bigint; deposit: bigint };

export type PalletAssetsAssetMetadata = {
  deposit: bigint;
  name: Bytes;
  symbol: Bytes;
  decimals: number;
  isFrozen: boolean;
};

/**
 * The `Error` enum of this pallet.
 **/
export type PalletAssetsError =
  /**
   * Account balance must be greater than or equal to the transfer amount.
   **/
  | 'BalanceLow'
  /**
   * The account to alter does not exist.
   **/
  | 'NoAccount'
  /**
   * The signing account has no permission to do the operation.
   **/
  | 'NoPermission'
  /**
   * The given asset ID is unknown.
   **/
  | 'Unknown'
  /**
   * The origin account is frozen.
   **/
  | 'Frozen'
  /**
   * The asset ID is already taken.
   **/
  | 'InUse'
  /**
   * Invalid witness data given.
   **/
  | 'BadWitness'
  /**
   * Minimum balance should be non-zero.
   **/
  | 'MinBalanceZero'
  /**
   * Unable to increment the consumer reference counters on the account. Either no provider
   * reference exists to allow a non-zero balance of a non-self-sufficient asset, or one
   * fewer then the maximum number of consumers has been reached.
   **/
  | 'UnavailableConsumer'
  /**
   * Invalid metadata given.
   **/
  | 'BadMetadata'
  /**
   * No approval exists that would allow the transfer.
   **/
  | 'Unapproved'
  /**
   * The source account would not survive the transfer and it needs to stay alive.
   **/
  | 'WouldDie'
  /**
   * The asset-account already exists.
   **/
  | 'AlreadyExists'
  /**
   * The asset-account doesn't have an associated deposit.
   **/
  | 'NoDeposit'
  /**
   * The operation would result in funds being burned.
   **/
  | 'WouldBurn'
  /**
   * The asset is a live asset and is actively being used. Usually emit for operations such
   * as `start_destroy` which require the asset to be in a destroying state.
   **/
  | 'LiveAsset'
  /**
   * The asset is not live, and likely being destroyed.
   **/
  | 'AssetNotLive'
  /**
   * The asset status is not the expected status.
   **/
  | 'IncorrectStatus'
  /**
   * The asset should be frozen before the given operation.
   **/
  | 'NotFrozen'
  /**
   * Callback action resulted in error
   **/
  | 'CallbackFailed';

export type PalletLotteryLotteryConfig = {
  price: bigint;
  start: number;
  length: number;
  delay: number;
  repeat: boolean;
};

/**
 * The `Error` enum of this pallet.
 **/
export type PalletLotteryError =
  /**
   * A lottery has not been configured.
   **/
  | 'NotConfigured'
  /**
   * A lottery is already in progress.
   **/
  | 'InProgress'
  /**
   * A lottery has already ended.
   **/
  | 'AlreadyEnded'
  /**
   * The call is not valid for an open lottery.
   **/
  | 'InvalidCall'
  /**
   * You are already participating in the lottery with this call.
   **/
  | 'AlreadyParticipating'
  /**
   * Too many calls for a single lottery.
   **/
  | 'TooManyCalls'
  /**
   * Failed to encode calls
   **/
  | 'EncodingFailed';

export type PalletNisBid = { amount: bigint; who: AccountId32Like };

export type PalletNisSummaryRecord = {
  proportionOwed: Perquintill;
  index: number;
  thawed: Perquintill;
  lastPeriod: number;
  receiptsOnHold: bigint;
};

export type PalletNisReceiptRecord = {
  proportion: Perquintill;
  owner?: [AccountId32Like, bigint] | undefined;
  expiry: number;
};

/**
 * The `Error` enum of this pallet.
 **/
export type PalletNisError =
  /**
   * The duration of the bid is less than one.
   **/
  | 'DurationTooSmall'
  /**
   * The duration is the bid is greater than the number of queues.
   **/
  | 'DurationTooBig'
  /**
   * The amount of the bid is less than the minimum allowed.
   **/
  | 'AmountTooSmall'
  /**
   * The queue for the bid's duration is full and the amount bid is too low to get in
   * through replacing an existing bid.
   **/
  | 'BidTooLow'
  /**
   * Receipt index is unknown.
   **/
  | 'UnknownReceipt'
  /**
   * Not the owner of the receipt.
   **/
  | 'NotOwner'
  /**
   * Bond not yet at expiry date.
   **/
  | 'NotExpired'
  /**
   * The given bid for retraction is not found.
   **/
  | 'UnknownBid'
  /**
   * The portion supplied is beyond the value of the receipt.
   **/
  | 'PortionTooBig'
  /**
   * Not enough funds are held to pay out.
   **/
  | 'Unfunded'
  /**
   * There are enough funds for what is required.
   **/
  | 'AlreadyFunded'
  /**
   * The thaw throttle has been reached for this period.
   **/
  | 'Throttled'
  /**
   * The operation would result in a receipt worth an insignficant value.
   **/
  | 'MakesDust'
  /**
   * The receipt is already communal.
   **/
  | 'AlreadyCommunal'
  /**
   * The receipt is already private.
   **/
  | 'AlreadyPrivate';

export type PalletUniquesCollectionDetails = {
  owner: AccountId32Like;
  issuer: AccountId32Like;
  admin: AccountId32Like;
  freezer: AccountId32Like;
  totalDeposit: bigint;
  freeHolding: boolean;
  items: number;
  itemMetadatas: number;
  attributes: number;
  isFrozen: boolean;
};

export type PalletUniquesItemDetails = {
  owner: AccountId32Like;
  approved?: AccountId32Like | undefined;
  isFrozen: boolean;
  deposit: bigint;
};

export type PalletUniquesCollectionMetadata = { deposit: bigint; data: Bytes; isFrozen: boolean };

export type PalletUniquesItemMetadata = { deposit: bigint; data: Bytes; isFrozen: boolean };

/**
 * The `Error` enum of this pallet.
 **/
export type PalletUniquesError =
  /**
   * The signing account has no permission to do the operation.
   **/
  | 'NoPermission'
  /**
   * The given item ID is unknown.
   **/
  | 'UnknownCollection'
  /**
   * The item ID has already been used for an item.
   **/
  | 'AlreadyExists'
  /**
   * The owner turned out to be different to what was expected.
   **/
  | 'WrongOwner'
  /**
   * Invalid witness data given.
   **/
  | 'BadWitness'
  /**
   * The item ID is already taken.
   **/
  | 'InUse'
  /**
   * The item or collection is frozen.
   **/
  | 'Frozen'
  /**
   * The delegate turned out to be different to what was expected.
   **/
  | 'WrongDelegate'
  /**
   * There is no delegate approved.
   **/
  | 'NoDelegate'
  /**
   * No approval exists that would allow the transfer.
   **/
  | 'Unapproved'
  /**
   * The named owner has not signed ownership of the collection is acceptable.
   **/
  | 'Unaccepted'
  /**
   * The item is locked.
   **/
  | 'Locked'
  /**
   * All items have been minted.
   **/
  | 'MaxSupplyReached'
  /**
   * The max supply has already been set.
   **/
  | 'MaxSupplyAlreadySet'
  /**
   * The provided max supply is less to the amount of items a collection already has.
   **/
  | 'MaxSupplyTooSmall'
  /**
   * The given item ID is unknown.
   **/
  | 'UnknownItem'
  /**
   * Item is not for sale.
   **/
  | 'NotForSale'
  /**
   * The provided bid is too low.
   **/
  | 'BidTooLow';

export type PalletNftsCollectionDetails = {
  owner: AccountId32Like;
  ownerDeposit: bigint;
  items: number;
  itemMetadatas: number;
  itemConfigs: number;
  attributes: number;
};

export type PalletNftsBitFlagsCollectionRole = number;

export type PalletNftsCollectionRole = 'Issuer' | 'Freezer' | 'Admin';

export type PalletNftsItemDetails = {
  owner: AccountId32Like;
  approvals: Array<[AccountId32Like, number | undefined]>;
  deposit: PalletNftsItemDeposit;
};

export type PalletNftsItemDeposit = { account: AccountId32Like; amount: bigint };

export type PalletNftsCollectionMetadata = { deposit: bigint; data: Bytes };

export type PalletNftsItemMetadata = { deposit: PalletNftsItemMetadataDeposit; data: Bytes };

export type PalletNftsItemMetadataDeposit = { account?: AccountId32Like | undefined; amount: bigint };

export type PalletNftsAttributeDeposit = { account?: AccountId32Like | undefined; amount: bigint };

export type PalletNftsPendingSwap = {
  desiredCollection: number;
  desiredItem?: number | undefined;
  price?: PalletNftsPriceWithDirection | undefined;
  deadline: number;
};

export type PalletNftsBitFlagsPalletFeature = bigint;

export type PalletNftsPalletFeature = 'Trading' | 'Attributes' | 'Approvals' | 'Swaps';

/**
 * The `Error` enum of this pallet.
 **/
export type PalletNftsError =
  /**
   * The signing account has no permission to do the operation.
   **/
  | 'NoPermission'
  /**
   * The given item ID is unknown.
   **/
  | 'UnknownCollection'
  /**
   * The item ID has already been used for an item.
   **/
  | 'AlreadyExists'
  /**
   * The approval had a deadline that expired, so the approval isn't valid anymore.
   **/
  | 'ApprovalExpired'
  /**
   * The owner turned out to be different to what was expected.
   **/
  | 'WrongOwner'
  /**
   * The witness data given does not match the current state of the chain.
   **/
  | 'BadWitness'
  /**
   * Collection ID is already taken.
   **/
  | 'CollectionIdInUse'
  /**
   * Items within that collection are non-transferable.
   **/
  | 'ItemsNonTransferable'
  /**
   * The provided account is not a delegate.
   **/
  | 'NotDelegate'
  /**
   * The delegate turned out to be different to what was expected.
   **/
  | 'WrongDelegate'
  /**
   * No approval exists that would allow the transfer.
   **/
  | 'Unapproved'
  /**
   * The named owner has not signed ownership acceptance of the collection.
   **/
  | 'Unaccepted'
  /**
   * The item is locked (non-transferable).
   **/
  | 'ItemLocked'
  /**
   * Item's attributes are locked.
   **/
  | 'LockedItemAttributes'
  /**
   * Collection's attributes are locked.
   **/
  | 'LockedCollectionAttributes'
  /**
   * Item's metadata is locked.
   **/
  | 'LockedItemMetadata'
  /**
   * Collection's metadata is locked.
   **/
  | 'LockedCollectionMetadata'
  /**
   * All items have been minted.
   **/
  | 'MaxSupplyReached'
  /**
   * The max supply is locked and can't be changed.
   **/
  | 'MaxSupplyLocked'
  /**
   * The provided max supply is less than the number of items a collection already has.
   **/
  | 'MaxSupplyTooSmall'
  /**
   * The given item ID is unknown.
   **/
  | 'UnknownItem'
  /**
   * Swap doesn't exist.
   **/
  | 'UnknownSwap'
  /**
   * The given item has no metadata set.
   **/
  | 'MetadataNotFound'
  /**
   * The provided attribute can't be found.
   **/
  | 'AttributeNotFound'
  /**
   * Item is not for sale.
   **/
  | 'NotForSale'
  /**
   * The provided bid is too low.
   **/
  | 'BidTooLow'
  /**
   * The item has reached its approval limit.
   **/
  | 'ReachedApprovalLimit'
  /**
   * The deadline has already expired.
   **/
  | 'DeadlineExpired'
  /**
   * The duration provided should be less than or equal to `MaxDeadlineDuration`.
   **/
  | 'WrongDuration'
  /**
   * The method is disabled by system settings.
   **/
  | 'MethodDisabled'
  /**
   * The provided setting can't be set.
   **/
  | 'WrongSetting'
  /**
   * Item's config already exists and should be equal to the provided one.
   **/
  | 'InconsistentItemConfig'
  /**
   * Config for a collection or an item can't be found.
   **/
  | 'NoConfig'
  /**
   * Some roles were not cleared.
   **/
  | 'RolesNotCleared'
  /**
   * Mint has not started yet.
   **/
  | 'MintNotStarted'
  /**
   * Mint has already ended.
   **/
  | 'MintEnded'
  /**
   * The provided Item was already used for claiming.
   **/
  | 'AlreadyClaimed'
  /**
   * The provided data is incorrect.
   **/
  | 'IncorrectData'
  /**
   * The extrinsic was sent by the wrong origin.
   **/
  | 'WrongOrigin'
  /**
   * The provided signature is incorrect.
   **/
  | 'WrongSignature'
  /**
   * The provided metadata might be too long.
   **/
  | 'IncorrectMetadata'
  /**
   * Can't set more attributes per one call.
   **/
  | 'MaxAttributesLimitReached'
  /**
   * The provided namespace isn't supported in this call.
   **/
  | 'WrongNamespace'
  /**
   * Can't delete non-empty collections.
   **/
  | 'CollectionNotEmpty'
  /**
   * The witness data should be provided.
   **/
  | 'WitnessRequired';

export type PalletNftFractionalizationDetails = {
  asset: number;
  fractions: bigint;
  deposit: bigint;
  assetCreator: AccountId32Like;
};

/**
 * The `Error` enum of this pallet.
 **/
export type PalletNftFractionalizationError =
  /**
   * Asset ID does not correspond to locked NFT.
   **/
  | 'IncorrectAssetId'
  /**
   * The signing account has no permission to do the operation.
   **/
  | 'NoPermission'
  /**
   * NFT doesn't exist.
   **/
  | 'NftNotFound'
  /**
   * NFT has not yet been fractionalised.
   **/
  | 'NftNotFractionalized';

export type PalletSalaryStatusType = {
  cycleIndex: number;
  cycleStart: number;
  budget: bigint;
  totalRegistrations: bigint;
  totalUnregisteredPaid: bigint;
};

export type PalletSalaryClaimantStatus = { lastActive: number; status: PalletSalaryClaimState };

export type PalletSalaryClaimState =
  | { tag: 'Nothing' }
  | { tag: 'Registered'; value: bigint }
  | { tag: 'Attempted'; value: { registered?: bigint | undefined; id: []; amount: bigint } };

/**
 * The `Error` enum of this pallet.
 **/
export type PalletSalaryError =
  /**
   * The salary system has already been started.
   **/
  | 'AlreadyStarted'
  /**
   * The account is not a ranked member.
   **/
  | 'NotMember'
  /**
   * The account is already inducted.
   **/
  | 'AlreadyInducted'
  | 'NotInducted'
  /**
   * The member does not have a current valid claim.
   **/
  | 'NoClaim'
  /**
   * The member's claim is zero.
   **/
  | 'ClaimZero'
  /**
   * Current cycle's registration period is over.
   **/
  | 'TooLate'
  /**
   * Current cycle's payment period is not yet begun.
   **/
  | 'TooEarly'
  /**
   * Cycle is not yet over.
   **/
  | 'NotYet'
  /**
   * The payout cycles have not yet started.
   **/
  | 'NotStarted'
  /**
   * There is no budget left for the payout.
   **/
  | 'Bankrupt'
  /**
   * There was some issue with the mechanism of payment.
   **/
  | 'PayError'
  /**
   * The payment has neither failed nor succeeded yet.
   **/
  | 'Inconclusive'
  /**
   * The cycle is after that in which the payment was made.
   **/
  | 'NotCurrent';

export type PalletCoreFellowshipMemberStatus = { isActive: boolean; lastPromotion: number; lastProof: number };

/**
 * The `Error` enum of this pallet.
 **/
export type PalletCoreFellowshipError =
  /**
   * Member's rank is too low.
   **/
  | 'Unranked'
  /**
   * Member's rank is not zero.
   **/
  | 'Ranked'
  /**
   * Member's rank is not as expected - generally means that the rank provided to the call
   * does not agree with the state of the system.
   **/
  | 'UnexpectedRank'
  /**
   * The given rank is invalid - this generally means it's not between 1 and `RANK_COUNT`.
   **/
  | 'InvalidRank'
  /**
   * The origin does not have enough permission to do this operation.
   **/
  | 'NoPermission'
  /**
   * No work needs to be done at present for this member.
   **/
  | 'NothingDoing'
  /**
   * The candidate has already been inducted. This should never happen since it would
   * require a candidate (rank 0) to already be tracked in the pallet.
   **/
  | 'AlreadyInducted'
  /**
   * The candidate has not been inducted, so cannot be offboarded from this pallet.
   **/
  | 'NotTracked'
  /**
   * Operation cannot be done yet since not enough time has passed.
   **/
  | 'TooSoon';

export type PalletTransactionStorageTransactionInfo = {
  chunkRoot: H256;
  contentHash: H256;
  size: number;
  blockChunks: number;
};

/**
 * The `Error` enum of this pallet.
 **/
export type PalletTransactionStorageError =
  /**
   * Insufficient account balance.
   **/
  | 'InsufficientFunds'
  /**
   * Invalid configuration.
   **/
  | 'NotConfigured'
  /**
   * Renewed extrinsic is not found.
   **/
  | 'RenewedNotFound'
  /**
   * Attempting to store empty transaction
   **/
  | 'EmptyTransaction'
  /**
   * Proof was not expected in this block.
   **/
  | 'UnexpectedProof'
  /**
   * Proof failed verification.
   **/
  | 'InvalidProof'
  /**
   * Missing storage proof.
   **/
  | 'MissingProof'
  /**
   * Unable to verify proof becasue state data is missing.
   **/
  | 'MissingStateData'
  /**
   * Double proof check in the block.
   **/
  | 'DoubleCheck'
  /**
   * Storage proof was not checked in the block.
   **/
  | 'ProofNotChecked'
  /**
   * Transaction is too large.
   **/
  | 'TransactionTooLarge'
  /**
   * Too many transactions in the block.
   **/
  | 'TooManyTransactions'
  /**
   * Attempted to call `store` outside of block execution.
   **/
  | 'BadContext';

export type PalletBagsListListNode = {
  id: AccountId32Like;
  prev?: AccountId32Like | undefined;
  next?: AccountId32Like | undefined;
  bagUpper: bigint;
  score: bigint;
};

export type PalletBagsListListBag = { head?: AccountId32Like | undefined; tail?: AccountId32Like | undefined };

/**
 * The `Error` enum of this pallet.
 **/
export type PalletBagsListError = { tag: 'List'; value: PalletBagsListListListError };

export type PalletBagsListListListError = 'Duplicate' | 'NotHeavier' | 'NotInSameBag' | 'NodeNotFound';

export type PalletChildBountiesChildBounty = {
  parentBounty: number;
  value: bigint;
  fee: bigint;
  curatorDeposit: bigint;
  status: PalletChildBountiesChildBountyStatus;
};

export type PalletChildBountiesChildBountyStatus =
  | { tag: 'Added' }
  | { tag: 'CuratorProposed'; value: { curator: AccountId32Like } }
  | { tag: 'Active'; value: { curator: AccountId32Like } }
  | { tag: 'PendingPayout'; value: { curator: AccountId32Like; beneficiary: AccountId32Like; unlockAt: number } };

/**
 * The `Error` enum of this pallet.
 **/
export type PalletChildBountiesError =
  /**
   * The parent bounty is not in active state.
   **/
  | 'ParentBountyNotActive'
  /**
   * The bounty balance is not enough to add new child-bounty.
   **/
  | 'InsufficientBountyBalance'
  /**
   * Number of child bounties exceeds limit `MaxActiveChildBountyCount`.
   **/
  | 'TooManyChildBounties';

export type PalletReferendaReferendumInfo =
  | { tag: 'Ongoing'; value: PalletReferendaReferendumStatus }
  | { tag: 'Approved'; value: [number, PalletReferendaDeposit | undefined, PalletReferendaDeposit | undefined] }
  | { tag: 'Rejected'; value: [number, PalletReferendaDeposit | undefined, PalletReferendaDeposit | undefined] }
  | { tag: 'Cancelled'; value: [number, PalletReferendaDeposit | undefined, PalletReferendaDeposit | undefined] }
  | { tag: 'TimedOut'; value: [number, PalletReferendaDeposit | undefined, PalletReferendaDeposit | undefined] }
  | { tag: 'Killed'; value: number };

export type PalletReferendaReferendumStatus = {
  track: number;
  origin: KitchensinkRuntimeOriginCaller;
  proposal: FrameSupportPreimagesBounded;
  enactment: FrameSupportScheduleDispatchTime;
  submitted: number;
  submissionDeposit: PalletReferendaDeposit;
  decisionDeposit?: PalletReferendaDeposit | undefined;
  deciding?: PalletReferendaDecidingStatus | undefined;
  tally: PalletConvictionVotingTally;
  inQueue: boolean;
  alarm?: [number, [number, number]] | undefined;
};

export type PalletReferendaDeposit = { who: AccountId32Like; amount: bigint };

export type PalletReferendaDecidingStatus = { since: number; confirming?: number | undefined };

export type PalletReferendaTrackInfo = {
  name: string;
  maxDeciding: number;
  decisionDeposit: bigint;
  preparePeriod: number;
  decisionPeriod: number;
  confirmPeriod: number;
  minEnactmentPeriod: number;
  minApproval: PalletReferendaCurve;
  minSupport: PalletReferendaCurve;
};

export type PalletReferendaCurve =
  | { tag: 'LinearDecreasing'; value: { length: Perbill; floor: Perbill; ceil: Perbill } }
  | { tag: 'SteppedDecreasing'; value: { begin: Perbill; end: Perbill; step: Perbill; period: Perbill } }
  | { tag: 'Reciprocal'; value: { factor: FixedI64; xOffset: FixedI64; yOffset: FixedI64 } };

/**
 * The `Error` enum of this pallet.
 **/
export type PalletReferendaError =
  /**
   * Referendum is not ongoing.
   **/
  | 'NotOngoing'
  /**
   * Referendum's decision deposit is already paid.
   **/
  | 'HasDeposit'
  /**
   * The track identifier given was invalid.
   **/
  | 'BadTrack'
  /**
   * There are already a full complement of referenda in progress for this track.
   **/
  | 'Full'
  /**
   * The queue of the track is empty.
   **/
  | 'QueueEmpty'
  /**
   * The referendum index provided is invalid in this context.
   **/
  | 'BadReferendum'
  /**
   * There was nothing to do in the advancement.
   **/
  | 'NothingToDo'
  /**
   * No track exists for the proposal origin.
   **/
  | 'NoTrack'
  /**
   * Any deposit cannot be refunded until after the decision is over.
   **/
  | 'Unfinished'
  /**
   * The deposit refunder is not the depositor.
   **/
  | 'NoPermission'
  /**
   * The deposit cannot be refunded since none was made.
   **/
  | 'NoDeposit'
  /**
   * The referendum status is invalid for this operation.
   **/
  | 'BadStatus'
  /**
   * The preimage does not exist.
   **/
  | 'PreimageNotExist';

/**
 * The `Error` enum of this pallet.
 **/
export type PalletRemarkError =
  /**
   * Attempting to store empty data.
   **/
  | 'Empty'
  /**
   * Attempted to call `store` outside of block execution.
   **/
  | 'BadContext';

export type PalletConvictionVotingVoteVoting =
  | { tag: 'Casting'; value: PalletConvictionVotingVoteCasting }
  | { tag: 'Delegating'; value: PalletConvictionVotingVoteDelegating };

export type PalletConvictionVotingVoteCasting = {
  votes: Array<[number, PalletConvictionVotingVoteAccountVote]>;
  delegations: PalletConvictionVotingDelegations;
  prior: PalletConvictionVotingVotePriorLock;
};

export type PalletConvictionVotingDelegations = { votes: bigint; capital: bigint };

export type PalletConvictionVotingVotePriorLock = [number, bigint];

export type PalletConvictionVotingVoteDelegating = {
  balance: bigint;
  target: AccountId32Like;
  conviction: PalletConvictionVotingConviction;
  delegations: PalletConvictionVotingDelegations;
  prior: PalletConvictionVotingVotePriorLock;
};

/**
 * The `Error` enum of this pallet.
 **/
export type PalletConvictionVotingError =
  /**
   * Poll is not ongoing.
   **/
  | 'NotOngoing'
  /**
   * The given account did not vote on the poll.
   **/
  | 'NotVoter'
  /**
   * The actor has no permission to conduct the action.
   **/
  | 'NoPermission'
  /**
   * The actor has no permission to conduct the action right now but will do in the future.
   **/
  | 'NoPermissionYet'
  /**
   * The account is already delegating.
   **/
  | 'AlreadyDelegating'
  /**
   * The account currently has votes attached to it and the operation cannot succeed until
   * these are removed, either through `unvote` or `reap_vote`.
   **/
  | 'AlreadyVoting'
  /**
   * Too high a balance was provided that the account cannot afford.
   **/
  | 'InsufficientFunds'
  /**
   * The account is not currently delegating.
   **/
  | 'NotDelegating'
  /**
   * Delegation to oneself makes no sense.
   **/
  | 'Nonsense'
  /**
   * Maximum number of votes reached.
   **/
  | 'MaxVotesReached'
  /**
   * The class must be supplied since it is not easily determinable from the state.
   **/
  | 'ClassNeeded'
  /**
   * The class ID supplied is invalid.
   **/
  | 'BadClass';

/**
 * The `Error` enum of this pallet.
 **/
export type PalletWhitelistError =
  /**
   * The preimage of the call hash could not be loaded.
   **/
  | 'UnavailablePreImage'
  /**
   * The call could not be decoded.
   **/
  | 'UndecodableCall'
  /**
   * The weight of the decoded call was higher than the witness.
   **/
  | 'InvalidCallWeightWitness'
  /**
   * The call was not whitelisted.
   **/
  | 'CallIsNotWhitelisted'
  /**
   * The call was already whitelisted; No-Op.
   **/
  | 'CallAlreadyWhitelisted';

export type PalletAllianceMemberRole = 'Fellow' | 'Ally' | 'Retiring';

/**
 * The `Error` enum of this pallet.
 **/
export type PalletAllianceError =
  /**
   * The Alliance has not been initialized yet, therefore accounts cannot join it.
   **/
  | 'AllianceNotYetInitialized'
  /**
   * The Alliance has been initialized, therefore cannot be initialized again.
   **/
  | 'AllianceAlreadyInitialized'
  /**
   * Account is already a member.
   **/
  | 'AlreadyMember'
  /**
   * Account is not a member.
   **/
  | 'NotMember'
  /**
   * Account is not an ally.
   **/
  | 'NotAlly'
  /**
   * Account does not have voting rights.
   **/
  | 'NoVotingRights'
  /**
   * Account is already an elevated (fellow) member.
   **/
  | 'AlreadyElevated'
  /**
   * Item is already listed as unscrupulous.
   **/
  | 'AlreadyUnscrupulous'
  /**
   * Account has been deemed unscrupulous by the Alliance and is not welcome to join or be
   * nominated.
   **/
  | 'AccountNonGrata'
  /**
   * Item has not been deemed unscrupulous.
   **/
  | 'NotListedAsUnscrupulous'
  /**
   * The number of unscrupulous items exceeds `MaxUnscrupulousItems`.
   **/
  | 'TooManyUnscrupulousItems'
  /**
   * Length of website URL exceeds `MaxWebsiteUrlLength`.
   **/
  | 'TooLongWebsiteUrl'
  /**
   * Balance is insufficient for the required deposit.
   **/
  | 'InsufficientFunds'
  /**
   * The account's identity does not have display field and website field.
   **/
  | 'WithoutIdentityDisplayAndWebsite'
  /**
   * The account's identity has no good judgement.
   **/
  | 'WithoutGoodIdentityJudgement'
  /**
   * The proposal hash is not found.
   **/
  | 'MissingProposalHash'
  /**
   * The announcement is not found.
   **/
  | 'MissingAnnouncement'
  /**
   * Number of members exceeds `MaxMembersCount`.
   **/
  | 'TooManyMembers'
  /**
   * Number of announcements exceeds `MaxAnnouncementsCount`.
   **/
  | 'TooManyAnnouncements'
  /**
   * Invalid witness data given.
   **/
  | 'BadWitness'
  /**
   * Account already gave retirement notice
   **/
  | 'AlreadyRetiring'
  /**
   * Account did not give a retirement notice required to retire.
   **/
  | 'RetirementNoticeNotGiven'
  /**
   * Retirement period has not passed.
   **/
  | 'RetirementPeriodNotPassed'
  /**
   * Fellows must be provided to initialize the Alliance.
   **/
  | 'FellowsMissing';

export type PalletNominationPoolsPoolMember = {
  poolId: number;
  points: bigint;
  lastRecordedRewardCounter: FixedU128;
  unbondingEras: Array<[number, bigint]>;
};

export type PalletNominationPoolsBondedPoolInner = {
  commission: PalletNominationPoolsCommission;
  memberCounter: number;
  points: bigint;
  roles: PalletNominationPoolsPoolRoles;
  state: PalletNominationPoolsPoolState;
};

export type PalletNominationPoolsCommission = {
  current?: [Perbill, AccountId32Like] | undefined;
  max?: Perbill | undefined;
  changeRate?: PalletNominationPoolsCommissionChangeRate | undefined;
  throttleFrom?: number | undefined;
};

export type PalletNominationPoolsPoolRoles = {
  depositor: AccountId32Like;
  root?: AccountId32Like | undefined;
  nominator?: AccountId32Like | undefined;
  bouncer?: AccountId32Like | undefined;
};

export type PalletNominationPoolsRewardPool = {
  lastRecordedRewardCounter: FixedU128;
  lastRecordedTotalPayouts: bigint;
  totalRewardsClaimed: bigint;
  totalCommissionPending: bigint;
  totalCommissionClaimed: bigint;
};

export type PalletNominationPoolsSubPools = {
  noEra: PalletNominationPoolsUnbondPool;
  withEra: Array<[number, PalletNominationPoolsUnbondPool]>;
};

export type PalletNominationPoolsUnbondPool = { points: bigint; balance: bigint };

/**
 * The `Error` enum of this pallet.
 **/
export type PalletNominationPoolsError =
  | { tag: 'PoolNotFound' }
  | { tag: 'PoolMemberNotFound' }
  | { tag: 'RewardPoolNotFound' }
  | { tag: 'SubPoolsNotFound' }
  | { tag: 'AccountBelongsToOtherPool' }
  | { tag: 'FullyUnbonding' }
  | { tag: 'MaxUnbondingLimit' }
  | { tag: 'CannotWithdrawAny' }
  | { tag: 'MinimumBondNotMet' }
  | { tag: 'OverflowRisk' }
  | { tag: 'NotDestroying' }
  | { tag: 'NotNominator' }
  | { tag: 'NotKickerOrDestroying' }
  | { tag: 'NotOpen' }
  | { tag: 'MaxPools' }
  | { tag: 'MaxPoolMembers' }
  | { tag: 'CanNotChangeState' }
  | { tag: 'DoesNotHavePermission' }
  | { tag: 'MetadataExceedsMaxLen' }
  | { tag: 'Defensive'; value: PalletNominationPoolsDefensiveError }
  | { tag: 'PartialUnbondNotAllowedPermissionlessly' }
  | { tag: 'MaxCommissionRestricted' }
  | { tag: 'CommissionExceedsMaximum' }
  | { tag: 'CommissionExceedsGlobalMaximum' }
  | { tag: 'CommissionChangeThrottled' }
  | { tag: 'CommissionChangeRateNotAllowed' }
  | { tag: 'NoPendingCommission' }
  | { tag: 'NoCommissionCurrentSet' }
  | { tag: 'PoolIdInUse' }
  | { tag: 'InvalidPoolId' }
  | { tag: 'BondExtraRestricted' };

export type PalletNominationPoolsDefensiveError =
  | 'NotEnoughSpaceInUnbondPool'
  | 'PoolNotFound'
  | 'RewardPoolNotFound'
  | 'SubPoolsNotFound'
  | 'BondedStashKilledPrematurely';

export type PalletReferendaReferendumInfoTally =
  | { tag: 'Ongoing'; value: PalletReferendaReferendumStatusTally }
  | { tag: 'Approved'; value: [number, PalletReferendaDeposit | undefined, PalletReferendaDeposit | undefined] }
  | { tag: 'Rejected'; value: [number, PalletReferendaDeposit | undefined, PalletReferendaDeposit | undefined] }
  | { tag: 'Cancelled'; value: [number, PalletReferendaDeposit | undefined, PalletReferendaDeposit | undefined] }
  | { tag: 'TimedOut'; value: [number, PalletReferendaDeposit | undefined, PalletReferendaDeposit | undefined] }
  | { tag: 'Killed'; value: number };

export type PalletReferendaReferendumStatusTally = {
  track: number;
  origin: KitchensinkRuntimeOriginCaller;
  proposal: FrameSupportPreimagesBounded;
  enactment: FrameSupportScheduleDispatchTime;
  submitted: number;
  submissionDeposit: PalletReferendaDeposit;
  decisionDeposit?: PalletReferendaDeposit | undefined;
  deciding?: PalletReferendaDecidingStatus | undefined;
  tally: PalletRankedCollectiveTally;
  inQueue: boolean;
  alarm?: [number, [number, number]] | undefined;
};

export type PalletRankedCollectiveMemberRecord = { rank: number };

/**
 * The `Error` enum of this pallet.
 **/
export type PalletRankedCollectiveError =
  /**
   * Account is already a member.
   **/
  | 'AlreadyMember'
  /**
   * Account is not a member.
   **/
  | 'NotMember'
  /**
   * The given poll index is unknown or has closed.
   **/
  | 'NotPolling'
  /**
   * The given poll is still ongoing.
   **/
  | 'Ongoing'
  /**
   * There are no further records to be removed.
   **/
  | 'NoneRemaining'
  /**
   * Unexpected error in state.
   **/
  | 'Corruption'
  /**
   * The member's rank is too low to vote.
   **/
  | 'RankTooLow'
  /**
   * The information provided is incorrect.
   **/
  | 'InvalidWitness'
  /**
   * The origin is not sufficiently privileged to do the operation.
   **/
  | 'NoPermission';

export type PalletAssetConversionPoolInfo = { lpToken: number };

/**
 * The `Error` enum of this pallet.
 **/
export type PalletAssetConversionError =
  /**
   * Provided assets are equal.
   **/
  | 'EqualAssets'
  /**
   * Provided asset is not supported for pool.
   **/
  | 'UnsupportedAsset'
  /**
   * Pool already exists.
   **/
  | 'PoolExists'
  /**
   * Desired amount can't be zero.
   **/
  | 'WrongDesiredAmount'
  /**
   * Provided amount should be greater than or equal to the existential deposit/asset's
   * minimal amount.
   **/
  | 'AmountOneLessThanMinimal'
  /**
   * Provided amount should be greater than or equal to the existential deposit/asset's
   * minimal amount.
   **/
  | 'AmountTwoLessThanMinimal'
  /**
   * Reserve needs to always be greater than or equal to the existential deposit/asset's
   * minimal amount.
   **/
  | 'ReserveLeftLessThanMinimal'
  /**
   * Desired amount can't be equal to the pool reserve.
   **/
  | 'AmountOutTooHigh'
  /**
   * The pool doesn't exist.
   **/
  | 'PoolNotFound'
  /**
   * An overflow happened.
   **/
  | 'Overflow'
  /**
   * The minimal amount requirement for the first token in the pair wasn't met.
   **/
  | 'AssetOneDepositDidNotMeetMinimum'
  /**
   * The minimal amount requirement for the second token in the pair wasn't met.
   **/
  | 'AssetTwoDepositDidNotMeetMinimum'
  /**
   * The minimal amount requirement for the first token in the pair wasn't met.
   **/
  | 'AssetOneWithdrawalDidNotMeetMinimum'
  /**
   * The minimal amount requirement for the second token in the pair wasn't met.
   **/
  | 'AssetTwoWithdrawalDidNotMeetMinimum'
  /**
   * Optimal calculated amount is less than desired.
   **/
  | 'OptimalAmountLessThanDesired'
  /**
   * Insufficient liquidity minted.
   **/
  | 'InsufficientLiquidityMinted'
  /**
   * Requested liquidity can't be zero.
   **/
  | 'ZeroLiquidity'
  /**
   * Amount can't be zero.
   **/
  | 'ZeroAmount'
  /**
   * Insufficient liquidity in the pool.
   **/
  | 'InsufficientLiquidity'
  /**
   * Calculated amount out is less than provided minimum amount.
   **/
  | 'ProvidedMinimumNotSufficientForSwap'
  /**
   * Provided maximum amount is not sufficient for swap.
   **/
  | 'ProvidedMaximumNotSufficientForSwap'
  /**
   * Only pools with native on one side are valid.
   **/
  | 'PoolMustContainNativeCurrency'
  /**
   * The provided path must consists of 2 assets at least.
   **/
  | 'InvalidPath'
  /**
   * It was not possible to calculate path data.
   **/
  | 'PathError'
  /**
   * The provided path must consists of unique assets.
   **/
  | 'NonUniquePath'
  /**
   * It was not possible to get or increment the Id of the pool.
   **/
  | 'IncorrectPoolAssetId'
  /**
   * Unable to find an element in an array/vec that should have one-to-one correspondence
   * with another. For example, an array of assets constituting a `path` should have a
   * corresponding array of `amounts` along the path.
   **/
  | 'CorrespondenceError';

export type PalletFastUnstakeUnstakeRequest = { stashes: Array<[AccountId32Like, bigint]>; checked: Array<number> };

/**
 * The `Error` enum of this pallet.
 **/
export type PalletFastUnstakeError =
  /**
   * The provided Controller account was not found.
   *
   * This means that the given account is not bonded.
   **/
  | 'NotController'
  /**
   * The bonded account has already been queued.
   **/
  | 'AlreadyQueued'
  /**
   * The bonded account has active unlocking chunks.
   **/
  | 'NotFullyBonded'
  /**
   * The provided un-staker is not in the `Queue`.
   **/
  | 'NotQueued'
  /**
   * The provided un-staker is already in Head, and cannot deregister.
   **/
  | 'AlreadyHead'
  /**
   * The call is not allowed at this point because the pallet is not active.
   **/
  | 'CallNotAllowed';

export type PalletMessageQueueBookState = {
  begin: number;
  end: number;
  count: number;
  readyNeighbours?: PalletMessageQueueNeighbours | undefined;
  messageCount: bigint;
  size: bigint;
};

export type PalletMessageQueueNeighbours = { prev: number; next: number };

export type PalletMessageQueuePage = {
  remaining: number;
  remainingSize: number;
  firstIndex: number;
  first: number;
  last: number;
  heap: Bytes;
};

/**
 * The `Error` enum of this pallet.
 **/
export type PalletMessageQueueError =
  /**
   * Page is not reapable because it has items remaining to be processed and is not old
   * enough.
   **/
  | 'NotReapable'
  /**
   * Page to be reaped does not exist.
   **/
  | 'NoPage'
  /**
   * The referenced message could not be found.
   **/
  | 'NoMessage'
  /**
   * The message was already processed and cannot be processed again.
   **/
  | 'AlreadyProcessed'
  /**
   * The message is queued for future execution.
   **/
  | 'Queued'
  /**
   * There is temporarily not enough weight to continue servicing messages.
   **/
  | 'InsufficientWeight'
  /**
   * This message is temporarily unprocessable.
   *
   * Such errors are expected, but not guaranteed, to resolve themselves eventually through
   * retrying.
   **/
  | 'TemporarilyUnprocessable'
  /**
   * The queue is paused and no message can be executed from it.
   *
   * This can change at any time and may resolve in the future by re-trying.
   **/
  | 'QueuePaused';

/**
 * The `Error` enum of this pallet.
 **/
export type PalletTxPauseError =
  /**
   * The call is paused.
   **/
  | 'IsPaused'
  /**
   * The call is unpaused.
   **/
  | 'IsUnpaused'
  /**
   * The call is whitelisted and cannot be paused.
   **/
  | 'Unpausable'
  | 'NotFound';

/**
 * The `Error` enum of this pallet.
 **/
export type PalletSafeModeError =
  /**
   * The safe-mode is (already or still) entered.
   **/
  | 'Entered'
  /**
   * The safe-mode is (already or still) exited.
   **/
  | 'Exited'
  /**
   * This functionality of the pallet is disabled by the configuration.
   **/
  | 'NotConfigured'
  /**
   * There is no balance reserved.
   **/
  | 'NoDeposit'
  /**
   * The account already has a deposit reserved and can therefore not enter or extend again.
   **/
  | 'AlreadyDeposited'
  /**
   * This deposit cannot be released yet.
   **/
  | 'CannotReleaseYet'
  /**
   * An error from the underlying `Currency`.
   **/
  | 'CurrencyError';

export type PalletBrokerLeaseRecordItem = { until: number; task: number };

export type PalletBrokerStatusRecord = {
  coreCount: number;
  privatePoolSize: number;
  systemPoolSize: number;
  lastCommittedTimeslice: number;
  lastTimeslice: number;
};

export type PalletBrokerSaleInfoRecord = {
  saleStart: number;
  leadinLength: number;
  price: bigint;
  regionBegin: number;
  regionEnd: number;
  idealCoresSold: number;
  coresOffered: number;
  firstCore: number;
  selloutPrice?: bigint | undefined;
  coresSold: number;
};

export type PalletBrokerAllowedRenewalId = { core: number; when: number };

export type PalletBrokerAllowedRenewalRecord = { price: bigint; completion: PalletBrokerCompletionStatus };

export type PalletBrokerCompletionStatus =
  | { tag: 'Partial'; value: PalletBrokerCoreMask }
  | { tag: 'Complete'; value: Array<PalletBrokerScheduleItem> };

export type PalletBrokerRegionRecord = { end: number; owner: AccountId32Like; paid?: bigint | undefined };

export type PalletBrokerContributionRecord = { length: number; payee: AccountId32Like };

export type PalletBrokerPoolIoRecord = { private: number; system: number };

export type PalletBrokerInstaPoolHistoryRecord = {
  privateContributions: number;
  systemContributions: number;
  maybePayout?: bigint | undefined;
};

/**
 * The `Error` enum of this pallet.
 **/
export type PalletBrokerError =
  /**
   * The given region identity is not known.
   **/
  | 'UnknownRegion'
  /**
   * The owner of the region is not the origin.
   **/
  | 'NotOwner'
  /**
   * The pivot point of the partition at or after the end of the region.
   **/
  | 'PivotTooLate'
  /**
   * The pivot point of the partition at the beginning of the region.
   **/
  | 'PivotTooEarly'
  /**
   * The pivot mask for the interlacing is not contained within the region's interlace mask.
   **/
  | 'ExteriorPivot'
  /**
   * The pivot mask for the interlacing is void (and therefore unschedulable).
   **/
  | 'VoidPivot'
  /**
   * The pivot mask for the interlacing is complete (and therefore not a strict subset).
   **/
  | 'CompletePivot'
  /**
   * The workplan of the pallet's state is invalid. This indicates a state corruption.
   **/
  | 'CorruptWorkplan'
  /**
   * There is no sale happening currently.
   **/
  | 'NoSales'
  /**
   * The price limit is exceeded.
   **/
  | 'Overpriced'
  /**
   * There are no cores available.
   **/
  | 'Unavailable'
  /**
   * The sale limit has been reached.
   **/
  | 'SoldOut'
  /**
   * The renewal operation is not valid at the current time (it may become valid in the next
   * sale).
   **/
  | 'WrongTime'
  /**
   * Invalid attempt to renew.
   **/
  | 'NotAllowed'
  /**
   * This pallet has not yet been initialized.
   **/
  | 'Uninitialized'
  /**
   * The purchase cannot happen yet as the sale period is yet to begin.
   **/
  | 'TooEarly'
  /**
   * There is no work to be done.
   **/
  | 'NothingToDo'
  /**
   * The maximum amount of reservations has already been reached.
   **/
  | 'TooManyReservations'
  /**
   * The maximum amount of leases has already been reached.
   **/
  | 'TooManyLeases'
  /**
   * The revenue for the Instantaneous Core Sales of this period is not (yet) known and thus
   * this operation cannot proceed.
   **/
  | 'UnknownRevenue'
  /**
   * The identified contribution to the Instantaneous Core Pool is unknown.
   **/
  | 'UnknownContribution'
  /**
   * The workload assigned for renewal is incomplete. This is unexpected and indicates a
   * logic error.
   **/
  | 'IncompleteAssignment'
  /**
   * An item cannot be dropped because it is still valid.
   **/
  | 'StillValid'
  /**
   * The history item does not exist.
   **/
  | 'NoHistory'
  /**
   * No reservation of the given index exists.
   **/
  | 'UnknownReservation'
  /**
   * The renewal record cannot be found.
   **/
  | 'UnknownRenewal'
  /**
   * The lease expiry time has already passed.
   **/
  | 'AlreadyExpired'
  /**
   * The configuration could not be applied because it is invalid.
   **/
  | 'InvalidConfig';

export type SpRuntimeUncheckedExtrinsic = Bytes;

export type FrameSystemExtensionsCheckNonZeroSender = {};

export type FrameSystemExtensionsCheckSpecVersion = {};

export type FrameSystemExtensionsCheckTxVersion = {};

export type FrameSystemExtensionsCheckGenesis = {};

export type FrameSystemExtensionsCheckMortality = SpRuntimeEra;

export type SpRuntimeEra =
  | { tag: 'Immortal' }
  | { tag: 'Mortal1'; value: number }
  | { tag: 'Mortal2'; value: number }
  | { tag: 'Mortal3'; value: number }
  | { tag: 'Mortal4'; value: number }
  | { tag: 'Mortal5'; value: number }
  | { tag: 'Mortal6'; value: number }
  | { tag: 'Mortal7'; value: number }
  | { tag: 'Mortal8'; value: number }
  | { tag: 'Mortal9'; value: number }
  | { tag: 'Mortal10'; value: number }
  | { tag: 'Mortal11'; value: number }
  | { tag: 'Mortal12'; value: number }
  | { tag: 'Mortal13'; value: number }
  | { tag: 'Mortal14'; value: number }
  | { tag: 'Mortal15'; value: number }
  | { tag: 'Mortal16'; value: number }
  | { tag: 'Mortal17'; value: number }
  | { tag: 'Mortal18'; value: number }
  | { tag: 'Mortal19'; value: number }
  | { tag: 'Mortal20'; value: number }
  | { tag: 'Mortal21'; value: number }
  | { tag: 'Mortal22'; value: number }
  | { tag: 'Mortal23'; value: number }
  | { tag: 'Mortal24'; value: number }
  | { tag: 'Mortal25'; value: number }
  | { tag: 'Mortal26'; value: number }
  | { tag: 'Mortal27'; value: number }
  | { tag: 'Mortal28'; value: number }
  | { tag: 'Mortal29'; value: number }
  | { tag: 'Mortal30'; value: number }
  | { tag: 'Mortal31'; value: number }
  | { tag: 'Mortal32'; value: number }
  | { tag: 'Mortal33'; value: number }
  | { tag: 'Mortal34'; value: number }
  | { tag: 'Mortal35'; value: number }
  | { tag: 'Mortal36'; value: number }
  | { tag: 'Mortal37'; value: number }
  | { tag: 'Mortal38'; value: number }
  | { tag: 'Mortal39'; value: number }
  | { tag: 'Mortal40'; value: number }
  | { tag: 'Mortal41'; value: number }
  | { tag: 'Mortal42'; value: number }
  | { tag: 'Mortal43'; value: number }
  | { tag: 'Mortal44'; value: number }
  | { tag: 'Mortal45'; value: number }
  | { tag: 'Mortal46'; value: number }
  | { tag: 'Mortal47'; value: number }
  | { tag: 'Mortal48'; value: number }
  | { tag: 'Mortal49'; value: number }
  | { tag: 'Mortal50'; value: number }
  | { tag: 'Mortal51'; value: number }
  | { tag: 'Mortal52'; value: number }
  | { tag: 'Mortal53'; value: number }
  | { tag: 'Mortal54'; value: number }
  | { tag: 'Mortal55'; value: number }
  | { tag: 'Mortal56'; value: number }
  | { tag: 'Mortal57'; value: number }
  | { tag: 'Mortal58'; value: number }
  | { tag: 'Mortal59'; value: number }
  | { tag: 'Mortal60'; value: number }
  | { tag: 'Mortal61'; value: number }
  | { tag: 'Mortal62'; value: number }
  | { tag: 'Mortal63'; value: number }
  | { tag: 'Mortal64'; value: number }
  | { tag: 'Mortal65'; value: number }
  | { tag: 'Mortal66'; value: number }
  | { tag: 'Mortal67'; value: number }
  | { tag: 'Mortal68'; value: number }
  | { tag: 'Mortal69'; value: number }
  | { tag: 'Mortal70'; value: number }
  | { tag: 'Mortal71'; value: number }
  | { tag: 'Mortal72'; value: number }
  | { tag: 'Mortal73'; value: number }
  | { tag: 'Mortal74'; value: number }
  | { tag: 'Mortal75'; value: number }
  | { tag: 'Mortal76'; value: number }
  | { tag: 'Mortal77'; value: number }
  | { tag: 'Mortal78'; value: number }
  | { tag: 'Mortal79'; value: number }
  | { tag: 'Mortal80'; value: number }
  | { tag: 'Mortal81'; value: number }
  | { tag: 'Mortal82'; value: number }
  | { tag: 'Mortal83'; value: number }
  | { tag: 'Mortal84'; value: number }
  | { tag: 'Mortal85'; value: number }
  | { tag: 'Mortal86'; value: number }
  | { tag: 'Mortal87'; value: number }
  | { tag: 'Mortal88'; value: number }
  | { tag: 'Mortal89'; value: number }
  | { tag: 'Mortal90'; value: number }
  | { tag: 'Mortal91'; value: number }
  | { tag: 'Mortal92'; value: number }
  | { tag: 'Mortal93'; value: number }
  | { tag: 'Mortal94'; value: number }
  | { tag: 'Mortal95'; value: number }
  | { tag: 'Mortal96'; value: number }
  | { tag: 'Mortal97'; value: number }
  | { tag: 'Mortal98'; value: number }
  | { tag: 'Mortal99'; value: number }
  | { tag: 'Mortal100'; value: number }
  | { tag: 'Mortal101'; value: number }
  | { tag: 'Mortal102'; value: number }
  | { tag: 'Mortal103'; value: number }
  | { tag: 'Mortal104'; value: number }
  | { tag: 'Mortal105'; value: number }
  | { tag: 'Mortal106'; value: number }
  | { tag: 'Mortal107'; value: number }
  | { tag: 'Mortal108'; value: number }
  | { tag: 'Mortal109'; value: number }
  | { tag: 'Mortal110'; value: number }
  | { tag: 'Mortal111'; value: number }
  | { tag: 'Mortal112'; value: number }
  | { tag: 'Mortal113'; value: number }
  | { tag: 'Mortal114'; value: number }
  | { tag: 'Mortal115'; value: number }
  | { tag: 'Mortal116'; value: number }
  | { tag: 'Mortal117'; value: number }
  | { tag: 'Mortal118'; value: number }
  | { tag: 'Mortal119'; value: number }
  | { tag: 'Mortal120'; value: number }
  | { tag: 'Mortal121'; value: number }
  | { tag: 'Mortal122'; value: number }
  | { tag: 'Mortal123'; value: number }
  | { tag: 'Mortal124'; value: number }
  | { tag: 'Mortal125'; value: number }
  | { tag: 'Mortal126'; value: number }
  | { tag: 'Mortal127'; value: number }
  | { tag: 'Mortal128'; value: number }
  | { tag: 'Mortal129'; value: number }
  | { tag: 'Mortal130'; value: number }
  | { tag: 'Mortal131'; value: number }
  | { tag: 'Mortal132'; value: number }
  | { tag: 'Mortal133'; value: number }
  | { tag: 'Mortal134'; value: number }
  | { tag: 'Mortal135'; value: number }
  | { tag: 'Mortal136'; value: number }
  | { tag: 'Mortal137'; value: number }
  | { tag: 'Mortal138'; value: number }
  | { tag: 'Mortal139'; value: number }
  | { tag: 'Mortal140'; value: number }
  | { tag: 'Mortal141'; value: number }
  | { tag: 'Mortal142'; value: number }
  | { tag: 'Mortal143'; value: number }
  | { tag: 'Mortal144'; value: number }
  | { tag: 'Mortal145'; value: number }
  | { tag: 'Mortal146'; value: number }
  | { tag: 'Mortal147'; value: number }
  | { tag: 'Mortal148'; value: number }
  | { tag: 'Mortal149'; value: number }
  | { tag: 'Mortal150'; value: number }
  | { tag: 'Mortal151'; value: number }
  | { tag: 'Mortal152'; value: number }
  | { tag: 'Mortal153'; value: number }
  | { tag: 'Mortal154'; value: number }
  | { tag: 'Mortal155'; value: number }
  | { tag: 'Mortal156'; value: number }
  | { tag: 'Mortal157'; value: number }
  | { tag: 'Mortal158'; value: number }
  | { tag: 'Mortal159'; value: number }
  | { tag: 'Mortal160'; value: number }
  | { tag: 'Mortal161'; value: number }
  | { tag: 'Mortal162'; value: number }
  | { tag: 'Mortal163'; value: number }
  | { tag: 'Mortal164'; value: number }
  | { tag: 'Mortal165'; value: number }
  | { tag: 'Mortal166'; value: number }
  | { tag: 'Mortal167'; value: number }
  | { tag: 'Mortal168'; value: number }
  | { tag: 'Mortal169'; value: number }
  | { tag: 'Mortal170'; value: number }
  | { tag: 'Mortal171'; value: number }
  | { tag: 'Mortal172'; value: number }
  | { tag: 'Mortal173'; value: number }
  | { tag: 'Mortal174'; value: number }
  | { tag: 'Mortal175'; value: number }
  | { tag: 'Mortal176'; value: number }
  | { tag: 'Mortal177'; value: number }
  | { tag: 'Mortal178'; value: number }
  | { tag: 'Mortal179'; value: number }
  | { tag: 'Mortal180'; value: number }
  | { tag: 'Mortal181'; value: number }
  | { tag: 'Mortal182'; value: number }
  | { tag: 'Mortal183'; value: number }
  | { tag: 'Mortal184'; value: number }
  | { tag: 'Mortal185'; value: number }
  | { tag: 'Mortal186'; value: number }
  | { tag: 'Mortal187'; value: number }
  | { tag: 'Mortal188'; value: number }
  | { tag: 'Mortal189'; value: number }
  | { tag: 'Mortal190'; value: number }
  | { tag: 'Mortal191'; value: number }
  | { tag: 'Mortal192'; value: number }
  | { tag: 'Mortal193'; value: number }
  | { tag: 'Mortal194'; value: number }
  | { tag: 'Mortal195'; value: number }
  | { tag: 'Mortal196'; value: number }
  | { tag: 'Mortal197'; value: number }
  | { tag: 'Mortal198'; value: number }
  | { tag: 'Mortal199'; value: number }
  | { tag: 'Mortal200'; value: number }
  | { tag: 'Mortal201'; value: number }
  | { tag: 'Mortal202'; value: number }
  | { tag: 'Mortal203'; value: number }
  | { tag: 'Mortal204'; value: number }
  | { tag: 'Mortal205'; value: number }
  | { tag: 'Mortal206'; value: number }
  | { tag: 'Mortal207'; value: number }
  | { tag: 'Mortal208'; value: number }
  | { tag: 'Mortal209'; value: number }
  | { tag: 'Mortal210'; value: number }
  | { tag: 'Mortal211'; value: number }
  | { tag: 'Mortal212'; value: number }
  | { tag: 'Mortal213'; value: number }
  | { tag: 'Mortal214'; value: number }
  | { tag: 'Mortal215'; value: number }
  | { tag: 'Mortal216'; value: number }
  | { tag: 'Mortal217'; value: number }
  | { tag: 'Mortal218'; value: number }
  | { tag: 'Mortal219'; value: number }
  | { tag: 'Mortal220'; value: number }
  | { tag: 'Mortal221'; value: number }
  | { tag: 'Mortal222'; value: number }
  | { tag: 'Mortal223'; value: number }
  | { tag: 'Mortal224'; value: number }
  | { tag: 'Mortal225'; value: number }
  | { tag: 'Mortal226'; value: number }
  | { tag: 'Mortal227'; value: number }
  | { tag: 'Mortal228'; value: number }
  | { tag: 'Mortal229'; value: number }
  | { tag: 'Mortal230'; value: number }
  | { tag: 'Mortal231'; value: number }
  | { tag: 'Mortal232'; value: number }
  | { tag: 'Mortal233'; value: number }
  | { tag: 'Mortal234'; value: number }
  | { tag: 'Mortal235'; value: number }
  | { tag: 'Mortal236'; value: number }
  | { tag: 'Mortal237'; value: number }
  | { tag: 'Mortal238'; value: number }
  | { tag: 'Mortal239'; value: number }
  | { tag: 'Mortal240'; value: number }
  | { tag: 'Mortal241'; value: number }
  | { tag: 'Mortal242'; value: number }
  | { tag: 'Mortal243'; value: number }
  | { tag: 'Mortal244'; value: number }
  | { tag: 'Mortal245'; value: number }
  | { tag: 'Mortal246'; value: number }
  | { tag: 'Mortal247'; value: number }
  | { tag: 'Mortal248'; value: number }
  | { tag: 'Mortal249'; value: number }
  | { tag: 'Mortal250'; value: number }
  | { tag: 'Mortal251'; value: number }
  | { tag: 'Mortal252'; value: number }
  | { tag: 'Mortal253'; value: number }
  | { tag: 'Mortal254'; value: number }
  | { tag: 'Mortal255'; value: number };

export type FrameSystemExtensionsCheckNonce = number;

export type FrameSystemExtensionsCheckWeight = {};

export type PalletAssetConversionTxPaymentChargeAssetTxPayment = { tip: bigint; assetId?: number | undefined };
