// Generated by @delightfuldot/codegen

import type { GenericChainStorage } from '@delightfuldot/types';
import type {
  AccountId20Like,
  H256,
  Bytes,
  Digest,
  FixedU128,
  Perbill,
  AccountId20,
  Percent,
  Data,
  FixedBytes,
  H160,
  U256,
} from '@delightfuldot/codecs';
import type {
  FrameSystemAccountInfo,
  FrameSupportDispatchPerDispatchClass,
  FrameSystemEventRecord,
  FrameSystemLastRuntimeUpgradeInfo,
  FrameSystemPhase,
  PolkadotPrimitivesV4PersistedValidationData,
  PolkadotPrimitivesV4UpgradeRestriction,
  SpTrieStorageProof,
  CumulusPalletParachainSystemRelayStateSnapshotMessagingStateSnapshot,
  PolkadotPrimitivesV4AbridgedHostConfiguration,
  CumulusPrimitivesParachainInherentMessageQueueChain,
  PolkadotParachainPrimitivesId,
  PolkadotCorePrimitivesOutboundHrmpMessage,
  SpWeightsWeightV2Weight,
  CumulusPalletParachainSystemCodeUpgradeAuthorization,
  PalletBalancesAccountData,
  PalletBalancesBalanceLock,
  PalletBalancesReserveData,
  PalletBalancesIdAmount,
  PalletTransactionPaymentReleases,
  PalletParachainStakingParachainBondConfig,
  PalletParachainStakingRoundInfo,
  PalletParachainStakingDelegator,
  PalletParachainStakingCandidateMetadata,
  PalletParachainStakingDelegationRequestsScheduledRequest,
  PalletParachainStakingAutoCompoundAutoCompoundConfig,
  PalletParachainStakingDelegations,
  PalletParachainStakingSetBoundedOrderedSet,
  PalletParachainStakingCollatorSnapshot,
  PalletParachainStakingDelayedPayout,
  PalletParachainStakingInflationInflationInfo,
  PalletAuthorSlotFilterNumNonZeroU32,
  PalletAuthorMappingRegistrationInfo,
  NimbusPrimitivesNimbusCryptoPublic,
  PalletMoonbeamOrbitersCollatorPoolInfo,
  PalletProxyProxyDefinition,
  PalletProxyAnnouncement,
  PalletIdentityRegistration,
  PalletIdentityRegistrarInfo,
  PalletMultisigMultisig,
  PalletEvmCodeMetadata,
  EthereumTransactionTransactionV2,
  FpRpcTransactionStatus,
  EthereumReceiptReceiptV3,
  EthereumBlock,
  PalletSchedulerScheduled,
  FrameSupportPreimagesBounded,
  PalletDemocracyReferendumInfo,
  PalletDemocracyVoteVoting,
  PalletDemocracyVoteThreshold,
  PalletDemocracyMetadataOwner,
  PalletPreimageRequestStatus,
  PalletConvictionVotingVoteVoting,
  PalletReferendaReferendumInfo,
  MoonbeamRuntimeRuntimeCall,
  PalletCollectiveVotes,
  PalletTreasuryProposal,
  PalletCrowdloanRewardsRewardInfo,
  CumulusPalletXcmpQueueInboundChannelDetails,
  CumulusPalletXcmpQueueOutboundChannelDetails,
  CumulusPalletXcmpQueueQueueConfigData,
  CumulusPalletDmpQueueConfigData,
  CumulusPalletDmpQueuePageIndexData,
  PalletXcmQueryStatus,
  XcmVersionedMultiLocation,
  PalletXcmVersionMigrationStage,
  PalletXcmRemoteLockedFungibleRecord,
  XcmVersionedAssetId,
  PalletAssetsAssetDetails,
  PalletAssetsAssetAccount,
  PalletAssetsApproval,
  PalletAssetsAssetMetadata,
  MoonbeamRuntimeXcmConfigAssetType,
  PalletAssetManagerAssetInfo,
  PalletXcmTransactorRemoteTransactInfoWithMaxWeight,
  XcmV3MultilocationMultiLocation,
  PalletRandomnessRequestState,
  PalletRandomnessRandomnessResult,
  PalletRandomnessRequestType,
} from './types';

export interface ChainStorage extends GenericChainStorage {
  system: {
    /**
     * The full account information for a particular account ID.
     **/
    account(arg: AccountId20Like): Promise<FrameSystemAccountInfo>;

    /**
     * Total extrinsics count for the current block.
     **/
    extrinsicCount(): Promise<number | undefined>;

    /**
     * The current weight for the block.
     **/
    blockWeight(): Promise<FrameSupportDispatchPerDispatchClass>;

    /**
     * Total length (in bytes) for all extrinsics put together, for the current block.
     **/
    allExtrinsicsLen(): Promise<number | undefined>;

    /**
     * Map of block numbers to block hashes.
     **/
    blockHash(arg: number): Promise<H256>;

    /**
     * Extrinsics data for the current block (maps an extrinsic's index to its data).
     **/
    extrinsicData(arg: number): Promise<Bytes>;

    /**
     * The current block number being processed. Set by `execute_block`.
     **/
    number(): Promise<number>;

    /**
     * Hash of the previous block.
     **/
    parentHash(): Promise<H256>;

    /**
     * Digest of the current block, also part of the block header.
     **/
    digest(): Promise<Digest>;

    /**
     * Events deposited for the current block.
     *
     * NOTE: The item is unbound and should therefore never be read on chain.
     * It could otherwise inflate the PoV size of a block.
     *
     * Events have a large in-memory size. Box the events to not go out-of-memory
     * just in case someone still reads them from within the runtime.
     **/
    events(): Promise<Array<FrameSystemEventRecord>>;

    /**
     * The number of events in the `Events<T>` list.
     **/
    eventCount(): Promise<number>;

    /**
     * Mapping between a topic (represented by T::Hash) and a vector of indexes
     * of events in the `<Events<T>>` list.
     *
     * All topic vectors have deterministic storage locations depending on the topic. This
     * allows light-clients to leverage the changes trie storage tracking mechanism and
     * in case of changes fetch the list of events of interest.
     *
     * The value has the type `(T::BlockNumber, EventIndex)` because if we used only just
     * the `EventIndex` then in case if the topic has the same contents on the next block
     * no notification will be triggered thus the event might be lost.
     **/
    eventTopics(arg: H256): Promise<Array<[number, number]>>;

    /**
     * Stores the `spec_version` and `spec_name` of when the last runtime upgrade happened.
     **/
    lastRuntimeUpgrade(): Promise<FrameSystemLastRuntimeUpgradeInfo | undefined>;

    /**
     * True if we have upgraded so that `type RefCount` is `u32`. False (default) if not.
     **/
    upgradedToU32RefCount(): Promise<boolean>;

    /**
     * True if we have upgraded so that AccountInfo contains three types of `RefCount`. False
     * (default) if not.
     **/
    upgradedToTripleRefCount(): Promise<boolean>;

    /**
     * The execution phase of the block.
     **/
    executionPhase(): Promise<FrameSystemPhase | undefined>;
  };
  parachainSystem: {
    /**
     * In case of a scheduled upgrade, this storage field contains the validation code to be applied.
     *
     * As soon as the relay chain gives us the go-ahead signal, we will overwrite the [`:code`][well_known_keys::CODE]
     * which will result the next block process with the new validation code. This concludes the upgrade process.
     *
     * [well_known_keys::CODE]: sp_core::storage::well_known_keys::CODE
     **/
    pendingValidationCode(): Promise<Bytes>;

    /**
     * Validation code that is set by the parachain and is to be communicated to collator and
     * consequently the relay-chain.
     *
     * This will be cleared in `on_initialize` of each new block if no other pallet already set
     * the value.
     **/
    newValidationCode(): Promise<Bytes | undefined>;

    /**
     * The [`PersistedValidationData`] set for this block.
     * This value is expected to be set only once per block and it's never stored
     * in the trie.
     **/
    validationData(): Promise<PolkadotPrimitivesV4PersistedValidationData | undefined>;

    /**
     * Were the validation data set to notify the relay chain?
     **/
    didSetValidationCode(): Promise<boolean>;

    /**
     * The relay chain block number associated with the last parachain block.
     **/
    lastRelayChainBlockNumber(): Promise<number>;

    /**
     * An option which indicates if the relay-chain restricts signalling a validation code upgrade.
     * In other words, if this is `Some` and [`NewValidationCode`] is `Some` then the produced
     * candidate will be invalid.
     *
     * This storage item is a mirror of the corresponding value for the current parachain from the
     * relay-chain. This value is ephemeral which means it doesn't hit the storage. This value is
     * set after the inherent.
     **/
    upgradeRestrictionSignal(): Promise<PolkadotPrimitivesV4UpgradeRestriction | undefined>;

    /**
     * The state proof for the last relay parent block.
     *
     * This field is meant to be updated each block with the validation data inherent. Therefore,
     * before processing of the inherent, e.g. in `on_initialize` this data may be stale.
     *
     * This data is also absent from the genesis.
     **/
    relayStateProof(): Promise<SpTrieStorageProof | undefined>;

    /**
     * The snapshot of some state related to messaging relevant to the current parachain as per
     * the relay parent.
     *
     * This field is meant to be updated each block with the validation data inherent. Therefore,
     * before processing of the inherent, e.g. in `on_initialize` this data may be stale.
     *
     * This data is also absent from the genesis.
     **/
    relevantMessagingState(): Promise<CumulusPalletParachainSystemRelayStateSnapshotMessagingStateSnapshot | undefined>;

    /**
     * The parachain host configuration that was obtained from the relay parent.
     *
     * This field is meant to be updated each block with the validation data inherent. Therefore,
     * before processing of the inherent, e.g. in `on_initialize` this data may be stale.
     *
     * This data is also absent from the genesis.
     **/
    hostConfiguration(): Promise<PolkadotPrimitivesV4AbridgedHostConfiguration | undefined>;

    /**
     * The last downward message queue chain head we have observed.
     *
     * This value is loaded before and saved after processing inbound downward messages carried
     * by the system inherent.
     **/
    lastDmqMqcHead(): Promise<CumulusPrimitivesParachainInherentMessageQueueChain>;

    /**
     * The message queue chain heads we have observed per each channel incoming channel.
     *
     * This value is loaded before and saved after processing inbound downward messages carried
     * by the system inherent.
     **/
    lastHrmpMqcHeads(): Promise<
      Array<[PolkadotParachainPrimitivesId, CumulusPrimitivesParachainInherentMessageQueueChain]>
    >;

    /**
     * Number of downward messages processed in a block.
     *
     * This will be cleared in `on_initialize` of each new block.
     **/
    processedDownwardMessages(): Promise<number>;

    /**
     * HRMP watermark that was set in a block.
     *
     * This will be cleared in `on_initialize` of each new block.
     **/
    hrmpWatermark(): Promise<number>;

    /**
     * HRMP messages that were sent in a block.
     *
     * This will be cleared in `on_initialize` of each new block.
     **/
    hrmpOutboundMessages(): Promise<Array<PolkadotCorePrimitivesOutboundHrmpMessage>>;

    /**
     * Upward messages that were sent in a block.
     *
     * This will be cleared in `on_initialize` of each new block.
     **/
    upwardMessages(): Promise<Array<Bytes>>;

    /**
     * Upward messages that are still pending and not yet send to the relay chain.
     **/
    pendingUpwardMessages(): Promise<Array<Bytes>>;

    /**
     * The number of HRMP messages we observed in `on_initialize` and thus used that number for
     * announcing the weight of `on_initialize` and `on_finalize`.
     **/
    announcedHrmpMessagesPerCandidate(): Promise<number>;

    /**
     * The weight we reserve at the beginning of the block for processing XCMP messages. This
     * overrides the amount set in the Config trait.
     **/
    reservedXcmpWeightOverride(): Promise<SpWeightsWeightV2Weight | undefined>;

    /**
     * The weight we reserve at the beginning of the block for processing DMP messages. This
     * overrides the amount set in the Config trait.
     **/
    reservedDmpWeightOverride(): Promise<SpWeightsWeightV2Weight | undefined>;

    /**
     * The next authorized upgrade, if there is one.
     **/
    authorizedUpgrade(): Promise<CumulusPalletParachainSystemCodeUpgradeAuthorization | undefined>;

    /**
     * A custom head data that should be returned as result of `validate_block`.
     *
     * See [`Pallet::set_custom_validation_head_data`] for more information.
     **/
    customValidationHeadData(): Promise<Bytes | undefined>;
  };
  timestamp: {
    /**
     * Current time for the current block.
     **/
    now(): Promise<bigint>;

    /**
     * Did the timestamp get updated in this block?
     **/
    didUpdate(): Promise<boolean>;
  };
  parachainInfo: { parachainId(): Promise<PolkadotParachainPrimitivesId> };
  rootTesting: {};
  balances: {
    /**
     * The total units issued in the system.
     **/
    totalIssuance(): Promise<bigint>;

    /**
     * The total units of outstanding deactivated balance in the system.
     **/
    inactiveIssuance(): Promise<bigint>;

    /**
     * The Balances pallet example of storing the balance of an account.
     *
     * # Example
     *
     * ```nocompile
     * impl pallet_balances::Config for Runtime {
     * type AccountStore = StorageMapShim<Self::Account<Runtime>, frame_system::Provider<Runtime>, AccountId, Self::AccountData<Balance>>
     * }
     * ```
     *
     * You can also store the balance of an account in the `System` pallet.
     *
     * # Example
     *
     * ```nocompile
     * impl pallet_balances::Config for Runtime {
     * type AccountStore = System
     * }
     * ```
     *
     * But this comes with tradeoffs, storing account balances in the system pallet stores
     * `frame_system` data alongside the account data contrary to storing account balances in the
     * `Balances` pallet, which uses a `StorageMap` to store balances data only.
     * NOTE: This is only used in the case that this pallet is used to store balances.
     **/
    account(arg: AccountId20Like): Promise<PalletBalancesAccountData>;

    /**
     * Any liquidity locks on some account balances.
     * NOTE: Should only be accessed when setting, changing and freeing a lock.
     **/
    locks(arg: AccountId20Like): Promise<Array<PalletBalancesBalanceLock>>;

    /**
     * Named reserves on some account balances.
     **/
    reserves(arg: AccountId20Like): Promise<Array<PalletBalancesReserveData>>;

    /**
     * Holds on account balances.
     **/
    holds(arg: AccountId20Like): Promise<Array<PalletBalancesIdAmount>>;

    /**
     * Freeze locks on account balances.
     **/
    freezes(arg: AccountId20Like): Promise<Array<PalletBalancesIdAmount>>;
  };
  transactionPayment: {
    nextFeeMultiplier(): Promise<FixedU128>;
    storageVersion(): Promise<PalletTransactionPaymentReleases>;
  };
  parachainStaking: {
    /**
     * Commission percent taken off of rewards for all collators
     **/
    collatorCommission(): Promise<Perbill>;

    /**
     * The total candidates selected every round
     **/
    totalSelected(): Promise<number>;

    /**
     * Parachain bond config info { account, percent_of_inflation }
     **/
    parachainBondInfo(): Promise<PalletParachainStakingParachainBondConfig>;

    /**
     * Current round index and next round scheduled transition
     **/
    round(): Promise<PalletParachainStakingRoundInfo>;

    /**
     * Get delegator state associated with an account if account is delegating else None
     **/
    delegatorState(arg: AccountId20Like): Promise<PalletParachainStakingDelegator | undefined>;

    /**
     * Get collator candidate info associated with an account if account is candidate else None
     **/
    candidateInfo(arg: AccountId20Like): Promise<PalletParachainStakingCandidateMetadata | undefined>;

    /**
     * Stores outstanding delegation requests per collator.
     **/
    delegationScheduledRequests(
      arg: AccountId20Like,
    ): Promise<Array<PalletParachainStakingDelegationRequestsScheduledRequest>>;

    /**
     * Stores auto-compounding configuration per collator.
     **/
    autoCompoundingDelegations(
      arg: AccountId20Like,
    ): Promise<Array<PalletParachainStakingAutoCompoundAutoCompoundConfig>>;

    /**
     * Top delegations for collator candidate
     **/
    topDelegations(arg: AccountId20Like): Promise<PalletParachainStakingDelegations | undefined>;

    /**
     * Bottom delegations for collator candidate
     **/
    bottomDelegations(arg: AccountId20Like): Promise<PalletParachainStakingDelegations | undefined>;

    /**
     * The collator candidates selected for the current round
     **/
    selectedCandidates(): Promise<Array<AccountId20>>;

    /**
     * Total capital locked by this staking pallet
     **/
    total(): Promise<bigint>;

    /**
     * The pool of collator candidates, each with their total backing stake
     **/
    candidatePool(): Promise<PalletParachainStakingSetBoundedOrderedSet>;

    /**
     * Snapshot of collator delegation stake at the start of the round
     **/
    atStake(arg: [number, AccountId20Like]): Promise<PalletParachainStakingCollatorSnapshot>;

    /**
     * Delayed payouts
     **/
    delayedPayouts(arg: number): Promise<PalletParachainStakingDelayedPayout | undefined>;

    /**
     * Total counted stake for selected candidates in the round
     **/
    staked(arg: number): Promise<bigint>;

    /**
     * Inflation configuration
     **/
    inflationConfig(): Promise<PalletParachainStakingInflationInflationInfo>;

    /**
     * Total points awarded to collators for block production in the round
     **/
    points(arg: number): Promise<number>;

    /**
     * Points for each collator per round
     **/
    awardedPts(arg: [number, AccountId20Like]): Promise<number>;
  };
  authorInherent: {
    /**
     * Author of current block.
     **/
    author(): Promise<AccountId20 | undefined>;

    /**
     * The highest slot that has been seen in the history of this chain.
     * This is a strictly-increasing value.
     **/
    highestSlotSeen(): Promise<number>;
  };
  authorFilter: {
    eligibleRatio(): Promise<Percent>;

    /**
     * The number of active authors that will be eligible at each height.
     **/
    eligibleCount(): Promise<PalletAuthorSlotFilterNumNonZeroU32>;
  };
  authorMapping: {
    /**
     * We maintain a mapping from the NimbusIds used in the consensus layer
     * to the AccountIds runtime.
     **/
    mappingWithDeposit(
      arg: NimbusPrimitivesNimbusCryptoPublic,
    ): Promise<PalletAuthorMappingRegistrationInfo | undefined>;

    /**
     * We maintain a reverse mapping from AccountIds to NimbusIDS
     **/
    nimbusLookup(arg: AccountId20Like): Promise<NimbusPrimitivesNimbusCryptoPublic | undefined>;
  };
  moonbeamOrbiters: {
    /**
     * Account lookup override
     **/
    accountLookupOverride(arg: AccountId20Like): Promise<AccountId20 | undefined | undefined>;

    /**
     * Current orbiters, with their "parent" collator
     **/
    collatorsPool(arg: AccountId20Like): Promise<PalletMoonbeamOrbitersCollatorPoolInfo | undefined>;

    /**
     * Counter for the related counted storage map
     **/
    counterForCollatorsPool(): Promise<number>;

    /**
     * Current round index
     **/
    currentRound(): Promise<number>;

    /**
     * If true, it forces the rotation at the next round.
     * A use case: when changing RotatePeriod, you need a migration code that sets this value to
     * true to avoid holes in OrbiterPerRound.
     **/
    forceRotation(): Promise<boolean>;

    /**
     * Minimum deposit required to be registered as an orbiter
     **/
    minOrbiterDeposit(): Promise<bigint | undefined>;

    /**
     * Store active orbiter per round and per parent collator
     **/
    orbiterPerRound(arg: [number, AccountId20Like]): Promise<AccountId20 | undefined>;

    /**
     * Check if account is an orbiter
     **/
    registeredOrbiter(arg: AccountId20Like): Promise<boolean | undefined>;
  };
  proxy: {
    /**
     * The set of account proxies. Maps the account which has delegated to the accounts
     * which are being delegated to, together with the amount held on deposit.
     **/
    proxies(arg: AccountId20Like): Promise<[Array<PalletProxyProxyDefinition>, bigint]>;

    /**
     * The announcements made by the proxy (key).
     **/
    announcements(arg: AccountId20Like): Promise<[Array<PalletProxyAnnouncement>, bigint]>;
  };
  maintenanceMode: {
    /**
     * Whether the site is in maintenance mode
     **/
    maintenanceMode(): Promise<boolean>;
  };
  identity: {
    /**
     * Information that is pertinent to identify the entity behind an account.
     *
     * TWOX-NOTE: OK ― `AccountId` is a secure hash.
     **/
    identityOf(arg: AccountId20Like): Promise<PalletIdentityRegistration | undefined>;

    /**
     * The super-identity of an alternative "sub" identity together with its name, within that
     * context. If the account is not some other account's sub-identity, then just `None`.
     **/
    superOf(arg: AccountId20Like): Promise<[AccountId20, Data] | undefined>;

    /**
     * Alternative "sub" identities of this account.
     *
     * The first item is the deposit, the second is a vector of the accounts.
     *
     * TWOX-NOTE: OK ― `AccountId` is a secure hash.
     **/
    subsOf(arg: AccountId20Like): Promise<[bigint, Array<AccountId20>]>;

    /**
     * The set of registrars. Not expected to get very big as can only be added through a
     * special origin (likely a council motion).
     *
     * The index into this can be cast to `RegistrarIndex` to get a valid value.
     **/
    registrars(): Promise<Array<PalletIdentityRegistrarInfo | undefined>>;
  };
  migrations: {
    /**
     * True if all required migrations have completed
     **/
    fullyUpgraded(): Promise<boolean>;

    /**
     * MigrationState tracks the progress of a migration.
     * Maps name (Vec<u8>) -> whether or not migration has been completed (bool)
     **/
    migrationState(arg: Bytes): Promise<boolean>;

    /**
     * Temporary value that is set to true at the beginning of the block during which the execution
     * of xcm messages must be paused.
     **/
    shouldPauseXcm(): Promise<boolean>;
  };
  multisig: {
    /**
     * The set of open multisig operations.
     **/
    multisigs(arg: [AccountId20Like, FixedBytes<32>]): Promise<PalletMultisigMultisig | undefined>;
  };
  ethereumChainId: { chainId(): Promise<bigint> };
  eVM: {
    accountCodes(arg: H160): Promise<Bytes>;
    accountCodesMetadata(arg: H160): Promise<PalletEvmCodeMetadata | undefined>;
    accountStorages(arg: [H160, H256]): Promise<H256>;
  };
  ethereum: {
    /**
     * Current building block's transactions and receipts.
     **/
    pending(): Promise<Array<[EthereumTransactionTransactionV2, FpRpcTransactionStatus, EthereumReceiptReceiptV3]>>;

    /**
     * The current Ethereum block.
     **/
    currentBlock(): Promise<EthereumBlock | undefined>;

    /**
     * The current Ethereum receipts.
     **/
    currentReceipts(): Promise<Array<EthereumReceiptReceiptV3> | undefined>;

    /**
     * The current transaction statuses.
     **/
    currentTransactionStatuses(): Promise<Array<FpRpcTransactionStatus> | undefined>;
    blockHash(arg: U256): Promise<H256>;
  };
  scheduler: {
    incompleteSince(): Promise<number | undefined>;

    /**
     * Items to be executed, indexed by the block number that they should be executed on.
     **/
    agenda(arg: number): Promise<Array<PalletSchedulerScheduled | undefined>>;

    /**
     * Lookup from a name to the block number and index of the task.
     *
     * For v3 -> v4 the previously unbounded identities are Blake2-256 hashed to form the v4
     * identities.
     **/
    lookup(arg: FixedBytes<32>): Promise<[number, number] | undefined>;
  };
  democracy: {
    /**
     * The number of (public) proposals that have been made so far.
     **/
    publicPropCount(): Promise<number>;

    /**
     * The public proposals. Unsorted. The second item is the proposal.
     **/
    publicProps(): Promise<Array<[number, FrameSupportPreimagesBounded, AccountId20]>>;

    /**
     * Those who have locked a deposit.
     *
     * TWOX-NOTE: Safe, as increasing integer keys are safe.
     **/
    depositOf(arg: number): Promise<[Array<AccountId20>, bigint] | undefined>;

    /**
     * The next free referendum index, aka the number of referenda started so far.
     **/
    referendumCount(): Promise<number>;

    /**
     * The lowest referendum index representing an unbaked referendum. Equal to
     * `ReferendumCount` if there isn't a unbaked referendum.
     **/
    lowestUnbaked(): Promise<number>;

    /**
     * Information concerning any given referendum.
     *
     * TWOX-NOTE: SAFE as indexes are not under an attacker’s control.
     **/
    referendumInfoOf(arg: number): Promise<PalletDemocracyReferendumInfo | undefined>;

    /**
     * All votes for a particular voter. We store the balance for the number of votes that we
     * have recorded. The second item is the total amount of delegations, that will be added.
     *
     * TWOX-NOTE: SAFE as `AccountId`s are crypto hashes anyway.
     **/
    votingOf(arg: AccountId20Like): Promise<PalletDemocracyVoteVoting>;

    /**
     * True if the last referendum tabled was submitted externally. False if it was a public
     * proposal.
     **/
    lastTabledWasExternal(): Promise<boolean>;

    /**
     * The referendum to be tabled whenever it would be valid to table an external proposal.
     * This happens when a referendum needs to be tabled and one of two conditions are met:
     * - `LastTabledWasExternal` is `false`; or
     * - `PublicProps` is empty.
     **/
    nextExternal(): Promise<[FrameSupportPreimagesBounded, PalletDemocracyVoteThreshold] | undefined>;

    /**
     * A record of who vetoed what. Maps proposal hash to a possible existent block number
     * (until when it may not be resubmitted) and who vetoed it.
     **/
    blacklist(arg: H256): Promise<[number, Array<AccountId20>] | undefined>;

    /**
     * Record of all proposals that have been subject to emergency cancellation.
     **/
    cancellations(arg: H256): Promise<boolean>;

    /**
     * General information concerning any proposal or referendum.
     * The `PreimageHash` refers to the preimage of the `Preimages` provider which can be a JSON
     * dump or IPFS hash of a JSON file.
     *
     * Consider a garbage collection for a metadata of finished referendums to `unrequest` (remove)
     * large preimages.
     **/
    metadataOf(arg: PalletDemocracyMetadataOwner): Promise<H256 | undefined>;
  };
  preimage: {
    /**
     * The request status of a given hash.
     **/
    statusFor(arg: H256): Promise<PalletPreimageRequestStatus | undefined>;
    preimageFor(arg: [H256, number]): Promise<Bytes | undefined>;
  };
  convictionVoting: {
    /**
     * All voting for a particular voter in a particular voting class. We store the balance for the
     * number of votes that we have recorded.
     **/
    votingFor(arg: [AccountId20Like, number]): Promise<PalletConvictionVotingVoteVoting>;

    /**
     * The voting classes which have a non-zero lock requirement and the lock amounts which they
     * require. The actual amount locked on behalf of this pallet should always be the maximum of
     * this list.
     **/
    classLocksFor(arg: AccountId20Like): Promise<Array<[number, bigint]>>;
  };
  referenda: {
    /**
     * The next free referendum index, aka the number of referenda started so far.
     **/
    referendumCount(): Promise<number>;

    /**
     * Information concerning any given referendum.
     **/
    referendumInfoFor(arg: number): Promise<PalletReferendaReferendumInfo | undefined>;

    /**
     * The sorted list of referenda ready to be decided but not yet being decided, ordered by
     * conviction-weighted approvals.
     *
     * This should be empty if `DecidingCount` is less than `TrackInfo::max_deciding`.
     **/
    trackQueue(arg: number): Promise<Array<[number, bigint]>>;

    /**
     * The number of referenda being decided currently.
     **/
    decidingCount(arg: number): Promise<number>;

    /**
     * The metadata is a general information concerning the referendum.
     * The `PreimageHash` refers to the preimage of the `Preimages` provider which can be a JSON
     * dump or IPFS hash of a JSON file.
     *
     * Consider a garbage collection for a metadata of finished referendums to `unrequest` (remove)
     * large preimages.
     **/
    metadataOf(arg: number): Promise<H256 | undefined>;
  };
  whitelist: { whitelistedCall(arg: H256): Promise<[] | undefined> };
  councilCollective: {
    /**
     * The hashes of the active proposals.
     **/
    proposals(): Promise<Array<H256>>;

    /**
     * Actual proposal for a given hash, if it's current.
     **/
    proposalOf(arg: H256): Promise<MoonbeamRuntimeRuntimeCall | undefined>;

    /**
     * Votes on a given proposal, if it is ongoing.
     **/
    voting(arg: H256): Promise<PalletCollectiveVotes | undefined>;

    /**
     * Proposals so far.
     **/
    proposalCount(): Promise<number>;

    /**
     * The current members of the collective. This is stored sorted (just by value).
     **/
    members(): Promise<Array<AccountId20>>;

    /**
     * The prime member that helps determine the default vote behavior in case of absentations.
     **/
    prime(): Promise<AccountId20 | undefined>;
  };
  techCommitteeCollective: {
    /**
     * The hashes of the active proposals.
     **/
    proposals(): Promise<Array<H256>>;

    /**
     * Actual proposal for a given hash, if it's current.
     **/
    proposalOf(arg: H256): Promise<MoonbeamRuntimeRuntimeCall | undefined>;

    /**
     * Votes on a given proposal, if it is ongoing.
     **/
    voting(arg: H256): Promise<PalletCollectiveVotes | undefined>;

    /**
     * Proposals so far.
     **/
    proposalCount(): Promise<number>;

    /**
     * The current members of the collective. This is stored sorted (just by value).
     **/
    members(): Promise<Array<AccountId20>>;

    /**
     * The prime member that helps determine the default vote behavior in case of absentations.
     **/
    prime(): Promise<AccountId20 | undefined>;
  };
  treasuryCouncilCollective: {
    /**
     * The hashes of the active proposals.
     **/
    proposals(): Promise<Array<H256>>;

    /**
     * Actual proposal for a given hash, if it's current.
     **/
    proposalOf(arg: H256): Promise<MoonbeamRuntimeRuntimeCall | undefined>;

    /**
     * Votes on a given proposal, if it is ongoing.
     **/
    voting(arg: H256): Promise<PalletCollectiveVotes | undefined>;

    /**
     * Proposals so far.
     **/
    proposalCount(): Promise<number>;

    /**
     * The current members of the collective. This is stored sorted (just by value).
     **/
    members(): Promise<Array<AccountId20>>;

    /**
     * The prime member that helps determine the default vote behavior in case of absentations.
     **/
    prime(): Promise<AccountId20 | undefined>;
  };
  openTechCommitteeCollective: {
    /**
     * The hashes of the active proposals.
     **/
    proposals(): Promise<Array<H256>>;

    /**
     * Actual proposal for a given hash, if it's current.
     **/
    proposalOf(arg: H256): Promise<MoonbeamRuntimeRuntimeCall | undefined>;

    /**
     * Votes on a given proposal, if it is ongoing.
     **/
    voting(arg: H256): Promise<PalletCollectiveVotes | undefined>;

    /**
     * Proposals so far.
     **/
    proposalCount(): Promise<number>;

    /**
     * The current members of the collective. This is stored sorted (just by value).
     **/
    members(): Promise<Array<AccountId20>>;

    /**
     * The prime member that helps determine the default vote behavior in case of absentations.
     **/
    prime(): Promise<AccountId20 | undefined>;
  };
  treasury: {
    /**
     * Number of proposals that have been made.
     **/
    proposalCount(): Promise<number>;

    /**
     * Proposals that have been made.
     **/
    proposals(arg: number): Promise<PalletTreasuryProposal | undefined>;

    /**
     * The amount which has been reported as inactive to Currency.
     **/
    deactivated(): Promise<bigint>;

    /**
     * Proposal indices that have been approved but not yet awarded.
     **/
    approvals(): Promise<Array<number>>;
  };
  crowdloanRewards: {
    accountsPayable(arg: AccountId20Like): Promise<PalletCrowdloanRewardsRewardInfo | undefined>;
    claimedRelayChainIds(arg: FixedBytes<32>): Promise<[] | undefined>;
    unassociatedContributions(arg: FixedBytes<32>): Promise<PalletCrowdloanRewardsRewardInfo | undefined>;
    initialized(): Promise<boolean>;

    /**
     * Vesting block height at the initialization of the pallet
     **/
    initRelayBlock(): Promise<number>;

    /**
     * Vesting block height at the initialization of the pallet
     **/
    endRelayBlock(): Promise<number>;

    /**
     * Total initialized amount so far. We store this to make pallet funds == contributors reward
     * check easier and more efficient
     **/
    initializedRewardAmount(): Promise<bigint>;

    /**
     * Total number of contributors to aid hinting benchmarking
     **/
    totalContributors(): Promise<number>;
  };
  xcmpQueue: {
    /**
     * Status of the inbound XCMP channels.
     **/
    inboundXcmpStatus(): Promise<Array<CumulusPalletXcmpQueueInboundChannelDetails>>;

    /**
     * Inbound aggregate XCMP messages. It can only be one per ParaId/block.
     **/
    inboundXcmpMessages(arg: [PolkadotParachainPrimitivesId, number]): Promise<Bytes>;

    /**
     * The non-empty XCMP channels in order of becoming non-empty, and the index of the first
     * and last outbound message. If the two indices are equal, then it indicates an empty
     * queue and there must be a non-`Ok` `OutboundStatus`. We assume queues grow no greater
     * than 65535 items. Queue indices for normal messages begin at one; zero is reserved in
     * case of the need to send a high-priority signal message this block.
     * The bool is true if there is a signal message waiting to be sent.
     **/
    outboundXcmpStatus(): Promise<Array<CumulusPalletXcmpQueueOutboundChannelDetails>>;

    /**
     * The messages outbound in a given XCMP channel.
     **/
    outboundXcmpMessages(arg: [PolkadotParachainPrimitivesId, number]): Promise<Bytes>;

    /**
     * Any signal messages waiting to be sent.
     **/
    signalMessages(arg: PolkadotParachainPrimitivesId): Promise<Bytes>;

    /**
     * The configuration which controls the dynamics of the outbound queue.
     **/
    queueConfig(): Promise<CumulusPalletXcmpQueueQueueConfigData>;

    /**
     * The messages that exceeded max individual message weight budget.
     *
     * These message stay in this storage map until they are manually dispatched via
     * `service_overweight`.
     **/
    overweight(arg: bigint): Promise<[PolkadotParachainPrimitivesId, number, Bytes] | undefined>;

    /**
     * Counter for the related counted storage map
     **/
    counterForOverweight(): Promise<number>;

    /**
     * The number of overweight messages ever recorded in `Overweight`. Also doubles as the next
     * available free overweight index.
     **/
    overweightCount(): Promise<bigint>;

    /**
     * Whether or not the XCMP queue is suspended from executing incoming XCMs or not.
     **/
    queueSuspended(): Promise<boolean>;
  };
  dmpQueue: {
    /**
     * The configuration.
     **/
    configuration(): Promise<CumulusPalletDmpQueueConfigData>;

    /**
     * The page index.
     **/
    pageIndex(): Promise<CumulusPalletDmpQueuePageIndexData>;

    /**
     * The queue pages.
     **/
    pages(arg: number): Promise<Array<[number, Bytes]>>;

    /**
     * The overweight messages.
     **/
    overweight(arg: bigint): Promise<[number, Bytes] | undefined>;

    /**
     * Counter for the related counted storage map
     **/
    counterForOverweight(): Promise<number>;
  };
  polkadotXcm: {
    /**
     * The latest available query index.
     **/
    queryCounter(): Promise<bigint>;

    /**
     * The ongoing queries.
     **/
    queries(arg: bigint): Promise<PalletXcmQueryStatus | undefined>;

    /**
     * The existing asset traps.
     *
     * Key is the blake2 256 hash of (origin, versioned `MultiAssets`) pair. Value is the number of
     * times this pair has been trapped (usually just 1 if it exists at all).
     **/
    assetTraps(arg: H256): Promise<number>;

    /**
     * Default version to encode XCM when latest version of destination is unknown. If `None`,
     * then the destinations whose XCM version is unknown are considered unreachable.
     **/
    safeXcmVersion(): Promise<number | undefined>;

    /**
     * The Latest versions that we know various locations support.
     **/
    supportedVersion(arg: [number, XcmVersionedMultiLocation]): Promise<number | undefined>;

    /**
     * All locations that we have requested version notifications from.
     **/
    versionNotifiers(arg: [number, XcmVersionedMultiLocation]): Promise<bigint | undefined>;

    /**
     * The target locations that are subscribed to our version changes, as well as the most recent
     * of our versions we informed them of.
     **/
    versionNotifyTargets(
      arg: [number, XcmVersionedMultiLocation],
    ): Promise<[bigint, SpWeightsWeightV2Weight, number] | undefined>;

    /**
     * Destinations whose latest XCM version we would like to know. Duplicates not allowed, and
     * the `u32` counter is the number of times that a send to the destination has been attempted,
     * which is used as a prioritization.
     **/
    versionDiscoveryQueue(): Promise<Array<[XcmVersionedMultiLocation, number]>>;

    /**
     * The current migration's stage, if any.
     **/
    currentMigration(): Promise<PalletXcmVersionMigrationStage | undefined>;

    /**
     * Fungible assets which we know are locked on a remote chain.
     **/
    remoteLockedFungibles(
      arg: [number, AccountId20Like, XcmVersionedAssetId],
    ): Promise<PalletXcmRemoteLockedFungibleRecord | undefined>;

    /**
     * Fungible assets which we know are locked on this chain.
     **/
    lockedFungibles(arg: AccountId20Like): Promise<Array<[bigint, XcmVersionedMultiLocation]> | undefined>;

    /**
     * Global suspension state of the XCM executor.
     **/
    xcmExecutionSuspended(): Promise<boolean>;
  };
  assets: {
    /**
     * Details of an asset.
     **/
    asset(arg: bigint): Promise<PalletAssetsAssetDetails | undefined>;

    /**
     * The holdings of a specific account for a specific asset.
     **/
    account(arg: [bigint, AccountId20Like]): Promise<PalletAssetsAssetAccount | undefined>;

    /**
     * Approved balance transfers. First balance is the amount approved for transfer. Second
     * is the amount of `T::Currency` reserved for storing this.
     * First key is the asset ID, second key is the owner and third key is the delegate.
     **/
    approvals(arg: [bigint, AccountId20Like, AccountId20Like]): Promise<PalletAssetsApproval | undefined>;

    /**
     * Metadata of an asset.
     **/
    metadata(arg: bigint): Promise<PalletAssetsAssetMetadata>;
  };
  assetManager: {
    /**
     * Mapping from an asset id to asset type.
     * This is mostly used when receiving transaction specifying an asset directly,
     * like transferring an asset from this chain to another.
     **/
    assetIdType(arg: bigint): Promise<MoonbeamRuntimeXcmConfigAssetType | undefined>;

    /**
     * Reverse mapping of AssetIdType. Mapping from an asset type to an asset id.
     * This is mostly used when receiving a multilocation XCM message to retrieve
     * the corresponding asset in which tokens should me minted.
     **/
    assetTypeId(arg: MoonbeamRuntimeXcmConfigAssetType): Promise<bigint | undefined>;

    /**
     * Stores the units per second for local execution for a AssetType.
     * This is used to know how to charge for XCM execution in a particular
     * asset
     * Not all assets might contain units per second, hence the different storage
     **/
    assetTypeUnitsPerSecond(arg: MoonbeamRuntimeXcmConfigAssetType): Promise<bigint | undefined>;

    /**
     * Stores the counter of the number of local assets that have been
     * created so far
     * This value can be used to salt the creation of an assetId, e.g.,
     * by hashing it. This is particularly useful for cases like moonbeam
     * where letting users choose their assetId would result in collision
     * in the evm side.
     **/
    localAssetCounter(): Promise<bigint>;

    /**
     * Local asset deposits, a mapping from assetId to a struct
     * holding the creator (from which the deposit was reserved) and
     * the deposit amount
     **/
    localAssetDeposit(arg: bigint): Promise<PalletAssetManagerAssetInfo | undefined>;
    supportedFeePaymentAssets(): Promise<Array<MoonbeamRuntimeXcmConfigAssetType>>;
  };
  xTokens: {};
  xcmTransactor: {
    /**
     * Since we are using pallet-utility for account derivation (through AsDerivative),
     * we need to provide an index for the account derivation. This storage item stores the index
     * assigned for a given local account. These indices are usable as derivative in the relay chain
     **/
    indexToAccount(arg: number): Promise<AccountId20 | undefined>;

    /**
     * Stores the transact info of a MultiLocation. This defines how much extra weight we need to
     * add when we want to transact in the destination chain and maximum amount of weight allowed
     * by the destination chain
     **/
    transactInfoWithWeightLimit(
      arg: XcmV3MultilocationMultiLocation,
    ): Promise<PalletXcmTransactorRemoteTransactInfoWithMaxWeight | undefined>;

    /**
     * Stores the fee per second for an asset in its reserve chain. This allows us to convert
     * from weight to fee
     **/
    destinationAssetFeePerSecond(arg: XcmV3MultilocationMultiLocation): Promise<bigint | undefined>;
  };
  localAssets: {
    /**
     * Details of an asset.
     **/
    asset(arg: bigint): Promise<PalletAssetsAssetDetails | undefined>;

    /**
     * The holdings of a specific account for a specific asset.
     **/
    account(arg: [bigint, AccountId20Like]): Promise<PalletAssetsAssetAccount | undefined>;

    /**
     * Approved balance transfers. First balance is the amount approved for transfer. Second
     * is the amount of `T::Currency` reserved for storing this.
     * First key is the asset ID, second key is the owner and third key is the delegate.
     **/
    approvals(arg: [bigint, AccountId20Like, AccountId20Like]): Promise<PalletAssetsApproval | undefined>;

    /**
     * Metadata of an asset.
     **/
    metadata(arg: bigint): Promise<PalletAssetsAssetMetadata>;
  };
  ethereumXcm: {
    /**
     * Global nonce used for building Ethereum transaction payload.
     **/
    nonce(): Promise<U256>;

    /**
     * Whether or not Ethereum-XCM is suspended from executing
     **/
    ethereumXcmSuspended(): Promise<boolean>;
  };
  randomness: {
    /**
     * Randomness requests not yet fulfilled or purged
     **/
    requests(arg: bigint): Promise<PalletRandomnessRequestState | undefined>;

    /**
     * Number of randomness requests made so far, used to generate the next request's uid
     **/
    requestCount(): Promise<bigint>;

    /**
     * Current local per-block VRF randomness
     * Set in `on_initialize`
     **/
    localVrfOutput(): Promise<H256 | undefined>;

    /**
     * Relay epoch
     **/
    relayEpoch(): Promise<bigint>;

    /**
     * Ensures the mandatory inherent was included in the block
     **/
    inherentIncluded(): Promise<[] | undefined>;

    /**
     * Records whether this is the first block (genesis or runtime upgrade)
     **/
    notFirstBlock(): Promise<[] | undefined>;

    /**
     * Snapshot of randomness to fulfill all requests that are for the same raw randomness
     * Removed once $value.request_count == 0
     **/
    randomnessResults(arg: PalletRandomnessRequestType): Promise<PalletRandomnessRandomnessResult | undefined>;

    /**
     * Previous local per-block VRF randomness
     * Set in `on_finalize` of last block
     **/
    previousLocalVrfOutput(): Promise<H256>;
  };
}
