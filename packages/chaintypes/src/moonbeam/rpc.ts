// Generated by @delightfuldot/codegen

import {
  GenericRpcCalls,
  AsyncMethod,
  RpcMethods,
  ChainType,
  Health,
  NodeRole,
  PeerInfo,
  ChainProperties,
  SyncState,
  NetworkState,
} from '@delightfuldot/types';
import type { Metadata, BlockHash } from '@delightfuldot/codecs';
import type { AccountId, Bytes } from './types';

export interface RpcCalls extends GenericRpcCalls {
  author: {
    /**
     * @rpcname: author_hasKey
     **/
    hasKey: AsyncMethod;

    /**
     * @rpcname: author_hasSessionKeys
     **/
    hasSessionKeys: AsyncMethod;

    /**
     * @rpcname: author_insertKey
     **/
    insertKey: AsyncMethod;

    /**
     * @rpcname: author_pendingExtrinsics
     **/
    pendingExtrinsics: AsyncMethod;

    /**
     * @rpcname: author_removeExtrinsic
     **/
    removeExtrinsic: AsyncMethod;

    /**
     * @rpcname: author_rotateKeys
     **/
    rotateKeys: AsyncMethod;

    /**
     * @rpcname: author_submitAndWatchExtrinsic
     **/
    submitAndWatchExtrinsic: AsyncMethod;

    /**
     * @rpcname: author_submitExtrinsic
     **/
    submitExtrinsic: AsyncMethod;

    /**
     * @rpcname: author_unwatchExtrinsic
     **/
    unwatchExtrinsic: AsyncMethod;

    [method: string]: AsyncMethod;
  };
  chainHead: {
    /**
     * @rpcname: chainHead_unstable_body
     **/
    unstable_body: AsyncMethod;

    /**
     * @rpcname: chainHead_unstable_call
     **/
    unstable_call: AsyncMethod;

    /**
     * @rpcname: chainHead_unstable_follow
     **/
    unstable_follow: AsyncMethod;

    /**
     * @rpcname: chainHead_unstable_genesisHash
     **/
    unstable_genesisHash: AsyncMethod;

    /**
     * @rpcname: chainHead_unstable_header
     **/
    unstable_header: AsyncMethod;

    /**
     * @rpcname: chainHead_unstable_stopBody
     **/
    unstable_stopBody: AsyncMethod;

    /**
     * @rpcname: chainHead_unstable_stopCall
     **/
    unstable_stopCall: AsyncMethod;

    /**
     * @rpcname: chainHead_unstable_stopStorage
     **/
    unstable_stopStorage: AsyncMethod;

    /**
     * @rpcname: chainHead_unstable_storage
     **/
    unstable_storage: AsyncMethod;

    /**
     * @rpcname: chainHead_unstable_unfollow
     **/
    unstable_unfollow: AsyncMethod;

    /**
     * @rpcname: chainHead_unstable_unpin
     **/
    unstable_unpin: AsyncMethod;

    [method: string]: AsyncMethod;
  };
  chain: {
    /**
     * @rpcname: chain_getBlock
     **/
    getBlock: AsyncMethod;

    /**
     * @rpcname: chain_getBlockHash
     **/
    getBlockHash: AsyncMethod;

    /**
     * @rpcname: chain_getFinalisedHead
     **/
    getFinalisedHead: AsyncMethod;

    /**
     * @rpcname: chain_getFinalizedHead
     **/
    getFinalizedHead: AsyncMethod;

    /**
     * @rpcname: chain_getHead
     **/
    getHead: AsyncMethod;

    /**
     * @rpcname: chain_getHeader
     **/
    getHeader: AsyncMethod;

    /**
     * @rpcname: chain_getRuntimeVersion
     **/
    getRuntimeVersion: AsyncMethod;

    /**
     * @rpcname: chain_subscribeAllHeads
     **/
    subscribeAllHeads: AsyncMethod;

    /**
     * @rpcname: chain_subscribeFinalisedHeads
     **/
    subscribeFinalisedHeads: AsyncMethod;

    /**
     * @rpcname: chain_subscribeFinalizedHeads
     **/
    subscribeFinalizedHeads: AsyncMethod;

    /**
     * @rpcname: chain_subscribeNewHead
     **/
    subscribeNewHead: AsyncMethod;

    /**
     * @rpcname: chain_subscribeNewHeads
     **/
    subscribeNewHeads: AsyncMethod;

    /**
     * @rpcname: chain_subscribeRuntimeVersion
     **/
    subscribeRuntimeVersion: AsyncMethod;

    /**
     * @rpcname: chain_unsubscribeAllHeads
     **/
    unsubscribeAllHeads: AsyncMethod;

    /**
     * @rpcname: chain_unsubscribeFinalisedHeads
     **/
    unsubscribeFinalisedHeads: AsyncMethod;

    /**
     * @rpcname: chain_unsubscribeFinalizedHeads
     **/
    unsubscribeFinalizedHeads: AsyncMethod;

    /**
     * @rpcname: chain_unsubscribeNewHead
     **/
    unsubscribeNewHead: AsyncMethod;

    /**
     * @rpcname: chain_unsubscribeNewHeads
     **/
    unsubscribeNewHeads: AsyncMethod;

    /**
     * @rpcname: chain_unsubscribeRuntimeVersion
     **/
    unsubscribeRuntimeVersion: AsyncMethod;

    [method: string]: AsyncMethod;
  };
  childstate: {
    /**
     * @rpcname: childstate_getKeys
     **/
    getKeys: AsyncMethod;

    /**
     * @rpcname: childstate_getKeysPaged
     **/
    getKeysPaged: AsyncMethod;

    /**
     * @rpcname: childstate_getKeysPagedAt
     **/
    getKeysPagedAt: AsyncMethod;

    /**
     * @rpcname: childstate_getStorage
     **/
    getStorage: AsyncMethod;

    /**
     * @rpcname: childstate_getStorageEntries
     **/
    getStorageEntries: AsyncMethod;

    /**
     * @rpcname: childstate_getStorageHash
     **/
    getStorageHash: AsyncMethod;

    /**
     * @rpcname: childstate_getStorageSize
     **/
    getStorageSize: AsyncMethod;

    [method: string]: AsyncMethod;
  };
  eth: {
    /**
     * @rpcname: eth_accounts
     **/
    accounts: AsyncMethod;

    /**
     * @rpcname: eth_blockNumber
     **/
    blockNumber: AsyncMethod;

    /**
     * @rpcname: eth_call
     **/
    call: AsyncMethod;

    /**
     * @rpcname: eth_chainId
     **/
    chainId: AsyncMethod;

    /**
     * @rpcname: eth_coinbase
     **/
    coinbase: AsyncMethod;

    /**
     * @rpcname: eth_estimateGas
     **/
    estimateGas: AsyncMethod;

    /**
     * @rpcname: eth_feeHistory
     **/
    feeHistory: AsyncMethod;

    /**
     * @rpcname: eth_gasPrice
     **/
    gasPrice: AsyncMethod;

    /**
     * @rpcname: eth_getBalance
     **/
    getBalance: AsyncMethod;

    /**
     * @rpcname: eth_getBlockByHash
     **/
    getBlockByHash: AsyncMethod;

    /**
     * @rpcname: eth_getBlockByNumber
     **/
    getBlockByNumber: AsyncMethod;

    /**
     * @rpcname: eth_getBlockTransactionCountByHash
     **/
    getBlockTransactionCountByHash: AsyncMethod;

    /**
     * @rpcname: eth_getBlockTransactionCountByNumber
     **/
    getBlockTransactionCountByNumber: AsyncMethod;

    /**
     * @rpcname: eth_getCode
     **/
    getCode: AsyncMethod;

    /**
     * @rpcname: eth_getFilterChanges
     **/
    getFilterChanges: AsyncMethod;

    /**
     * @rpcname: eth_getFilterLogs
     **/
    getFilterLogs: AsyncMethod;

    /**
     * @rpcname: eth_getLogs
     **/
    getLogs: AsyncMethod;

    /**
     * @rpcname: eth_getStorageAt
     **/
    getStorageAt: AsyncMethod;

    /**
     * @rpcname: eth_getTransactionByBlockHashAndIndex
     **/
    getTransactionByBlockHashAndIndex: AsyncMethod;

    /**
     * @rpcname: eth_getTransactionByBlockNumberAndIndex
     **/
    getTransactionByBlockNumberAndIndex: AsyncMethod;

    /**
     * @rpcname: eth_getTransactionByHash
     **/
    getTransactionByHash: AsyncMethod;

    /**
     * @rpcname: eth_getTransactionCount
     **/
    getTransactionCount: AsyncMethod;

    /**
     * @rpcname: eth_getTransactionReceipt
     **/
    getTransactionReceipt: AsyncMethod;

    /**
     * @rpcname: eth_getUncleByBlockHashAndIndex
     **/
    getUncleByBlockHashAndIndex: AsyncMethod;

    /**
     * @rpcname: eth_getUncleByBlockNumberAndIndex
     **/
    getUncleByBlockNumberAndIndex: AsyncMethod;

    /**
     * @rpcname: eth_getUncleCountByBlockHash
     **/
    getUncleCountByBlockHash: AsyncMethod;

    /**
     * @rpcname: eth_getUncleCountByBlockNumber
     **/
    getUncleCountByBlockNumber: AsyncMethod;

    /**
     * @rpcname: eth_getWork
     **/
    getWork: AsyncMethod;

    /**
     * @rpcname: eth_hashrate
     **/
    hashrate: AsyncMethod;

    /**
     * @rpcname: eth_maxPriorityFeePerGas
     **/
    maxPriorityFeePerGas: AsyncMethod;

    /**
     * @rpcname: eth_mining
     **/
    mining: AsyncMethod;

    /**
     * @rpcname: eth_newBlockFilter
     **/
    newBlockFilter: AsyncMethod;

    /**
     * @rpcname: eth_newFilter
     **/
    newFilter: AsyncMethod;

    /**
     * @rpcname: eth_newPendingTransactionFilter
     **/
    newPendingTransactionFilter: AsyncMethod;

    /**
     * @rpcname: eth_protocolVersion
     **/
    protocolVersion: AsyncMethod;

    /**
     * @rpcname: eth_sendRawTransaction
     **/
    sendRawTransaction: AsyncMethod;

    /**
     * @rpcname: eth_sendTransaction
     **/
    sendTransaction: AsyncMethod;

    /**
     * @rpcname: eth_submitHashrate
     **/
    submitHashrate: AsyncMethod;

    /**
     * @rpcname: eth_submitWork
     **/
    submitWork: AsyncMethod;

    /**
     * @rpcname: eth_subscribe
     **/
    subscribe: AsyncMethod;

    /**
     * @rpcname: eth_syncing
     **/
    syncing: AsyncMethod;

    /**
     * @rpcname: eth_uninstallFilter
     **/
    uninstallFilter: AsyncMethod;

    /**
     * @rpcname: eth_unsubscribe
     **/
    unsubscribe: AsyncMethod;

    [method: string]: AsyncMethod;
  };
  moon: {
    /**
     * @rpcname: moon_isBlockFinalized
     **/
    isBlockFinalized: AsyncMethod;

    /**
     * @rpcname: moon_isTxFinalized
     **/
    isTxFinalized: AsyncMethod;

    [method: string]: AsyncMethod;
  };
  net: {
    /**
     * @rpcname: net_listening
     **/
    listening: AsyncMethod;

    /**
     * @rpcname: net_peerCount
     **/
    peerCount: AsyncMethod;

    /**
     * @rpcname: net_version
     **/
    version: AsyncMethod;

    [method: string]: AsyncMethod;
  };
  offchain: {
    /**
     * @rpcname: offchain_localStorageGet
     **/
    localStorageGet: AsyncMethod;

    /**
     * @rpcname: offchain_localStorageSet
     **/
    localStorageSet: AsyncMethod;

    [method: string]: AsyncMethod;
  };
  payment: {
    /**
     * @rpcname: payment_queryFeeDetails
     **/
    queryFeeDetails: AsyncMethod;

    /**
     * @rpcname: payment_queryInfo
     **/
    queryInfo: AsyncMethod;

    [method: string]: AsyncMethod;
  };
  rpc: {
    /**
     * Retrieves the list of RPC methods that are exposed by the node
     *
     * @rpcname: rpc_methods
     **/
    methods(): Promise<RpcMethods>;

    [method: string]: AsyncMethod;
  };
  state: {
    /**
     * @rpcname: state_call
     **/
    call: AsyncMethod;

    /**
     * @rpcname: state_callAt
     **/
    callAt: AsyncMethod;

    /**
     * @rpcname: state_getChildReadProof
     **/
    getChildReadProof: AsyncMethod;

    /**
     * @rpcname: state_getKeys
     **/
    getKeys: AsyncMethod;

    /**
     * @rpcname: state_getKeysPaged
     **/
    getKeysPaged: AsyncMethod;

    /**
     * @rpcname: state_getKeysPagedAt
     **/
    getKeysPagedAt: AsyncMethod;

    /**
     * Returns the runtime metadata
     *
     * @rpcname: state_getMetadata
     **/
    getMetadata(at?: BlockHash): Promise<Metadata>;

    /**
     * @rpcname: state_getPairs
     **/
    getPairs: AsyncMethod;

    /**
     * @rpcname: state_getReadProof
     **/
    getReadProof: AsyncMethod;

    /**
     * @rpcname: state_getRuntimeVersion
     **/
    getRuntimeVersion: AsyncMethod;

    /**
     * @rpcname: state_getStorage
     **/
    getStorage: AsyncMethod;

    /**
     * @rpcname: state_getStorageAt
     **/
    getStorageAt: AsyncMethod;

    /**
     * @rpcname: state_getStorageHash
     **/
    getStorageHash: AsyncMethod;

    /**
     * @rpcname: state_getStorageHashAt
     **/
    getStorageHashAt: AsyncMethod;

    /**
     * @rpcname: state_getStorageSize
     **/
    getStorageSize: AsyncMethod;

    /**
     * @rpcname: state_getStorageSizeAt
     **/
    getStorageSizeAt: AsyncMethod;

    /**
     * @rpcname: state_queryStorage
     **/
    queryStorage: AsyncMethod;

    /**
     * @rpcname: state_queryStorageAt
     **/
    queryStorageAt: AsyncMethod;

    /**
     * @rpcname: state_subscribeRuntimeVersion
     **/
    subscribeRuntimeVersion: AsyncMethod;

    /**
     * @rpcname: state_subscribeStorage
     **/
    subscribeStorage: AsyncMethod;

    /**
     * @rpcname: state_traceBlock
     **/
    traceBlock: AsyncMethod;

    /**
     * @rpcname: state_unsubscribeRuntimeVersion
     **/
    unsubscribeRuntimeVersion: AsyncMethod;

    /**
     * @rpcname: state_unsubscribeStorage
     **/
    unsubscribeStorage: AsyncMethod;

    [method: string]: AsyncMethod;
  };
  subscribe: {
    /**
     * @rpcname: subscribe_newHead
     **/
    newHead: AsyncMethod;

    [method: string]: AsyncMethod;
  };
  system: {
    /**
     * Returns the next valid index (aka nonce) for given account.
     *
     * This method takes into consideration all pending transactions
     * currently in the pool and if no transactions are found in the pool
     * it fallbacks to query the index from the runtime (aka. state nonce).
     *
     * @rpcname: system_accountNextIndex
     **/
    accountNextIndex(accountId: AccountId): Promise<number>;

    /**
     * Adds the supplied directives to the current log filter
     *
     * The syntax is identical to the CLI `<target>=<level>`:
     *
     * `sync=debug,state=trace`
     *
     * @rpcname: system_addLogFilter
     **/
    addLogFilter(directives: string): Promise<void>;

    /**
     * Adds a reserved peer. Returns the empty string or an error. The string
     * parameter should encode a `p2p` multiaddr.
     *
     * `/ip4/198.51.100.19/tcp/30333/p2p/QmSk5HQbn6LhUwDiNMseVUjuRYhEtYj4aUZ6WfWoGURpdV`
     * is an example of a valid, passing multiaddr with PeerId attached.
     *
     * @rpcname: system_addReservedPeer
     **/
    addReservedPeer(peer: string): Promise<void>;

    /**
     * Get the chain's name. Given as a string identifier.
     *
     * @rpcname: system_chain
     **/
    chain(): Promise<string>;

    /**
     * Get the chain's type.
     *
     * @rpcname: system_chainType
     **/
    chainType(): Promise<ChainType>;

    /**
     * Dry run an extrinsic at a given block. Return SCALE encoded ApplyExtrinsicResult.
     *
     * @rpcname: system_dryRun
     **/
    dryRun(extrinsic: Bytes, at?: BlockHash): Promise<Bytes>;

    /**
     * Return health status of the node.
     *
     * Node is considered healthy if it is:
     * - connected to some peers (unless running in dev mode)
     * - not performing a major sync
     *
     * @rpcname: system_health
     **/
    health(): Promise<Health>;

    /**
     * Returns the multi-addresses that the local node is listening on
     *
     * The addresses include a trailing `/p2p/` with the local PeerId, and are thus suitable to
     * be passed to `addReservedPeer` or as a bootnode address for example.
     *
     * @rpcname: system_localListenAddresses
     **/
    localListenAddresses(): Promise<Array<string>>;

    /**
     * Returns the base58-encoded PeerId of the node.
     *
     * @rpcname: system_localPeerId
     **/
    localPeerId(): Promise<string>;

    /**
     * Get the node's implementation name. Plain old string.
     *
     * @rpcname: system_name
     **/
    name(): Promise<string>;

    /**
     * Returns the roles the node is running as
     *
     * @rpcname: system_nodeRoles
     **/
    nodeRoles(): Promise<Array<NodeRole>>;

    /**
     * Returns the currently connected peers
     *
     * @rpcname: system_peers
     **/
    peers(): Promise<Array<PeerInfo>>;

    /**
     * Get a custom set of properties as a JSON object, defined in the chain spec.
     *
     * @rpcname: system_properties
     **/
    properties(): Promise<ChainProperties>;

    /**
     * Remove a reserved peer. Returns the empty string or an error. The string
     * should encode only the PeerId e.g. `QmSk5HQbn6LhUwDiNMseVUjuRYhEtYj4aUZ6WfWoGURpdV`.
     *
     * @rpcname: system_removeReservedPeer
     **/
    removeReservedPeer(peerId: string): Promise<void>;

    /**
     * Returns the list of reserved peers
     *
     * @rpcname: system_reservedPeers
     **/
    reservedPeers(): Promise<Array<string>>;

    /**
     * Resets the log filter to Substrate defaults
     *
     * @rpcname: system_resetLogFilter
     **/
    resetLogFilter(): Promise<void>;

    /**
     * Returns the state of the syncing of the node: starting block, current best block, highest known block.
     *
     * @rpcname: system_syncState
     **/
    syncState(): Promise<SyncState>;

    /**
     * Returns current state of the network.
     *
     * **Warning**: This API is not stable. Please do not programmatically interpret its output,
     * as its format might change at any time.
     *
     * @rpcname: system_unstable_networkState
     **/
    unstable_networkState(): Promise<NetworkState>;

    /**
     * Get the node implementation's version. Should be a semver string.
     *
     * @rpcname: system_version
     **/
    version(): Promise<string>;

    [method: string]: AsyncMethod;
  };
  transaction: {
    /**
     * @rpcname: transaction_unstable_submitAndWatch
     **/
    unstable_submitAndWatch: AsyncMethod;

    /**
     * @rpcname: transaction_unstable_unwatch
     **/
    unstable_unwatch: AsyncMethod;

    [method: string]: AsyncMethod;
  };
  unsubscribe: {
    /**
     * @rpcname: unsubscribe_newHead
     **/
    newHead: AsyncMethod;

    [method: string]: AsyncMethod;
  };
  web3: {
    /**
     * @rpcname: web3_clientVersion
     **/
    clientVersion: AsyncMethod;

    /**
     * @rpcname: web3_sha3
     **/
    sha3: AsyncMethod;

    [method: string]: AsyncMethod;
  };
}
