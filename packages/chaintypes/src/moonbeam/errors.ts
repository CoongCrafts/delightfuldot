// Generated by @delightfuldot/codegen

import type { GenericChainErrors, GenericModuleError } from '@delightfuldot/types';

export interface ChainErrors extends GenericChainErrors {
  system: {
    /**
     * The name of specification does not match between the current runtime
     * and the new runtime.
     **/
    invalidSpecName: GenericModuleError;

    /**
     * The specification version is not allowed to decrease between the current runtime
     * and the new runtime.
     **/
    specVersionNeedsToIncrease: GenericModuleError;

    /**
     * Failed to extract the runtime version from the new runtime.
     *
     * Either calling `Core_version` or decoding `RuntimeVersion` failed.
     **/
    failedToExtractRuntimeVersion: GenericModuleError;

    /**
     * Suicide called when the account has non-default composite data.
     **/
    nonDefaultComposite: GenericModuleError;

    /**
     * There is a non-zero reference count preventing the account from being purged.
     **/
    nonZeroRefCount: GenericModuleError;

    /**
     * The origin filter prevent the call to be dispatched.
     **/
    callFiltered: GenericModuleError;
  };
  parachainSystem: {
    /**
     * Attempt to upgrade validation function while existing upgrade pending.
     **/
    overlappingUpgrades: GenericModuleError;

    /**
     * Polkadot currently prohibits this parachain from upgrading its validation function.
     **/
    prohibitedByPolkadot: GenericModuleError;

    /**
     * The supplied validation function has compiled into a blob larger than Polkadot is
     * willing to run.
     **/
    tooBig: GenericModuleError;

    /**
     * The inherent which supplies the validation data did not run this block.
     **/
    validationDataNotAvailable: GenericModuleError;

    /**
     * The inherent which supplies the host configuration did not run this block.
     **/
    hostConfigurationNotAvailable: GenericModuleError;

    /**
     * No validation function upgrade is currently scheduled.
     **/
    notScheduled: GenericModuleError;

    /**
     * No code upgrade has been authorized.
     **/
    nothingAuthorized: GenericModuleError;

    /**
     * The given code upgrade has not been authorized.
     **/
    unauthorized: GenericModuleError;
  };
  balances: {
    /**
     * Vesting balance too high to send value.
     **/
    vestingBalance: GenericModuleError;

    /**
     * Account liquidity restrictions prevent withdrawal.
     **/
    liquidityRestrictions: GenericModuleError;

    /**
     * Balance too low to send value.
     **/
    insufficientBalance: GenericModuleError;

    /**
     * Value too low to create account due to existential deposit.
     **/
    existentialDeposit: GenericModuleError;

    /**
     * Transfer/payment would kill account.
     **/
    expendability: GenericModuleError;

    /**
     * A vesting schedule already exists for this account.
     **/
    existingVestingSchedule: GenericModuleError;

    /**
     * Beneficiary account must pre-exist.
     **/
    deadAccount: GenericModuleError;

    /**
     * Number of named reserves exceed `MaxReserves`.
     **/
    tooManyReserves: GenericModuleError;

    /**
     * Number of holds exceed `MaxHolds`.
     **/
    tooManyHolds: GenericModuleError;

    /**
     * Number of freezes exceed `MaxFreezes`.
     **/
    tooManyFreezes: GenericModuleError;
  };
  parachainStaking: {
    delegatorDNE: GenericModuleError;
    delegatorDNEinTopNorBottom: GenericModuleError;
    delegatorDNEInDelegatorSet: GenericModuleError;
    candidateDNE: GenericModuleError;
    delegationDNE: GenericModuleError;
    delegatorExists: GenericModuleError;
    candidateExists: GenericModuleError;
    candidateBondBelowMin: GenericModuleError;
    insufficientBalance: GenericModuleError;
    delegatorBondBelowMin: GenericModuleError;
    delegationBelowMin: GenericModuleError;
    alreadyOffline: GenericModuleError;
    alreadyActive: GenericModuleError;
    delegatorAlreadyLeaving: GenericModuleError;
    delegatorNotLeaving: GenericModuleError;
    delegatorCannotLeaveYet: GenericModuleError;
    cannotDelegateIfLeaving: GenericModuleError;
    candidateAlreadyLeaving: GenericModuleError;
    candidateNotLeaving: GenericModuleError;
    candidateCannotLeaveYet: GenericModuleError;
    cannotGoOnlineIfLeaving: GenericModuleError;
    exceedMaxDelegationsPerDelegator: GenericModuleError;
    alreadyDelegatedCandidate: GenericModuleError;
    invalidSchedule: GenericModuleError;
    cannotSetBelowMin: GenericModuleError;
    roundLengthMustBeGreaterThanTotalSelectedCollators: GenericModuleError;
    noWritingSameValue: GenericModuleError;
    tooLowCandidateCountWeightHintJoinCandidates: GenericModuleError;
    tooLowCandidateCountWeightHintCancelLeaveCandidates: GenericModuleError;
    tooLowCandidateCountToLeaveCandidates: GenericModuleError;
    tooLowDelegationCountToDelegate: GenericModuleError;
    tooLowCandidateDelegationCountToDelegate: GenericModuleError;
    tooLowCandidateDelegationCountToLeaveCandidates: GenericModuleError;
    tooLowDelegationCountToLeaveDelegators: GenericModuleError;
    pendingCandidateRequestsDNE: GenericModuleError;
    pendingCandidateRequestAlreadyExists: GenericModuleError;
    pendingCandidateRequestNotDueYet: GenericModuleError;
    pendingDelegationRequestDNE: GenericModuleError;
    pendingDelegationRequestAlreadyExists: GenericModuleError;
    pendingDelegationRequestNotDueYet: GenericModuleError;
    cannotDelegateLessThanOrEqualToLowestBottomWhenFull: GenericModuleError;
    pendingDelegationRevoke: GenericModuleError;
    tooLowDelegationCountToAutoCompound: GenericModuleError;
    tooLowCandidateAutoCompoundingDelegationCountToAutoCompound: GenericModuleError;
    tooLowCandidateAutoCompoundingDelegationCountToDelegate: GenericModuleError;
    tooLowCandidateAutoCompoundingDelegationCountToLeaveCandidates: GenericModuleError;
    tooLowCandidateCountWeightHint: GenericModuleError;
    tooLowCandidateCountWeightHintGoOffline: GenericModuleError;
    candidateLimitReached: GenericModuleError;
    cannotSetAboveMaxCandidates: GenericModuleError;
    removedCall: GenericModuleError;
  };
  authorInherent: {
    /**
     * Author already set in block.
     **/
    authorAlreadySet: GenericModuleError;

    /**
     * No AccountId was found to be associated with this author
     **/
    noAccountId: GenericModuleError;

    /**
     * The author in the inherent is not an eligible author.
     **/
    cannotBeAuthor: GenericModuleError;
  };
  authorMapping: {
    /**
     * The association can't be cleared because it is not found.
     **/
    associationNotFound: GenericModuleError;

    /**
     * The association can't be cleared because it belongs to another account.
     **/
    notYourAssociation: GenericModuleError;

    /**
     * This account cannot set an author because it cannon afford the security deposit
     **/
    cannotAffordSecurityDeposit: GenericModuleError;

    /**
     * The NimbusId in question is already associated and cannot be overwritten
     **/
    alreadyAssociated: GenericModuleError;

    /**
     * No existing NimbusId can be found for the account
     **/
    oldAuthorIdNotFound: GenericModuleError;

    /**
     * Keys have wrong size
     **/
    wrongKeySize: GenericModuleError;

    /**
     * Failed to decode NimbusId for `set_keys`
     **/
    decodeNimbusFailed: GenericModuleError;

    /**
     * Failed to decode T::Keys for `set_keys`
     **/
    decodeKeysFailed: GenericModuleError;
  };
  moonbeamOrbiters: {
    /**
     * The collator is already added in orbiters program.
     **/
    collatorAlreadyAdded: GenericModuleError;

    /**
     * This collator is not in orbiters program.
     **/
    collatorNotFound: GenericModuleError;

    /**
     * There are already too many orbiters associated with this collator.
     **/
    collatorPoolTooLarge: GenericModuleError;

    /**
     * There are more collator pools than the number specified in the parameter.
     **/
    collatorsPoolCountTooLow: GenericModuleError;

    /**
     * The minimum deposit required to register as an orbiter has not yet been included in the
     * onchain storage
     **/
    minOrbiterDepositNotSet: GenericModuleError;

    /**
     * This orbiter is already associated with this collator.
     **/
    orbiterAlreadyInPool: GenericModuleError;

    /**
     * This orbiter has not made a deposit
     **/
    orbiterDepositNotFound: GenericModuleError;

    /**
     * This orbiter is not found
     **/
    orbiterNotFound: GenericModuleError;

    /**
     * The orbiter is still at least in one pool
     **/
    orbiterStillInAPool: GenericModuleError;
  };
  utility: {
    /**
     * Too many calls batched.
     **/
    tooManyCalls: GenericModuleError;
  };
  proxy: {
    /**
     * There are too many proxies registered or too many announcements pending.
     **/
    tooMany: GenericModuleError;

    /**
     * Proxy registration not found.
     **/
    notFound: GenericModuleError;

    /**
     * Sender is not a proxy of the account to be proxied.
     **/
    notProxy: GenericModuleError;

    /**
     * A call which is incompatible with the proxy type's filter was attempted.
     **/
    unproxyable: GenericModuleError;

    /**
     * Account is already a proxy.
     **/
    duplicate: GenericModuleError;

    /**
     * Call may not be made by proxy because it may escalate its privileges.
     **/
    noPermission: GenericModuleError;

    /**
     * Announcement, if made at all, was made too recently.
     **/
    unannounced: GenericModuleError;

    /**
     * Cannot add self as proxy.
     **/
    noSelfProxy: GenericModuleError;
  };
  maintenanceMode: {
    /**
     * The chain cannot enter maintenance mode because it is already in maintenance mode
     **/
    alreadyInMaintenanceMode: GenericModuleError;

    /**
     * The chain cannot resume normal operation because it is not in maintenance mode
     **/
    notInMaintenanceMode: GenericModuleError;
  };
  identity: {
    /**
     * Too many subs-accounts.
     **/
    tooManySubAccounts: GenericModuleError;

    /**
     * Account isn't found.
     **/
    notFound: GenericModuleError;

    /**
     * Account isn't named.
     **/
    notNamed: GenericModuleError;

    /**
     * Empty index.
     **/
    emptyIndex: GenericModuleError;

    /**
     * Fee is changed.
     **/
    feeChanged: GenericModuleError;

    /**
     * No identity found.
     **/
    noIdentity: GenericModuleError;

    /**
     * Sticky judgement.
     **/
    stickyJudgement: GenericModuleError;

    /**
     * Judgement given.
     **/
    judgementGiven: GenericModuleError;

    /**
     * Invalid judgement.
     **/
    invalidJudgement: GenericModuleError;

    /**
     * The index is invalid.
     **/
    invalidIndex: GenericModuleError;

    /**
     * The target is invalid.
     **/
    invalidTarget: GenericModuleError;

    /**
     * Too many additional fields.
     **/
    tooManyFields: GenericModuleError;

    /**
     * Maximum amount of registrars reached. Cannot add any more.
     **/
    tooManyRegistrars: GenericModuleError;

    /**
     * Account ID is already named.
     **/
    alreadyClaimed: GenericModuleError;

    /**
     * Sender is not a sub-account.
     **/
    notSub: GenericModuleError;

    /**
     * Sub-account isn't owned by sender.
     **/
    notOwned: GenericModuleError;

    /**
     * The provided judgement was for a different identity.
     **/
    judgementForDifferentIdentity: GenericModuleError;

    /**
     * Error that occurs when there is an issue paying for judgement.
     **/
    judgementPaymentFailed: GenericModuleError;
  };
  migrations: {
    /**
     * Missing preimage in original democracy storage
     **/
    preimageMissing: GenericModuleError;

    /**
     * Provided upper bound is too low.
     **/
    wrongUpperBound: GenericModuleError;

    /**
     * Preimage is larger than the new max size.
     **/
    preimageIsTooBig: GenericModuleError;

    /**
     * Preimage already exists in the new storage.
     **/
    preimageAlreadyExists: GenericModuleError;
  };
  multisig: {
    /**
     * Threshold must be 2 or greater.
     **/
    minimumThreshold: GenericModuleError;

    /**
     * Call is already approved by this signatory.
     **/
    alreadyApproved: GenericModuleError;

    /**
     * Call doesn't need any (more) approvals.
     **/
    noApprovalsNeeded: GenericModuleError;

    /**
     * There are too few signatories in the list.
     **/
    tooFewSignatories: GenericModuleError;

    /**
     * There are too many signatories in the list.
     **/
    tooManySignatories: GenericModuleError;

    /**
     * The signatories were provided out of order; they should be ordered.
     **/
    signatoriesOutOfOrder: GenericModuleError;

    /**
     * The sender was contained in the other signatories; it shouldn't be.
     **/
    senderInSignatories: GenericModuleError;

    /**
     * Multisig operation not found when attempting to cancel.
     **/
    notFound: GenericModuleError;

    /**
     * Only the account that originally created the multisig is able to cancel it.
     **/
    notOwner: GenericModuleError;

    /**
     * No timepoint was given, yet the multisig operation is already underway.
     **/
    noTimepoint: GenericModuleError;

    /**
     * A different timepoint was given to the multisig operation that is underway.
     **/
    wrongTimepoint: GenericModuleError;

    /**
     * A timepoint was given, yet no multisig operation is underway.
     **/
    unexpectedTimepoint: GenericModuleError;

    /**
     * The maximum weight information provided was too low.
     **/
    maxWeightTooLow: GenericModuleError;

    /**
     * The data to be stored is already stored.
     **/
    alreadyStored: GenericModuleError;
  };
  evm: {
    /**
     * Not enough balance to perform action
     **/
    balanceLow: GenericModuleError;

    /**
     * Calculating total fee overflowed
     **/
    feeOverflow: GenericModuleError;

    /**
     * Calculating total payment overflowed
     **/
    paymentOverflow: GenericModuleError;

    /**
     * Withdraw fee failed
     **/
    withdrawFailed: GenericModuleError;

    /**
     * Gas price is too low.
     **/
    gasPriceTooLow: GenericModuleError;

    /**
     * Nonce is invalid
     **/
    invalidNonce: GenericModuleError;

    /**
     * Gas limit is too low.
     **/
    gasLimitTooLow: GenericModuleError;

    /**
     * Gas limit is too high.
     **/
    gasLimitTooHigh: GenericModuleError;

    /**
     * Undefined error.
     **/
    undefined: GenericModuleError;

    /**
     * EVM reentrancy
     **/
    reentrancy: GenericModuleError;

    /**
     * EIP-3607,
     **/
    transactionMustComeFromEOA: GenericModuleError;
  };
  ethereum: {
    /**
     * Signature is invalid.
     **/
    invalidSignature: GenericModuleError;

    /**
     * Pre-log is present, therefore transact is not allowed.
     **/
    preLogExists: GenericModuleError;
  };
  scheduler: {
    /**
     * Failed to schedule a call
     **/
    failedToSchedule: GenericModuleError;

    /**
     * Cannot find the scheduled call.
     **/
    notFound: GenericModuleError;

    /**
     * Given target block number is in the past.
     **/
    targetBlockNumberInPast: GenericModuleError;

    /**
     * Reschedule failed because it does not change scheduled time.
     **/
    rescheduleNoChange: GenericModuleError;

    /**
     * Attempt to use a non-named function on a named task.
     **/
    named: GenericModuleError;
  };
  democracy: {
    /**
     * Value too low
     **/
    valueLow: GenericModuleError;

    /**
     * Proposal does not exist
     **/
    proposalMissing: GenericModuleError;

    /**
     * Cannot cancel the same proposal twice
     **/
    alreadyCanceled: GenericModuleError;

    /**
     * Proposal already made
     **/
    duplicateProposal: GenericModuleError;

    /**
     * Proposal still blacklisted
     **/
    proposalBlacklisted: GenericModuleError;

    /**
     * Next external proposal not simple majority
     **/
    notSimpleMajority: GenericModuleError;

    /**
     * Invalid hash
     **/
    invalidHash: GenericModuleError;

    /**
     * No external proposal
     **/
    noProposal: GenericModuleError;

    /**
     * Identity may not veto a proposal twice
     **/
    alreadyVetoed: GenericModuleError;

    /**
     * Vote given for invalid referendum
     **/
    referendumInvalid: GenericModuleError;

    /**
     * No proposals waiting
     **/
    noneWaiting: GenericModuleError;

    /**
     * The given account did not vote on the referendum.
     **/
    notVoter: GenericModuleError;

    /**
     * The actor has no permission to conduct the action.
     **/
    noPermission: GenericModuleError;

    /**
     * The account is already delegating.
     **/
    alreadyDelegating: GenericModuleError;

    /**
     * Too high a balance was provided that the account cannot afford.
     **/
    insufficientFunds: GenericModuleError;

    /**
     * The account is not currently delegating.
     **/
    notDelegating: GenericModuleError;

    /**
     * The account currently has votes attached to it and the operation cannot succeed until
     * these are removed, either through `unvote` or `reap_vote`.
     **/
    votesExist: GenericModuleError;

    /**
     * The instant referendum origin is currently disallowed.
     **/
    instantNotAllowed: GenericModuleError;

    /**
     * Delegation to oneself makes no sense.
     **/
    nonsense: GenericModuleError;

    /**
     * Invalid upper bound.
     **/
    wrongUpperBound: GenericModuleError;

    /**
     * Maximum number of votes reached.
     **/
    maxVotesReached: GenericModuleError;

    /**
     * Maximum number of items reached.
     **/
    tooMany: GenericModuleError;

    /**
     * Voting period too low
     **/
    votingPeriodLow: GenericModuleError;

    /**
     * The preimage does not exist.
     **/
    preimageNotExist: GenericModuleError;
  };
  preimage: {
    /**
     * Preimage is too large to store on-chain.
     **/
    tooBig: GenericModuleError;

    /**
     * Preimage has already been noted on-chain.
     **/
    alreadyNoted: GenericModuleError;

    /**
     * The user is not authorized to perform this action.
     **/
    notAuthorized: GenericModuleError;

    /**
     * The preimage cannot be removed since it has not yet been noted.
     **/
    notNoted: GenericModuleError;

    /**
     * A preimage may not be removed when there are outstanding requests.
     **/
    requested: GenericModuleError;

    /**
     * The preimage request cannot be removed since no outstanding requests exist.
     **/
    notRequested: GenericModuleError;
  };
  convictionVoting: {
    /**
     * Poll is not ongoing.
     **/
    notOngoing: GenericModuleError;

    /**
     * The given account did not vote on the poll.
     **/
    notVoter: GenericModuleError;

    /**
     * The actor has no permission to conduct the action.
     **/
    noPermission: GenericModuleError;

    /**
     * The actor has no permission to conduct the action right now but will do in the future.
     **/
    noPermissionYet: GenericModuleError;

    /**
     * The account is already delegating.
     **/
    alreadyDelegating: GenericModuleError;

    /**
     * The account currently has votes attached to it and the operation cannot succeed until
     * these are removed, either through `unvote` or `reap_vote`.
     **/
    alreadyVoting: GenericModuleError;

    /**
     * Too high a balance was provided that the account cannot afford.
     **/
    insufficientFunds: GenericModuleError;

    /**
     * The account is not currently delegating.
     **/
    notDelegating: GenericModuleError;

    /**
     * Delegation to oneself makes no sense.
     **/
    nonsense: GenericModuleError;

    /**
     * Maximum number of votes reached.
     **/
    maxVotesReached: GenericModuleError;

    /**
     * The class must be supplied since it is not easily determinable from the state.
     **/
    classNeeded: GenericModuleError;

    /**
     * The class ID supplied is invalid.
     **/
    badClass: GenericModuleError;
  };
  referenda: {
    /**
     * Referendum is not ongoing.
     **/
    notOngoing: GenericModuleError;

    /**
     * Referendum's decision deposit is already paid.
     **/
    hasDeposit: GenericModuleError;

    /**
     * The track identifier given was invalid.
     **/
    badTrack: GenericModuleError;

    /**
     * There are already a full complement of referenda in progress for this track.
     **/
    full: GenericModuleError;

    /**
     * The queue of the track is empty.
     **/
    queueEmpty: GenericModuleError;

    /**
     * The referendum index provided is invalid in this context.
     **/
    badReferendum: GenericModuleError;

    /**
     * There was nothing to do in the advancement.
     **/
    nothingToDo: GenericModuleError;

    /**
     * No track exists for the proposal origin.
     **/
    noTrack: GenericModuleError;

    /**
     * Any deposit cannot be refunded until after the decision is over.
     **/
    unfinished: GenericModuleError;

    /**
     * The deposit refunder is not the depositor.
     **/
    noPermission: GenericModuleError;

    /**
     * The deposit cannot be refunded since none was made.
     **/
    noDeposit: GenericModuleError;

    /**
     * The referendum status is invalid for this operation.
     **/
    badStatus: GenericModuleError;

    /**
     * The preimage does not exist.
     **/
    preimageNotExist: GenericModuleError;
  };
  whitelist: {
    /**
     * The preimage of the call hash could not be loaded.
     **/
    unavailablePreImage: GenericModuleError;

    /**
     * The call could not be decoded.
     **/
    undecodableCall: GenericModuleError;

    /**
     * The weight of the decoded call was higher than the witness.
     **/
    invalidCallWeightWitness: GenericModuleError;

    /**
     * The call was not whitelisted.
     **/
    callIsNotWhitelisted: GenericModuleError;

    /**
     * The call was already whitelisted; No-Op.
     **/
    callAlreadyWhitelisted: GenericModuleError;
  };
  councilCollective: {
    /**
     * Account is not a member
     **/
    notMember: GenericModuleError;

    /**
     * Duplicate proposals not allowed
     **/
    duplicateProposal: GenericModuleError;

    /**
     * Proposal must exist
     **/
    proposalMissing: GenericModuleError;

    /**
     * Mismatched index
     **/
    wrongIndex: GenericModuleError;

    /**
     * Duplicate vote ignored
     **/
    duplicateVote: GenericModuleError;

    /**
     * Members are already initialized!
     **/
    alreadyInitialized: GenericModuleError;

    /**
     * The close call was made too early, before the end of the voting.
     **/
    tooEarly: GenericModuleError;

    /**
     * There can only be a maximum of `MaxProposals` active proposals.
     **/
    tooManyProposals: GenericModuleError;

    /**
     * The given weight bound for the proposal was too low.
     **/
    wrongProposalWeight: GenericModuleError;

    /**
     * The given length bound for the proposal was too low.
     **/
    wrongProposalLength: GenericModuleError;
  };
  techCommitteeCollective: {
    /**
     * Account is not a member
     **/
    notMember: GenericModuleError;

    /**
     * Duplicate proposals not allowed
     **/
    duplicateProposal: GenericModuleError;

    /**
     * Proposal must exist
     **/
    proposalMissing: GenericModuleError;

    /**
     * Mismatched index
     **/
    wrongIndex: GenericModuleError;

    /**
     * Duplicate vote ignored
     **/
    duplicateVote: GenericModuleError;

    /**
     * Members are already initialized!
     **/
    alreadyInitialized: GenericModuleError;

    /**
     * The close call was made too early, before the end of the voting.
     **/
    tooEarly: GenericModuleError;

    /**
     * There can only be a maximum of `MaxProposals` active proposals.
     **/
    tooManyProposals: GenericModuleError;

    /**
     * The given weight bound for the proposal was too low.
     **/
    wrongProposalWeight: GenericModuleError;

    /**
     * The given length bound for the proposal was too low.
     **/
    wrongProposalLength: GenericModuleError;
  };
  treasuryCouncilCollective: {
    /**
     * Account is not a member
     **/
    notMember: GenericModuleError;

    /**
     * Duplicate proposals not allowed
     **/
    duplicateProposal: GenericModuleError;

    /**
     * Proposal must exist
     **/
    proposalMissing: GenericModuleError;

    /**
     * Mismatched index
     **/
    wrongIndex: GenericModuleError;

    /**
     * Duplicate vote ignored
     **/
    duplicateVote: GenericModuleError;

    /**
     * Members are already initialized!
     **/
    alreadyInitialized: GenericModuleError;

    /**
     * The close call was made too early, before the end of the voting.
     **/
    tooEarly: GenericModuleError;

    /**
     * There can only be a maximum of `MaxProposals` active proposals.
     **/
    tooManyProposals: GenericModuleError;

    /**
     * The given weight bound for the proposal was too low.
     **/
    wrongProposalWeight: GenericModuleError;

    /**
     * The given length bound for the proposal was too low.
     **/
    wrongProposalLength: GenericModuleError;
  };
  openTechCommitteeCollective: {
    /**
     * Account is not a member
     **/
    notMember: GenericModuleError;

    /**
     * Duplicate proposals not allowed
     **/
    duplicateProposal: GenericModuleError;

    /**
     * Proposal must exist
     **/
    proposalMissing: GenericModuleError;

    /**
     * Mismatched index
     **/
    wrongIndex: GenericModuleError;

    /**
     * Duplicate vote ignored
     **/
    duplicateVote: GenericModuleError;

    /**
     * Members are already initialized!
     **/
    alreadyInitialized: GenericModuleError;

    /**
     * The close call was made too early, before the end of the voting.
     **/
    tooEarly: GenericModuleError;

    /**
     * There can only be a maximum of `MaxProposals` active proposals.
     **/
    tooManyProposals: GenericModuleError;

    /**
     * The given weight bound for the proposal was too low.
     **/
    wrongProposalWeight: GenericModuleError;

    /**
     * The given length bound for the proposal was too low.
     **/
    wrongProposalLength: GenericModuleError;
  };
  treasury: {
    /**
     * Proposer's balance is too low.
     **/
    insufficientProposersBalance: GenericModuleError;

    /**
     * No proposal or bounty at that index.
     **/
    invalidIndex: GenericModuleError;

    /**
     * Too many approvals in the queue.
     **/
    tooManyApprovals: GenericModuleError;

    /**
     * The spend origin is valid but the amount it is allowed to spend is lower than the
     * amount to be spent.
     **/
    insufficientPermission: GenericModuleError;

    /**
     * Proposal has not been approved.
     **/
    proposalNotApproved: GenericModuleError;
  };
  crowdloanRewards: {
    /**
     * User trying to associate a native identity with a relay chain identity for posterior
     * reward claiming provided an already associated relay chain identity
     **/
    alreadyAssociated: GenericModuleError;

    /**
     * Trying to introduce a batch that goes beyond the limits of the funds
     **/
    batchBeyondFundPot: GenericModuleError;

    /**
     * First claim already done
     **/
    firstClaimAlreadyDone: GenericModuleError;

    /**
     * The contribution is not high enough to be eligible for rewards
     **/
    rewardNotHighEnough: GenericModuleError;

    /**
     * User trying to associate a native identity with a relay chain identity for posterior
     * reward claiming provided a wrong signature
     **/
    invalidClaimSignature: GenericModuleError;

    /**
     * User trying to claim the first free reward provided the wrong signature
     **/
    invalidFreeClaimSignature: GenericModuleError;

    /**
     * User trying to claim an award did not have an claim associated with it. This may mean
     * they did not contribute to the crowdloan, or they have not yet associated a native id
     * with their contribution
     **/
    noAssociatedClaim: GenericModuleError;

    /**
     * User trying to claim rewards has already claimed all rewards associated with its
     * identity and contribution
     **/
    rewardsAlreadyClaimed: GenericModuleError;

    /**
     * Reward vec has already been initialized
     **/
    rewardVecAlreadyInitialized: GenericModuleError;

    /**
     * Reward vec has not yet been fully initialized
     **/
    rewardVecNotFullyInitializedYet: GenericModuleError;

    /**
     * Rewards should match funds of the pallet
     **/
    rewardsDoNotMatchFund: GenericModuleError;

    /**
     * Initialize_reward_vec received too many contributors
     **/
    tooManyContributors: GenericModuleError;

    /**
     * Provided vesting period is not valid
     **/
    vestingPeriodNonValid: GenericModuleError;

    /**
     * User provided a signature from a non-contributor relay account
     **/
    nonContributedAddressProvided: GenericModuleError;

    /**
     * User submitted an unsifficient number of proofs to change the reward address
     **/
    insufficientNumberOfValidProofs: GenericModuleError;
  };
  xcmpQueue: {
    /**
     * Failed to send XCM message.
     **/
    failedToSend: GenericModuleError;

    /**
     * Bad XCM origin.
     **/
    badXcmOrigin: GenericModuleError;

    /**
     * Bad XCM data.
     **/
    badXcm: GenericModuleError;

    /**
     * Bad overweight index.
     **/
    badOverweightIndex: GenericModuleError;

    /**
     * Provided weight is possibly not enough to execute the message.
     **/
    weightOverLimit: GenericModuleError;
  };
  cumulusXcm: {};
  dmpQueue: {
    /**
     * The message index given is unknown.
     **/
    unknown: GenericModuleError;

    /**
     * The amount of weight given is possibly not enough for executing the message.
     **/
    overLimit: GenericModuleError;
  };
  polkadotXcm: {
    /**
     * The desired destination was unreachable, generally because there is a no way of routing
     * to it.
     **/
    unreachable: GenericModuleError;

    /**
     * There was some other issue (i.e. not to do with routing) in sending the message. Perhaps
     * a lack of space for buffering the message.
     **/
    sendFailure: GenericModuleError;

    /**
     * The message execution fails the filter.
     **/
    filtered: GenericModuleError;

    /**
     * The message's weight could not be determined.
     **/
    unweighableMessage: GenericModuleError;

    /**
     * The destination `MultiLocation` provided cannot be inverted.
     **/
    destinationNotInvertible: GenericModuleError;

    /**
     * The assets to be sent are empty.
     **/
    empty: GenericModuleError;

    /**
     * Could not re-anchor the assets to declare the fees for the destination chain.
     **/
    cannotReanchor: GenericModuleError;

    /**
     * Too many assets have been attempted for transfer.
     **/
    tooManyAssets: GenericModuleError;

    /**
     * Origin is invalid for sending.
     **/
    invalidOrigin: GenericModuleError;

    /**
     * The version of the `Versioned` value used is not able to be interpreted.
     **/
    badVersion: GenericModuleError;

    /**
     * The given location could not be used (e.g. because it cannot be expressed in the
     * desired version of XCM).
     **/
    badLocation: GenericModuleError;

    /**
     * The referenced subscription could not be found.
     **/
    noSubscription: GenericModuleError;

    /**
     * The location is invalid since it already has a subscription from us.
     **/
    alreadySubscribed: GenericModuleError;

    /**
     * Invalid asset for the operation.
     **/
    invalidAsset: GenericModuleError;

    /**
     * The owner does not own (all) of the asset that they wish to do the operation on.
     **/
    lowBalance: GenericModuleError;

    /**
     * The asset owner has too many locks on the asset.
     **/
    tooManyLocks: GenericModuleError;

    /**
     * The given account is not an identifiable sovereign account for any location.
     **/
    accountNotSovereign: GenericModuleError;

    /**
     * The operation required fees to be paid which the initiator could not meet.
     **/
    feesNotMet: GenericModuleError;

    /**
     * A remote lock with the corresponding data could not be found.
     **/
    lockNotFound: GenericModuleError;

    /**
     * The unlock operation cannot succeed because there are still consumers of the lock.
     **/
    inUse: GenericModuleError;
  };
  assets: {
    /**
     * Account balance must be greater than or equal to the transfer amount.
     **/
    balanceLow: GenericModuleError;

    /**
     * The account to alter does not exist.
     **/
    noAccount: GenericModuleError;

    /**
     * The signing account has no permission to do the operation.
     **/
    noPermission: GenericModuleError;

    /**
     * The given asset ID is unknown.
     **/
    unknown: GenericModuleError;

    /**
     * The origin account is frozen.
     **/
    frozen: GenericModuleError;

    /**
     * The asset ID is already taken.
     **/
    inUse: GenericModuleError;

    /**
     * Invalid witness data given.
     **/
    badWitness: GenericModuleError;

    /**
     * Minimum balance should be non-zero.
     **/
    minBalanceZero: GenericModuleError;

    /**
     * Unable to increment the consumer reference counters on the account. Either no provider
     * reference exists to allow a non-zero balance of a non-self-sufficient asset, or one
     * fewer then the maximum number of consumers has been reached.
     **/
    unavailableConsumer: GenericModuleError;

    /**
     * Invalid metadata given.
     **/
    badMetadata: GenericModuleError;

    /**
     * No approval exists that would allow the transfer.
     **/
    unapproved: GenericModuleError;

    /**
     * The source account would not survive the transfer and it needs to stay alive.
     **/
    wouldDie: GenericModuleError;

    /**
     * The asset-account already exists.
     **/
    alreadyExists: GenericModuleError;

    /**
     * The asset-account doesn't have an associated deposit.
     **/
    noDeposit: GenericModuleError;

    /**
     * The operation would result in funds being burned.
     **/
    wouldBurn: GenericModuleError;

    /**
     * The asset is a live asset and is actively being used. Usually emit for operations such
     * as `start_destroy` which require the asset to be in a destroying state.
     **/
    liveAsset: GenericModuleError;

    /**
     * The asset is not live, and likely being destroyed.
     **/
    assetNotLive: GenericModuleError;

    /**
     * The asset status is not the expected status.
     **/
    incorrectStatus: GenericModuleError;

    /**
     * The asset should be frozen before the given operation.
     **/
    notFrozen: GenericModuleError;

    /**
     * Callback action resulted in error
     **/
    callbackFailed: GenericModuleError;
  };
  assetManager: {
    errorCreatingAsset: GenericModuleError;
    assetAlreadyExists: GenericModuleError;
    assetDoesNotExist: GenericModuleError;
    tooLowNumAssetsWeightHint: GenericModuleError;
    localAssetLimitReached: GenericModuleError;
    errorDestroyingAsset: GenericModuleError;
    notSufficientDeposit: GenericModuleError;
    nonExistentLocalAsset: GenericModuleError;
  };
  xTokens: {
    /**
     * Asset has no reserve location.
     **/
    assetHasNoReserve: GenericModuleError;

    /**
     * Not cross-chain transfer.
     **/
    notCrossChainTransfer: GenericModuleError;

    /**
     * Invalid transfer destination.
     **/
    invalidDest: GenericModuleError;

    /**
     * Currency is not cross-chain transferable.
     **/
    notCrossChainTransferableCurrency: GenericModuleError;

    /**
     * The message's weight could not be determined.
     **/
    unweighableMessage: GenericModuleError;

    /**
     * XCM execution failed.
     **/
    xcmExecutionFailed: GenericModuleError;

    /**
     * Could not re-anchor the assets to declare the fees for the
     * destination chain.
     **/
    cannotReanchor: GenericModuleError;

    /**
     * Could not get ancestry of asset reserve location.
     **/
    invalidAncestry: GenericModuleError;

    /**
     * The MultiAsset is invalid.
     **/
    invalidAsset: GenericModuleError;

    /**
     * The destination `MultiLocation` provided cannot be inverted.
     **/
    destinationNotInvertible: GenericModuleError;

    /**
     * The version of the `Versioned` value used is not able to be
     * interpreted.
     **/
    badVersion: GenericModuleError;

    /**
     * We tried sending distinct asset and fee but they have different
     * reserve chains.
     **/
    distinctReserveForAssetAndFee: GenericModuleError;

    /**
     * The fee is zero.
     **/
    zeroFee: GenericModuleError;

    /**
     * The transfering asset amount is zero.
     **/
    zeroAmount: GenericModuleError;

    /**
     * The number of assets to be sent is over the maximum.
     **/
    tooManyAssetsBeingSent: GenericModuleError;

    /**
     * The specified index does not exist in a MultiAssets struct.
     **/
    assetIndexNonExistent: GenericModuleError;

    /**
     * Fee is not enough.
     **/
    feeNotEnough: GenericModuleError;

    /**
     * Not supported MultiLocation
     **/
    notSupportedMultiLocation: GenericModuleError;

    /**
     * MinXcmFee not registered for certain reserve location
     **/
    minXcmFeeNotDefined: GenericModuleError;
  };
  xcmTransactor: {
    indexAlreadyClaimed: GenericModuleError;
    unclaimedIndex: GenericModuleError;
    notOwner: GenericModuleError;
    unweighableMessage: GenericModuleError;
    cannotReanchor: GenericModuleError;
    assetHasNoReserve: GenericModuleError;
    invalidDest: GenericModuleError;
    notCrossChainTransfer: GenericModuleError;
    assetIsNotReserveInDestination: GenericModuleError;
    destinationNotInvertible: GenericModuleError;
    errorDelivering: GenericModuleError;
    dispatchWeightBiggerThanTotalWeight: GenericModuleError;
    weightOverflow: GenericModuleError;
    amountOverflow: GenericModuleError;
    transactorInfoNotSet: GenericModuleError;
    notCrossChainTransferableCurrency: GenericModuleError;
    xcmExecuteError: GenericModuleError;
    badVersion: GenericModuleError;
    maxWeightTransactReached: GenericModuleError;
    unableToWithdrawAsset: GenericModuleError;
    feePerSecondNotSet: GenericModuleError;
    signedTransactNotAllowedForDestination: GenericModuleError;
    failedMultiLocationToJunction: GenericModuleError;
    hrmpHandlerNotImplemented: GenericModuleError;
    tooMuchFeeUsed: GenericModuleError;
    errorValidating: GenericModuleError;
    refundNotSupportedWithTransactInfo: GenericModuleError;
  };
  localAssets: {
    /**
     * Account balance must be greater than or equal to the transfer amount.
     **/
    balanceLow: GenericModuleError;

    /**
     * The account to alter does not exist.
     **/
    noAccount: GenericModuleError;

    /**
     * The signing account has no permission to do the operation.
     **/
    noPermission: GenericModuleError;

    /**
     * The given asset ID is unknown.
     **/
    unknown: GenericModuleError;

    /**
     * The origin account is frozen.
     **/
    frozen: GenericModuleError;

    /**
     * The asset ID is already taken.
     **/
    inUse: GenericModuleError;

    /**
     * Invalid witness data given.
     **/
    badWitness: GenericModuleError;

    /**
     * Minimum balance should be non-zero.
     **/
    minBalanceZero: GenericModuleError;

    /**
     * Unable to increment the consumer reference counters on the account. Either no provider
     * reference exists to allow a non-zero balance of a non-self-sufficient asset, or one
     * fewer then the maximum number of consumers has been reached.
     **/
    unavailableConsumer: GenericModuleError;

    /**
     * Invalid metadata given.
     **/
    badMetadata: GenericModuleError;

    /**
     * No approval exists that would allow the transfer.
     **/
    unapproved: GenericModuleError;

    /**
     * The source account would not survive the transfer and it needs to stay alive.
     **/
    wouldDie: GenericModuleError;

    /**
     * The asset-account already exists.
     **/
    alreadyExists: GenericModuleError;

    /**
     * The asset-account doesn't have an associated deposit.
     **/
    noDeposit: GenericModuleError;

    /**
     * The operation would result in funds being burned.
     **/
    wouldBurn: GenericModuleError;

    /**
     * The asset is a live asset and is actively being used. Usually emit for operations such
     * as `start_destroy` which require the asset to be in a destroying state.
     **/
    liveAsset: GenericModuleError;

    /**
     * The asset is not live, and likely being destroyed.
     **/
    assetNotLive: GenericModuleError;

    /**
     * The asset status is not the expected status.
     **/
    incorrectStatus: GenericModuleError;

    /**
     * The asset should be frozen before the given operation.
     **/
    notFrozen: GenericModuleError;

    /**
     * Callback action resulted in error
     **/
    callbackFailed: GenericModuleError;
  };
  ethereumXcm: {
    /**
     * Xcm to Ethereum execution is suspended
     **/
    ethereumXcmExecutionSuspended: GenericModuleError;
  };
  randomness: {
    requestCounterOverflowed: GenericModuleError;
    requestFeeOverflowed: GenericModuleError;
    mustRequestAtLeastOneWord: GenericModuleError;
    cannotRequestMoreWordsThanMax: GenericModuleError;
    cannotRequestRandomnessAfterMaxDelay: GenericModuleError;
    cannotRequestRandomnessBeforeMinDelay: GenericModuleError;
    requestDNE: GenericModuleError;
    requestCannotYetBeFulfilled: GenericModuleError;
    onlyRequesterCanIncreaseFee: GenericModuleError;
    requestHasNotExpired: GenericModuleError;
    randomnessResultDNE: GenericModuleError;
    randomnessResultNotFilled: GenericModuleError;
  };
}
