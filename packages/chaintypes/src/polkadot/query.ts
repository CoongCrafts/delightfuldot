// Generated by @delightfuldot/codegen

import type { GenericChainStorage, Callback, Unsub } from '@delightfuldot/types';
import type {
  AccountId32Like,
  H256,
  Bytes,
  Digest,
  FixedBytes,
  AccountId32,
  FixedU128,
  Perbill,
  Percent,
  EthereumAddressLike,
  EthereumAddress,
  Data,
  FixedArray,
} from '@delightfuldot/codecs';
import type {
  FrameSystemAccountInfo,
  FrameSupportDispatchPerDispatchClass,
  FrameSystemEventRecord,
  FrameSystemLastRuntimeUpgradeInfo,
  FrameSystemPhase,
  PalletSchedulerScheduled,
  PalletPreimageRequestStatus,
  SpConsensusBabeAppPublic,
  SpConsensusSlotsSlot,
  SpConsensusBabeDigestsNextConfigDescriptor,
  SpConsensusBabeDigestsPreDigest,
  SpConsensusBabeBabeEpochConfiguration,
  PalletBalancesAccountData,
  PalletBalancesBalanceLock,
  PalletBalancesReserveData,
  PalletBalancesIdAmount,
  PalletBalancesIdAmount002,
  PalletTransactionPaymentReleases,
  PalletStakingStakingLedger,
  PalletStakingRewardDestination,
  PalletStakingValidatorPrefs,
  PalletStakingNominations,
  PalletStakingActiveEraInfo,
  PalletStakingExposure,
  PalletStakingEraRewardPoints,
  PalletStakingForcing,
  PalletStakingUnappliedSlash,
  PalletStakingSlashingSlashingSpans,
  PalletStakingSlashingSpanRecord,
  SpStakingOffenceOffenceDetails,
  PolkadotRuntimeSessionKeys,
  SpCoreCryptoKeyTypeId,
  PalletGrandpaStoredState,
  PalletGrandpaStoredPendingChange,
  PalletImOnlineSr25519AppSr25519Public,
  PalletTreasuryProposal,
  PalletConvictionVotingVoteVoting,
  PalletReferendaReferendumInfo,
  PolkadotRuntimeCommonClaimsStatementKind,
  PalletVestingVestingInfo,
  PalletVestingReleases,
  PalletIdentityRegistration,
  PalletIdentityRegistrarInfo,
  PalletProxyProxyDefinition,
  PalletProxyAnnouncement,
  PalletMultisigMultisig,
  PalletBountiesBounty,
  PalletChildBountiesChildBounty,
  PalletElectionProviderMultiPhasePhase,
  PalletElectionProviderMultiPhaseReadySolution,
  PalletElectionProviderMultiPhaseRoundSnapshot,
  PalletElectionProviderMultiPhaseSolutionOrSnapshotSize,
  SpNposElectionsElectionScore,
  PalletElectionProviderMultiPhaseSignedSignedSubmission,
  PalletBagsListListNode,
  PalletBagsListListBag,
  PalletNominationPoolsPoolMember,
  PalletNominationPoolsBondedPoolInner,
  PalletNominationPoolsRewardPool,
  PalletNominationPoolsSubPools,
  PalletNominationPoolsClaimPermission,
  PalletFastUnstakeUnstakeRequest,
  PolkadotRuntimeParachainsConfigurationHostConfiguration,
  PolkadotPrimitivesV5ValidatorIndex,
  PolkadotPrimitivesV5ValidatorAppPublic,
  PolkadotRuntimeParachainsSharedAllowedRelayParentsTracker,
  PolkadotRuntimeParachainsInclusionAvailabilityBitfieldRecord,
  PolkadotRuntimeParachainsInclusionCandidatePendingAvailability,
  PolkadotParachainPrimitivesPrimitivesId,
  PolkadotPrimitivesV5CandidateCommitments,
  PolkadotPrimitivesV5ScrapedOnChainVotes,
  PolkadotPrimitivesV5CoreOccupied,
  PolkadotPrimitivesV5CoreIndex,
  PolkadotPrimitivesV5ParasEntry,
  PolkadotRuntimeParachainsParasPvfCheckActiveVoteState,
  PolkadotParachainPrimitivesPrimitivesValidationCodeHash,
  PolkadotRuntimeParachainsParasParaLifecycle,
  PolkadotParachainPrimitivesPrimitivesHeadData,
  PolkadotRuntimeParachainsParasParaPastCodeMeta,
  PolkadotPrimitivesV5UpgradeGoAhead,
  PolkadotPrimitivesV5UpgradeRestriction,
  PolkadotRuntimeParachainsParasParaGenesisArgs,
  PolkadotParachainPrimitivesPrimitivesValidationCode,
  PolkadotRuntimeParachainsInitializerBufferedSessionChange,
  PolkadotCorePrimitivesInboundDownwardMessage,
  PolkadotRuntimeParachainsHrmpHrmpOpenChannelRequest,
  PolkadotParachainPrimitivesPrimitivesHrmpChannelId,
  PolkadotRuntimeParachainsHrmpHrmpChannel,
  PolkadotCorePrimitivesInboundHrmpMessage,
  PolkadotPrimitivesV5AssignmentAppPublic,
  PolkadotPrimitivesV5SessionInfo,
  PolkadotPrimitivesV5ExecutorParams,
  PolkadotPrimitivesV5DisputeState,
  PolkadotCorePrimitivesCandidateHash,
  PolkadotPrimitivesV5SlashingPendingSlashes,
  PolkadotRuntimeCommonParasRegistrarParaInfo,
  PolkadotRuntimeCommonCrowdloanFundInfo,
  PalletXcmQueryStatus,
  XcmVersionedMultiLocation,
  SpWeightsWeightV2Weight,
  PalletXcmVersionMigrationStage,
  PalletXcmRemoteLockedFungibleRecord,
  XcmVersionedAssetId,
  PalletMessageQueueBookState,
  PolkadotRuntimeParachainsInclusionAggregateMessageOrigin,
  PalletMessageQueuePage,
} from './types';

export interface ChainStorage extends GenericChainStorage {
  system: {
    /**
     * The full account information for a particular account ID.
     **/
    account(arg: AccountId32Like): Promise<FrameSystemAccountInfo>;
    account(arg: AccountId32Like, callback: Callback<FrameSystemAccountInfo>): Promise<Unsub>;

    /**
     * Total extrinsics count for the current block.
     **/
    extrinsicCount(): Promise<number | undefined>;
    extrinsicCount(callback: Callback<number | undefined>): Promise<Unsub>;

    /**
     * The current weight for the block.
     **/
    blockWeight(): Promise<FrameSupportDispatchPerDispatchClass>;
    blockWeight(callback: Callback<FrameSupportDispatchPerDispatchClass>): Promise<Unsub>;

    /**
     * Total length (in bytes) for all extrinsics put together, for the current block.
     **/
    allExtrinsicsLen(): Promise<number | undefined>;
    allExtrinsicsLen(callback: Callback<number | undefined>): Promise<Unsub>;

    /**
     * Map of block numbers to block hashes.
     **/
    blockHash(arg: number): Promise<H256>;
    blockHash(arg: number, callback: Callback<H256>): Promise<Unsub>;

    /**
     * Extrinsics data for the current block (maps an extrinsic's index to its data).
     **/
    extrinsicData(arg: number): Promise<Bytes>;
    extrinsicData(arg: number, callback: Callback<Bytes>): Promise<Unsub>;

    /**
     * The current block number being processed. Set by `execute_block`.
     **/
    number(): Promise<number>;
    number(callback: Callback<number>): Promise<Unsub>;

    /**
     * Hash of the previous block.
     **/
    parentHash(): Promise<H256>;
    parentHash(callback: Callback<H256>): Promise<Unsub>;

    /**
     * Digest of the current block, also part of the block header.
     **/
    digest(): Promise<Digest>;
    digest(callback: Callback<Digest>): Promise<Unsub>;

    /**
     * Events deposited for the current block.
     *
     * NOTE: The item is unbound and should therefore never be read on chain.
     * It could otherwise inflate the PoV size of a block.
     *
     * Events have a large in-memory size. Box the events to not go out-of-memory
     * just in case someone still reads them from within the runtime.
     **/
    events(): Promise<Array<FrameSystemEventRecord>>;
    events(callback: Callback<Array<FrameSystemEventRecord>>): Promise<Unsub>;

    /**
     * The number of events in the `Events<T>` list.
     **/
    eventCount(): Promise<number>;
    eventCount(callback: Callback<number>): Promise<Unsub>;

    /**
     * Mapping between a topic (represented by T::Hash) and a vector of indexes
     * of events in the `<Events<T>>` list.
     *
     * All topic vectors have deterministic storage locations depending on the topic. This
     * allows light-clients to leverage the changes trie storage tracking mechanism and
     * in case of changes fetch the list of events of interest.
     *
     * The value has the type `(BlockNumberFor<T>, EventIndex)` because if we used only just
     * the `EventIndex` then in case if the topic has the same contents on the next block
     * no notification will be triggered thus the event might be lost.
     **/
    eventTopics(arg: H256): Promise<Array<[number, number]>>;
    eventTopics(arg: H256, callback: Callback<Array<[number, number]>>): Promise<Unsub>;

    /**
     * Stores the `spec_version` and `spec_name` of when the last runtime upgrade happened.
     **/
    lastRuntimeUpgrade(): Promise<FrameSystemLastRuntimeUpgradeInfo | undefined>;
    lastRuntimeUpgrade(callback: Callback<FrameSystemLastRuntimeUpgradeInfo | undefined>): Promise<Unsub>;

    /**
     * True if we have upgraded so that `type RefCount` is `u32`. False (default) if not.
     **/
    upgradedToU32RefCount(): Promise<boolean>;
    upgradedToU32RefCount(callback: Callback<boolean>): Promise<Unsub>;

    /**
     * True if we have upgraded so that AccountInfo contains three types of `RefCount`. False
     * (default) if not.
     **/
    upgradedToTripleRefCount(): Promise<boolean>;
    upgradedToTripleRefCount(callback: Callback<boolean>): Promise<Unsub>;

    /**
     * The execution phase of the block.
     **/
    executionPhase(): Promise<FrameSystemPhase | undefined>;
    executionPhase(callback: Callback<FrameSystemPhase | undefined>): Promise<Unsub>;
  };
  scheduler: {
    incompleteSince(): Promise<number | undefined>;
    incompleteSince(callback: Callback<number | undefined>): Promise<Unsub>;

    /**
     * Items to be executed, indexed by the block number that they should be executed on.
     **/
    agenda(arg: number): Promise<Array<PalletSchedulerScheduled | undefined>>;
    agenda(arg: number, callback: Callback<Array<PalletSchedulerScheduled | undefined>>): Promise<Unsub>;

    /**
     * Lookup from a name to the block number and index of the task.
     *
     * For v3 -> v4 the previously unbounded identities are Blake2-256 hashed to form the v4
     * identities.
     **/
    lookup(arg: FixedBytes<32>): Promise<[number, number] | undefined>;
    lookup(arg: FixedBytes<32>, callback: Callback<[number, number] | undefined>): Promise<Unsub>;
  };
  preimage: {
    /**
     * The request status of a given hash.
     **/
    statusFor(arg: H256): Promise<PalletPreimageRequestStatus | undefined>;
    statusFor(arg: H256, callback: Callback<PalletPreimageRequestStatus | undefined>): Promise<Unsub>;
    preimageFor(arg: [H256, number]): Promise<Bytes | undefined>;
    preimageFor(arg: [H256, number], callback: Callback<Bytes | undefined>): Promise<Unsub>;
  };
  babe: {
    /**
     * Current epoch index.
     **/
    epochIndex(): Promise<bigint>;
    epochIndex(callback: Callback<bigint>): Promise<Unsub>;

    /**
     * Current epoch authorities.
     **/
    authorities(): Promise<Array<[SpConsensusBabeAppPublic, bigint]>>;
    authorities(callback: Callback<Array<[SpConsensusBabeAppPublic, bigint]>>): Promise<Unsub>;

    /**
     * The slot at which the first epoch actually started. This is 0
     * until the first block of the chain.
     **/
    genesisSlot(): Promise<SpConsensusSlotsSlot>;
    genesisSlot(callback: Callback<SpConsensusSlotsSlot>): Promise<Unsub>;

    /**
     * Current slot number.
     **/
    currentSlot(): Promise<SpConsensusSlotsSlot>;
    currentSlot(callback: Callback<SpConsensusSlotsSlot>): Promise<Unsub>;

    /**
     * The epoch randomness for the *current* epoch.
     *
     * # Security
     *
     * This MUST NOT be used for gambling, as it can be influenced by a
     * malicious validator in the short term. It MAY be used in many
     * cryptographic protocols, however, so long as one remembers that this
     * (like everything else on-chain) it is public. For example, it can be
     * used where a number is needed that cannot have been chosen by an
     * adversary, for purposes such as public-coin zero-knowledge proofs.
     **/
    randomness(): Promise<FixedBytes<32>>;
    randomness(callback: Callback<FixedBytes<32>>): Promise<Unsub>;

    /**
     * Pending epoch configuration change that will be applied when the next epoch is enacted.
     **/
    pendingEpochConfigChange(): Promise<SpConsensusBabeDigestsNextConfigDescriptor | undefined>;
    pendingEpochConfigChange(
      callback: Callback<SpConsensusBabeDigestsNextConfigDescriptor | undefined>,
    ): Promise<Unsub>;

    /**
     * Next epoch randomness.
     **/
    nextRandomness(): Promise<FixedBytes<32>>;
    nextRandomness(callback: Callback<FixedBytes<32>>): Promise<Unsub>;

    /**
     * Next epoch authorities.
     **/
    nextAuthorities(): Promise<Array<[SpConsensusBabeAppPublic, bigint]>>;
    nextAuthorities(callback: Callback<Array<[SpConsensusBabeAppPublic, bigint]>>): Promise<Unsub>;

    /**
     * Randomness under construction.
     *
     * We make a trade-off between storage accesses and list length.
     * We store the under-construction randomness in segments of up to
     * `UNDER_CONSTRUCTION_SEGMENT_LENGTH`.
     *
     * Once a segment reaches this length, we begin the next one.
     * We reset all segments and return to `0` at the beginning of every
     * epoch.
     **/
    segmentIndex(): Promise<number>;
    segmentIndex(callback: Callback<number>): Promise<Unsub>;

    /**
     * TWOX-NOTE: `SegmentIndex` is an increasing integer, so this is okay.
     **/
    underConstruction(arg: number): Promise<Array<FixedBytes<32>>>;
    underConstruction(arg: number, callback: Callback<Array<FixedBytes<32>>>): Promise<Unsub>;

    /**
     * Temporary value (cleared at block finalization) which is `Some`
     * if per-block initialization has already been called for current block.
     **/
    initialized(): Promise<SpConsensusBabeDigestsPreDigest | undefined | undefined>;
    initialized(callback: Callback<SpConsensusBabeDigestsPreDigest | undefined | undefined>): Promise<Unsub>;

    /**
     * This field should always be populated during block processing unless
     * secondary plain slots are enabled (which don't contain a VRF output).
     *
     * It is set in `on_finalize`, before it will contain the value from the last block.
     **/
    authorVrfRandomness(): Promise<FixedBytes<32> | undefined>;
    authorVrfRandomness(callback: Callback<FixedBytes<32> | undefined>): Promise<Unsub>;

    /**
     * The block numbers when the last and current epoch have started, respectively `N-1` and
     * `N`.
     * NOTE: We track this is in order to annotate the block number when a given pool of
     * entropy was fixed (i.e. it was known to chain observers). Since epochs are defined in
     * slots, which may be skipped, the block numbers may not line up with the slot numbers.
     **/
    epochStart(): Promise<[number, number]>;
    epochStart(callback: Callback<[number, number]>): Promise<Unsub>;

    /**
     * How late the current block is compared to its parent.
     *
     * This entry is populated as part of block execution and is cleaned up
     * on block finalization. Querying this storage entry outside of block
     * execution context should always yield zero.
     **/
    lateness(): Promise<number>;
    lateness(callback: Callback<number>): Promise<Unsub>;

    /**
     * The configuration for the current epoch. Should never be `None` as it is initialized in
     * genesis.
     **/
    epochConfig(): Promise<SpConsensusBabeBabeEpochConfiguration | undefined>;
    epochConfig(callback: Callback<SpConsensusBabeBabeEpochConfiguration | undefined>): Promise<Unsub>;

    /**
     * The configuration for the next epoch, `None` if the config will not change
     * (you can fallback to `EpochConfig` instead in that case).
     **/
    nextEpochConfig(): Promise<SpConsensusBabeBabeEpochConfiguration | undefined>;
    nextEpochConfig(callback: Callback<SpConsensusBabeBabeEpochConfiguration | undefined>): Promise<Unsub>;

    /**
     * A list of the last 100 skipped epochs and the corresponding session index
     * when the epoch was skipped.
     *
     * This is only used for validating equivocation proofs. An equivocation proof
     * must contains a key-ownership proof for a given session, therefore we need a
     * way to tie together sessions and epoch indices, i.e. we need to validate that
     * a validator was the owner of a given key on a given session, and what the
     * active epoch index was during that session.
     **/
    skippedEpochs(): Promise<Array<[bigint, number]>>;
    skippedEpochs(callback: Callback<Array<[bigint, number]>>): Promise<Unsub>;
  };
  timestamp: {
    /**
     * Current time for the current block.
     **/
    now(): Promise<bigint>;
    now(callback: Callback<bigint>): Promise<Unsub>;

    /**
     * Did the timestamp get updated in this block?
     **/
    didUpdate(): Promise<boolean>;
    didUpdate(callback: Callback<boolean>): Promise<Unsub>;
  };
  indices: {
    /**
     * The lookup from index to account.
     **/
    accounts(arg: number): Promise<[AccountId32, bigint, boolean] | undefined>;
    accounts(arg: number, callback: Callback<[AccountId32, bigint, boolean] | undefined>): Promise<Unsub>;
  };
  balances: {
    /**
     * The total units issued in the system.
     **/
    totalIssuance(): Promise<bigint>;
    totalIssuance(callback: Callback<bigint>): Promise<Unsub>;

    /**
     * The total units of outstanding deactivated balance in the system.
     **/
    inactiveIssuance(): Promise<bigint>;
    inactiveIssuance(callback: Callback<bigint>): Promise<Unsub>;

    /**
     * The Balances pallet example of storing the balance of an account.
     *
     * # Example
     *
     * ```nocompile
     * impl pallet_balances::Config for Runtime {
     * type AccountStore = StorageMapShim<Self::Account<Runtime>, frame_system::Provider<Runtime>, AccountId, Self::AccountData<Balance>>
     * }
     * ```
     *
     * You can also store the balance of an account in the `System` pallet.
     *
     * # Example
     *
     * ```nocompile
     * impl pallet_balances::Config for Runtime {
     * type AccountStore = System
     * }
     * ```
     *
     * But this comes with tradeoffs, storing account balances in the system pallet stores
     * `frame_system` data alongside the account data contrary to storing account balances in the
     * `Balances` pallet, which uses a `StorageMap` to store balances data only.
     * NOTE: This is only used in the case that this pallet is used to store balances.
     **/
    account(arg: AccountId32Like): Promise<PalletBalancesAccountData>;
    account(arg: AccountId32Like, callback: Callback<PalletBalancesAccountData>): Promise<Unsub>;

    /**
     * Any liquidity locks on some account balances.
     * NOTE: Should only be accessed when setting, changing and freeing a lock.
     **/
    locks(arg: AccountId32Like): Promise<Array<PalletBalancesBalanceLock>>;
    locks(arg: AccountId32Like, callback: Callback<Array<PalletBalancesBalanceLock>>): Promise<Unsub>;

    /**
     * Named reserves on some account balances.
     **/
    reserves(arg: AccountId32Like): Promise<Array<PalletBalancesReserveData>>;
    reserves(arg: AccountId32Like, callback: Callback<Array<PalletBalancesReserveData>>): Promise<Unsub>;

    /**
     * Holds on account balances.
     **/
    holds(arg: AccountId32Like): Promise<Array<PalletBalancesIdAmount>>;
    holds(arg: AccountId32Like, callback: Callback<Array<PalletBalancesIdAmount>>): Promise<Unsub>;

    /**
     * Freeze locks on account balances.
     **/
    freezes(arg: AccountId32Like): Promise<Array<PalletBalancesIdAmount002>>;
    freezes(arg: AccountId32Like, callback: Callback<Array<PalletBalancesIdAmount002>>): Promise<Unsub>;
  };
  transactionPayment: {
    nextFeeMultiplier(): Promise<FixedU128>;
    nextFeeMultiplier(callback: Callback<FixedU128>): Promise<Unsub>;
    storageVersion(): Promise<PalletTransactionPaymentReleases>;
    storageVersion(callback: Callback<PalletTransactionPaymentReleases>): Promise<Unsub>;
  };
  authorship: {
    /**
     * Author of current block.
     **/
    author(): Promise<AccountId32 | undefined>;
    author(callback: Callback<AccountId32 | undefined>): Promise<Unsub>;
  };
  staking: {
    /**
     * The ideal number of active validators.
     **/
    validatorCount(): Promise<number>;
    validatorCount(callback: Callback<number>): Promise<Unsub>;

    /**
     * Minimum number of staking participants before emergency conditions are imposed.
     **/
    minimumValidatorCount(): Promise<number>;
    minimumValidatorCount(callback: Callback<number>): Promise<Unsub>;

    /**
     * Any validators that may never be slashed or forcibly kicked. It's a Vec since they're
     * easy to initialize and the performance hit is minimal (we expect no more than four
     * invulnerables) and restricted to testnets.
     **/
    invulnerables(): Promise<Array<AccountId32>>;
    invulnerables(callback: Callback<Array<AccountId32>>): Promise<Unsub>;

    /**
     * Map from all locked "stash" accounts to the controller account.
     *
     * TWOX-NOTE: SAFE since `AccountId` is a secure hash.
     **/
    bonded(arg: AccountId32Like): Promise<AccountId32 | undefined>;
    bonded(arg: AccountId32Like, callback: Callback<AccountId32 | undefined>): Promise<Unsub>;

    /**
     * The minimum active bond to become and maintain the role of a nominator.
     **/
    minNominatorBond(): Promise<bigint>;
    minNominatorBond(callback: Callback<bigint>): Promise<Unsub>;

    /**
     * The minimum active bond to become and maintain the role of a validator.
     **/
    minValidatorBond(): Promise<bigint>;
    minValidatorBond(callback: Callback<bigint>): Promise<Unsub>;

    /**
     * The minimum active nominator stake of the last successful election.
     **/
    minimumActiveStake(): Promise<bigint>;
    minimumActiveStake(callback: Callback<bigint>): Promise<Unsub>;

    /**
     * The minimum amount of commission that validators can set.
     *
     * If set to `0`, no limit exists.
     **/
    minCommission(): Promise<Perbill>;
    minCommission(callback: Callback<Perbill>): Promise<Unsub>;

    /**
     * Map from all (unlocked) "controller" accounts to the info regarding the staking.
     **/
    ledger(arg: AccountId32Like): Promise<PalletStakingStakingLedger | undefined>;
    ledger(arg: AccountId32Like, callback: Callback<PalletStakingStakingLedger | undefined>): Promise<Unsub>;

    /**
     * Where the reward payment should be made. Keyed by stash.
     *
     * TWOX-NOTE: SAFE since `AccountId` is a secure hash.
     **/
    payee(arg: AccountId32Like): Promise<PalletStakingRewardDestination>;
    payee(arg: AccountId32Like, callback: Callback<PalletStakingRewardDestination>): Promise<Unsub>;

    /**
     * The map from (wannabe) validator stash key to the preferences of that validator.
     *
     * TWOX-NOTE: SAFE since `AccountId` is a secure hash.
     **/
    validators(arg: AccountId32Like): Promise<PalletStakingValidatorPrefs>;
    validators(arg: AccountId32Like, callback: Callback<PalletStakingValidatorPrefs>): Promise<Unsub>;

    /**
     * Counter for the related counted storage map
     **/
    counterForValidators(): Promise<number>;
    counterForValidators(callback: Callback<number>): Promise<Unsub>;

    /**
     * The maximum validator count before we stop allowing new validators to join.
     *
     * When this value is not set, no limits are enforced.
     **/
    maxValidatorsCount(): Promise<number | undefined>;
    maxValidatorsCount(callback: Callback<number | undefined>): Promise<Unsub>;

    /**
     * The map from nominator stash key to their nomination preferences, namely the validators that
     * they wish to support.
     *
     * Note that the keys of this storage map might become non-decodable in case the
     * account's [`NominationsQuota::MaxNominations`] configuration is decreased.
     * In this rare case, these nominators
     * are still existent in storage, their key is correct and retrievable (i.e. `contains_key`
     * indicates that they exist), but their value cannot be decoded. Therefore, the non-decodable
     * nominators will effectively not-exist, until they re-submit their preferences such that it
     * is within the bounds of the newly set `Config::MaxNominations`.
     *
     * This implies that `::iter_keys().count()` and `::iter().count()` might return different
     * values for this map. Moreover, the main `::count()` is aligned with the former, namely the
     * number of keys that exist.
     *
     * Lastly, if any of the nominators become non-decodable, they can be chilled immediately via
     * [`Call::chill_other`] dispatchable by anyone.
     *
     * TWOX-NOTE: SAFE since `AccountId` is a secure hash.
     **/
    nominators(arg: AccountId32Like): Promise<PalletStakingNominations | undefined>;
    nominators(arg: AccountId32Like, callback: Callback<PalletStakingNominations | undefined>): Promise<Unsub>;

    /**
     * Counter for the related counted storage map
     **/
    counterForNominators(): Promise<number>;
    counterForNominators(callback: Callback<number>): Promise<Unsub>;

    /**
     * The maximum nominator count before we stop allowing new validators to join.
     *
     * When this value is not set, no limits are enforced.
     **/
    maxNominatorsCount(): Promise<number | undefined>;
    maxNominatorsCount(callback: Callback<number | undefined>): Promise<Unsub>;

    /**
     * The current era index.
     *
     * This is the latest planned era, depending on how the Session pallet queues the validator
     * set, it might be active or not.
     **/
    currentEra(): Promise<number | undefined>;
    currentEra(callback: Callback<number | undefined>): Promise<Unsub>;

    /**
     * The active era information, it holds index and start.
     *
     * The active era is the era being currently rewarded. Validator set of this era must be
     * equal to [`SessionInterface::validators`].
     **/
    activeEra(): Promise<PalletStakingActiveEraInfo | undefined>;
    activeEra(callback: Callback<PalletStakingActiveEraInfo | undefined>): Promise<Unsub>;

    /**
     * The session index at which the era start for the last `HISTORY_DEPTH` eras.
     *
     * Note: This tracks the starting session (i.e. session index when era start being active)
     * for the eras in `[CurrentEra - HISTORY_DEPTH, CurrentEra]`.
     **/
    erasStartSessionIndex(arg: number): Promise<number | undefined>;
    erasStartSessionIndex(arg: number, callback: Callback<number | undefined>): Promise<Unsub>;

    /**
     * Exposure of validator at era.
     *
     * This is keyed first by the era index to allow bulk deletion and then the stash account.
     *
     * Is it removed after `HISTORY_DEPTH` eras.
     * If stakers hasn't been set or has been removed then empty exposure is returned.
     **/
    erasStakers(arg: [number, AccountId32Like]): Promise<PalletStakingExposure>;
    erasStakers(arg: [number, AccountId32Like], callback: Callback<PalletStakingExposure>): Promise<Unsub>;

    /**
     * Clipped Exposure of validator at era.
     *
     * This is similar to [`ErasStakers`] but number of nominators exposed is reduced to the
     * `T::MaxNominatorRewardedPerValidator` biggest stakers.
     * (Note: the field `total` and `own` of the exposure remains unchanged).
     * This is used to limit the i/o cost for the nominator payout.
     *
     * This is keyed fist by the era index to allow bulk deletion and then the stash account.
     *
     * Is it removed after `HISTORY_DEPTH` eras.
     * If stakers hasn't been set or has been removed then empty exposure is returned.
     **/
    erasStakersClipped(arg: [number, AccountId32Like]): Promise<PalletStakingExposure>;
    erasStakersClipped(arg: [number, AccountId32Like], callback: Callback<PalletStakingExposure>): Promise<Unsub>;

    /**
     * Similar to `ErasStakers`, this holds the preferences of validators.
     *
     * This is keyed first by the era index to allow bulk deletion and then the stash account.
     *
     * Is it removed after `HISTORY_DEPTH` eras.
     **/
    erasValidatorPrefs(arg: [number, AccountId32Like]): Promise<PalletStakingValidatorPrefs>;
    erasValidatorPrefs(arg: [number, AccountId32Like], callback: Callback<PalletStakingValidatorPrefs>): Promise<Unsub>;

    /**
     * The total validator era payout for the last `HISTORY_DEPTH` eras.
     *
     * Eras that haven't finished yet or has been removed doesn't have reward.
     **/
    erasValidatorReward(arg: number): Promise<bigint | undefined>;
    erasValidatorReward(arg: number, callback: Callback<bigint | undefined>): Promise<Unsub>;

    /**
     * Rewards for the last `HISTORY_DEPTH` eras.
     * If reward hasn't been set or has been removed then 0 reward is returned.
     **/
    erasRewardPoints(arg: number): Promise<PalletStakingEraRewardPoints>;
    erasRewardPoints(arg: number, callback: Callback<PalletStakingEraRewardPoints>): Promise<Unsub>;

    /**
     * The total amount staked for the last `HISTORY_DEPTH` eras.
     * If total hasn't been set or has been removed then 0 stake is returned.
     **/
    erasTotalStake(arg: number): Promise<bigint>;
    erasTotalStake(arg: number, callback: Callback<bigint>): Promise<Unsub>;

    /**
     * Mode of era forcing.
     **/
    forceEra(): Promise<PalletStakingForcing>;
    forceEra(callback: Callback<PalletStakingForcing>): Promise<Unsub>;

    /**
     * The percentage of the slash that is distributed to reporters.
     *
     * The rest of the slashed value is handled by the `Slash`.
     **/
    slashRewardFraction(): Promise<Perbill>;
    slashRewardFraction(callback: Callback<Perbill>): Promise<Unsub>;

    /**
     * The amount of currency given to reporters of a slash event which was
     * canceled by extraordinary circumstances (e.g. governance).
     **/
    canceledSlashPayout(): Promise<bigint>;
    canceledSlashPayout(callback: Callback<bigint>): Promise<Unsub>;

    /**
     * All unapplied slashes that are queued for later.
     **/
    unappliedSlashes(arg: number): Promise<Array<PalletStakingUnappliedSlash>>;
    unappliedSlashes(arg: number, callback: Callback<Array<PalletStakingUnappliedSlash>>): Promise<Unsub>;

    /**
     * A mapping from still-bonded eras to the first session index of that era.
     *
     * Must contains information for eras for the range:
     * `[active_era - bounding_duration; active_era]`
     **/
    bondedEras(): Promise<Array<[number, number]>>;
    bondedEras(callback: Callback<Array<[number, number]>>): Promise<Unsub>;

    /**
     * All slashing events on validators, mapped by era to the highest slash proportion
     * and slash value of the era.
     **/
    validatorSlashInEra(arg: [number, AccountId32Like]): Promise<[Perbill, bigint] | undefined>;
    validatorSlashInEra(
      arg: [number, AccountId32Like],
      callback: Callback<[Perbill, bigint] | undefined>,
    ): Promise<Unsub>;

    /**
     * All slashing events on nominators, mapped by era to the highest slash value of the era.
     **/
    nominatorSlashInEra(arg: [number, AccountId32Like]): Promise<bigint | undefined>;
    nominatorSlashInEra(arg: [number, AccountId32Like], callback: Callback<bigint | undefined>): Promise<Unsub>;

    /**
     * Slashing spans for stash accounts.
     **/
    slashingSpans(arg: AccountId32Like): Promise<PalletStakingSlashingSlashingSpans | undefined>;
    slashingSpans(
      arg: AccountId32Like,
      callback: Callback<PalletStakingSlashingSlashingSpans | undefined>,
    ): Promise<Unsub>;

    /**
     * Records information about the maximum slash of a stash within a slashing span,
     * as well as how much reward has been paid out.
     **/
    spanSlash(arg: [AccountId32Like, number]): Promise<PalletStakingSlashingSpanRecord>;
    spanSlash(arg: [AccountId32Like, number], callback: Callback<PalletStakingSlashingSpanRecord>): Promise<Unsub>;

    /**
     * The last planned session scheduled by the session pallet.
     *
     * This is basically in sync with the call to [`pallet_session::SessionManager::new_session`].
     **/
    currentPlannedSession(): Promise<number>;
    currentPlannedSession(callback: Callback<number>): Promise<Unsub>;

    /**
     * Indices of validators that have offended in the active era and whether they are currently
     * disabled.
     *
     * This value should be a superset of disabled validators since not all offences lead to the
     * validator being disabled (if there was no slash). This is needed to track the percentage of
     * validators that have offended in the current era, ensuring a new era is forced if
     * `OffendingValidatorsThreshold` is reached. The vec is always kept sorted so that we can find
     * whether a given validator has previously offended using binary search. It gets cleared when
     * the era ends.
     **/
    offendingValidators(): Promise<Array<[number, boolean]>>;
    offendingValidators(callback: Callback<Array<[number, boolean]>>): Promise<Unsub>;

    /**
     * The threshold for when users can start calling `chill_other` for other validators /
     * nominators. The threshold is compared to the actual number of validators / nominators
     * (`CountFor*`) in the system compared to the configured max (`Max*Count`).
     **/
    chillThreshold(): Promise<Percent | undefined>;
    chillThreshold(callback: Callback<Percent | undefined>): Promise<Unsub>;
  };
  offences: {
    /**
     * The primary structure that holds all offence records keyed by report identifiers.
     **/
    reports(arg: H256): Promise<SpStakingOffenceOffenceDetails | undefined>;
    reports(arg: H256, callback: Callback<SpStakingOffenceOffenceDetails | undefined>): Promise<Unsub>;

    /**
     * A vector of reports of the same kind that happened at the same time slot.
     **/
    concurrentReportsIndex(arg: [FixedBytes<16>, Bytes]): Promise<Array<H256>>;
    concurrentReportsIndex(arg: [FixedBytes<16>, Bytes], callback: Callback<Array<H256>>): Promise<Unsub>;
  };
  session: {
    /**
     * The current set of validators.
     **/
    validators(): Promise<Array<AccountId32>>;
    validators(callback: Callback<Array<AccountId32>>): Promise<Unsub>;

    /**
     * Current index of the session.
     **/
    currentIndex(): Promise<number>;
    currentIndex(callback: Callback<number>): Promise<Unsub>;

    /**
     * True if the underlying economic identities or weighting behind the validators
     * has changed in the queued validator set.
     **/
    queuedChanged(): Promise<boolean>;
    queuedChanged(callback: Callback<boolean>): Promise<Unsub>;

    /**
     * The queued keys for the next session. When the next session begins, these keys
     * will be used to determine the validator's session keys.
     **/
    queuedKeys(): Promise<Array<[AccountId32, PolkadotRuntimeSessionKeys]>>;
    queuedKeys(callback: Callback<Array<[AccountId32, PolkadotRuntimeSessionKeys]>>): Promise<Unsub>;

    /**
     * Indices of disabled validators.
     *
     * The vec is always kept sorted so that we can find whether a given validator is
     * disabled using binary search. It gets cleared when `on_session_ending` returns
     * a new set of identities.
     **/
    disabledValidators(): Promise<Array<number>>;
    disabledValidators(callback: Callback<Array<number>>): Promise<Unsub>;

    /**
     * The next session keys for a validator.
     **/
    nextKeys(arg: AccountId32Like): Promise<PolkadotRuntimeSessionKeys | undefined>;
    nextKeys(arg: AccountId32Like, callback: Callback<PolkadotRuntimeSessionKeys | undefined>): Promise<Unsub>;

    /**
     * The owner of a key. The key is the `KeyTypeId` + the encoded key.
     **/
    keyOwner(arg: [SpCoreCryptoKeyTypeId, Bytes]): Promise<AccountId32 | undefined>;
    keyOwner(arg: [SpCoreCryptoKeyTypeId, Bytes], callback: Callback<AccountId32 | undefined>): Promise<Unsub>;
  };
  grandpa: {
    /**
     * State of the current authority set.
     **/
    state(): Promise<PalletGrandpaStoredState>;
    state(callback: Callback<PalletGrandpaStoredState>): Promise<Unsub>;

    /**
     * Pending change: (signaled at, scheduled change).
     **/
    pendingChange(): Promise<PalletGrandpaStoredPendingChange | undefined>;
    pendingChange(callback: Callback<PalletGrandpaStoredPendingChange | undefined>): Promise<Unsub>;

    /**
     * next block number where we can force a change.
     **/
    nextForced(): Promise<number | undefined>;
    nextForced(callback: Callback<number | undefined>): Promise<Unsub>;

    /**
     * `true` if we are currently stalled.
     **/
    stalled(): Promise<[number, number] | undefined>;
    stalled(callback: Callback<[number, number] | undefined>): Promise<Unsub>;

    /**
     * The number of changes (both in terms of keys and underlying economic responsibilities)
     * in the "set" of Grandpa validators from genesis.
     **/
    currentSetId(): Promise<bigint>;
    currentSetId(callback: Callback<bigint>): Promise<Unsub>;

    /**
     * A mapping from grandpa set ID to the index of the *most recent* session for which its
     * members were responsible.
     *
     * This is only used for validating equivocation proofs. An equivocation proof must
     * contains a key-ownership proof for a given session, therefore we need a way to tie
     * together sessions and GRANDPA set ids, i.e. we need to validate that a validator
     * was the owner of a given key on a given session, and what the active set ID was
     * during that session.
     *
     * TWOX-NOTE: `SetId` is not under user control.
     **/
    setIdSession(arg: bigint): Promise<number | undefined>;
    setIdSession(arg: bigint, callback: Callback<number | undefined>): Promise<Unsub>;
  };
  imOnline: {
    /**
     * The block number after which it's ok to send heartbeats in the current
     * session.
     *
     * At the beginning of each session we set this to a value that should fall
     * roughly in the middle of the session duration. The idea is to first wait for
     * the validators to produce a block in the current session, so that the
     * heartbeat later on will not be necessary.
     *
     * This value will only be used as a fallback if we fail to get a proper session
     * progress estimate from `NextSessionRotation`, as those estimates should be
     * more accurate then the value we calculate for `HeartbeatAfter`.
     **/
    heartbeatAfter(): Promise<number>;
    heartbeatAfter(callback: Callback<number>): Promise<Unsub>;

    /**
     * The current set of keys that may issue a heartbeat.
     **/
    keys(): Promise<Array<PalletImOnlineSr25519AppSr25519Public>>;
    keys(callback: Callback<Array<PalletImOnlineSr25519AppSr25519Public>>): Promise<Unsub>;

    /**
     * For each session index, we keep a mapping of `SessionIndex` and `AuthIndex`.
     **/
    receivedHeartbeats(arg: [number, number]): Promise<boolean | undefined>;
    receivedHeartbeats(arg: [number, number], callback: Callback<boolean | undefined>): Promise<Unsub>;

    /**
     * For each session index, we keep a mapping of `ValidatorId<T>` to the
     * number of blocks authored by the given authority.
     **/
    authoredBlocks(arg: [number, AccountId32Like]): Promise<number>;
    authoredBlocks(arg: [number, AccountId32Like], callback: Callback<number>): Promise<Unsub>;
  };
  treasury: {
    /**
     * Number of proposals that have been made.
     **/
    proposalCount(): Promise<number>;
    proposalCount(callback: Callback<number>): Promise<Unsub>;

    /**
     * Proposals that have been made.
     **/
    proposals(arg: number): Promise<PalletTreasuryProposal | undefined>;
    proposals(arg: number, callback: Callback<PalletTreasuryProposal | undefined>): Promise<Unsub>;

    /**
     * The amount which has been reported as inactive to Currency.
     **/
    deactivated(): Promise<bigint>;
    deactivated(callback: Callback<bigint>): Promise<Unsub>;

    /**
     * Proposal indices that have been approved but not yet awarded.
     **/
    approvals(): Promise<Array<number>>;
    approvals(callback: Callback<Array<number>>): Promise<Unsub>;
  };
  convictionVoting: {
    /**
     * All voting for a particular voter in a particular voting class. We store the balance for the
     * number of votes that we have recorded.
     **/
    votingFor(arg: [AccountId32Like, number]): Promise<PalletConvictionVotingVoteVoting>;
    votingFor(arg: [AccountId32Like, number], callback: Callback<PalletConvictionVotingVoteVoting>): Promise<Unsub>;

    /**
     * The voting classes which have a non-zero lock requirement and the lock amounts which they
     * require. The actual amount locked on behalf of this pallet should always be the maximum of
     * this list.
     **/
    classLocksFor(arg: AccountId32Like): Promise<Array<[number, bigint]>>;
    classLocksFor(arg: AccountId32Like, callback: Callback<Array<[number, bigint]>>): Promise<Unsub>;
  };
  referenda: {
    /**
     * The next free referendum index, aka the number of referenda started so far.
     **/
    referendumCount(): Promise<number>;
    referendumCount(callback: Callback<number>): Promise<Unsub>;

    /**
     * Information concerning any given referendum.
     **/
    referendumInfoFor(arg: number): Promise<PalletReferendaReferendumInfo | undefined>;
    referendumInfoFor(arg: number, callback: Callback<PalletReferendaReferendumInfo | undefined>): Promise<Unsub>;

    /**
     * The sorted list of referenda ready to be decided but not yet being decided, ordered by
     * conviction-weighted approvals.
     *
     * This should be empty if `DecidingCount` is less than `TrackInfo::max_deciding`.
     **/
    trackQueue(arg: number): Promise<Array<[number, bigint]>>;
    trackQueue(arg: number, callback: Callback<Array<[number, bigint]>>): Promise<Unsub>;

    /**
     * The number of referenda being decided currently.
     **/
    decidingCount(arg: number): Promise<number>;
    decidingCount(arg: number, callback: Callback<number>): Promise<Unsub>;

    /**
     * The metadata is a general information concerning the referendum.
     * The `PreimageHash` refers to the preimage of the `Preimages` provider which can be a JSON
     * dump or IPFS hash of a JSON file.
     *
     * Consider a garbage collection for a metadata of finished referendums to `unrequest` (remove)
     * large preimages.
     **/
    metadataOf(arg: number): Promise<H256 | undefined>;
    metadataOf(arg: number, callback: Callback<H256 | undefined>): Promise<Unsub>;
  };
  whitelist: {
    whitelistedCall(arg: H256): Promise<[] | undefined>;
    whitelistedCall(arg: H256, callback: Callback<[] | undefined>): Promise<Unsub>;
  };
  claims: {
    claims(arg: EthereumAddressLike): Promise<bigint | undefined>;
    claims(arg: EthereumAddressLike, callback: Callback<bigint | undefined>): Promise<Unsub>;
    total(): Promise<bigint>;
    total(callback: Callback<bigint>): Promise<Unsub>;

    /**
     * Vesting schedule for a claim.
     * First balance is the total amount that should be held for vesting.
     * Second balance is how much should be unlocked per block.
     * The block number is when the vesting should start.
     **/
    vesting(arg: EthereumAddressLike): Promise<[bigint, bigint, number] | undefined>;
    vesting(arg: EthereumAddressLike, callback: Callback<[bigint, bigint, number] | undefined>): Promise<Unsub>;

    /**
     * The statement kind that must be signed, if any.
     **/
    signing(arg: EthereumAddressLike): Promise<PolkadotRuntimeCommonClaimsStatementKind | undefined>;
    signing(
      arg: EthereumAddressLike,
      callback: Callback<PolkadotRuntimeCommonClaimsStatementKind | undefined>,
    ): Promise<Unsub>;

    /**
     * Pre-claimed Ethereum accounts, by the Account ID that they are claimed to.
     **/
    preclaims(arg: AccountId32Like): Promise<EthereumAddress | undefined>;
    preclaims(arg: AccountId32Like, callback: Callback<EthereumAddress | undefined>): Promise<Unsub>;
  };
  vesting: {
    /**
     * Information regarding the vesting of a given account.
     **/
    vesting(arg: AccountId32Like): Promise<Array<PalletVestingVestingInfo> | undefined>;
    vesting(arg: AccountId32Like, callback: Callback<Array<PalletVestingVestingInfo> | undefined>): Promise<Unsub>;

    /**
     * Storage version of the pallet.
     *
     * New networks start with latest version, as determined by the genesis build.
     **/
    storageVersion(): Promise<PalletVestingReleases>;
    storageVersion(callback: Callback<PalletVestingReleases>): Promise<Unsub>;
  };
  identity: {
    /**
     * Information that is pertinent to identify the entity behind an account.
     *
     * TWOX-NOTE: OK ― `AccountId` is a secure hash.
     **/
    identityOf(arg: AccountId32Like): Promise<PalletIdentityRegistration | undefined>;
    identityOf(arg: AccountId32Like, callback: Callback<PalletIdentityRegistration | undefined>): Promise<Unsub>;

    /**
     * The super-identity of an alternative "sub" identity together with its name, within that
     * context. If the account is not some other account's sub-identity, then just `None`.
     **/
    superOf(arg: AccountId32Like): Promise<[AccountId32, Data] | undefined>;
    superOf(arg: AccountId32Like, callback: Callback<[AccountId32, Data] | undefined>): Promise<Unsub>;

    /**
     * Alternative "sub" identities of this account.
     *
     * The first item is the deposit, the second is a vector of the accounts.
     *
     * TWOX-NOTE: OK ― `AccountId` is a secure hash.
     **/
    subsOf(arg: AccountId32Like): Promise<[bigint, Array<AccountId32>]>;
    subsOf(arg: AccountId32Like, callback: Callback<[bigint, Array<AccountId32>]>): Promise<Unsub>;

    /**
     * The set of registrars. Not expected to get very big as can only be added through a
     * special origin (likely a council motion).
     *
     * The index into this can be cast to `RegistrarIndex` to get a valid value.
     **/
    registrars(): Promise<Array<PalletIdentityRegistrarInfo | undefined>>;
    registrars(callback: Callback<Array<PalletIdentityRegistrarInfo | undefined>>): Promise<Unsub>;
  };
  proxy: {
    /**
     * The set of account proxies. Maps the account which has delegated to the accounts
     * which are being delegated to, together with the amount held on deposit.
     **/
    proxies(arg: AccountId32Like): Promise<[Array<PalletProxyProxyDefinition>, bigint]>;
    proxies(arg: AccountId32Like, callback: Callback<[Array<PalletProxyProxyDefinition>, bigint]>): Promise<Unsub>;

    /**
     * The announcements made by the proxy (key).
     **/
    announcements(arg: AccountId32Like): Promise<[Array<PalletProxyAnnouncement>, bigint]>;
    announcements(arg: AccountId32Like, callback: Callback<[Array<PalletProxyAnnouncement>, bigint]>): Promise<Unsub>;
  };
  multisig: {
    /**
     * The set of open multisig operations.
     **/
    multisigs(arg: [AccountId32Like, FixedBytes<32>]): Promise<PalletMultisigMultisig | undefined>;
    multisigs(
      arg: [AccountId32Like, FixedBytes<32>],
      callback: Callback<PalletMultisigMultisig | undefined>,
    ): Promise<Unsub>;
  };
  bounties: {
    /**
     * Number of bounty proposals that have been made.
     **/
    bountyCount(): Promise<number>;
    bountyCount(callback: Callback<number>): Promise<Unsub>;

    /**
     * Bounties that have been made.
     **/
    bounties(arg: number): Promise<PalletBountiesBounty | undefined>;
    bounties(arg: number, callback: Callback<PalletBountiesBounty | undefined>): Promise<Unsub>;

    /**
     * The description of each bounty.
     **/
    bountyDescriptions(arg: number): Promise<Bytes | undefined>;
    bountyDescriptions(arg: number, callback: Callback<Bytes | undefined>): Promise<Unsub>;

    /**
     * Bounty indices that have been approved but not yet funded.
     **/
    bountyApprovals(): Promise<Array<number>>;
    bountyApprovals(callback: Callback<Array<number>>): Promise<Unsub>;
  };
  childBounties: {
    /**
     * Number of total child bounties.
     **/
    childBountyCount(): Promise<number>;
    childBountyCount(callback: Callback<number>): Promise<Unsub>;

    /**
     * Number of child bounties per parent bounty.
     * Map of parent bounty index to number of child bounties.
     **/
    parentChildBounties(arg: number): Promise<number>;
    parentChildBounties(arg: number, callback: Callback<number>): Promise<Unsub>;

    /**
     * Child bounties that have been added.
     **/
    childBounties(arg: [number, number]): Promise<PalletChildBountiesChildBounty | undefined>;
    childBounties(
      arg: [number, number],
      callback: Callback<PalletChildBountiesChildBounty | undefined>,
    ): Promise<Unsub>;

    /**
     * The description of each child-bounty.
     **/
    childBountyDescriptions(arg: number): Promise<Bytes | undefined>;
    childBountyDescriptions(arg: number, callback: Callback<Bytes | undefined>): Promise<Unsub>;

    /**
     * The cumulative child-bounty curator fee for each parent bounty.
     **/
    childrenCuratorFees(arg: number): Promise<bigint>;
    childrenCuratorFees(arg: number, callback: Callback<bigint>): Promise<Unsub>;
  };
  electionProviderMultiPhase: {
    /**
     * Internal counter for the number of rounds.
     *
     * This is useful for de-duplication of transactions submitted to the pool, and general
     * diagnostics of the pallet.
     *
     * This is merely incremented once per every time that an upstream `elect` is called.
     **/
    round(): Promise<number>;
    round(callback: Callback<number>): Promise<Unsub>;

    /**
     * Current phase.
     **/
    currentPhase(): Promise<PalletElectionProviderMultiPhasePhase>;
    currentPhase(callback: Callback<PalletElectionProviderMultiPhasePhase>): Promise<Unsub>;

    /**
     * Current best solution, signed or unsigned, queued to be returned upon `elect`.
     *
     * Always sorted by score.
     **/
    queuedSolution(): Promise<PalletElectionProviderMultiPhaseReadySolution | undefined>;
    queuedSolution(callback: Callback<PalletElectionProviderMultiPhaseReadySolution | undefined>): Promise<Unsub>;

    /**
     * Snapshot data of the round.
     *
     * This is created at the beginning of the signed phase and cleared upon calling `elect`.
     **/
    snapshot(): Promise<PalletElectionProviderMultiPhaseRoundSnapshot | undefined>;
    snapshot(callback: Callback<PalletElectionProviderMultiPhaseRoundSnapshot | undefined>): Promise<Unsub>;

    /**
     * Desired number of targets to elect for this round.
     *
     * Only exists when [`Snapshot`] is present.
     **/
    desiredTargets(): Promise<number | undefined>;
    desiredTargets(callback: Callback<number | undefined>): Promise<Unsub>;

    /**
     * The metadata of the [`RoundSnapshot`]
     *
     * Only exists when [`Snapshot`] is present.
     **/
    snapshotMetadata(): Promise<PalletElectionProviderMultiPhaseSolutionOrSnapshotSize | undefined>;
    snapshotMetadata(
      callback: Callback<PalletElectionProviderMultiPhaseSolutionOrSnapshotSize | undefined>,
    ): Promise<Unsub>;

    /**
     * The next index to be assigned to an incoming signed submission.
     *
     * Every accepted submission is assigned a unique index; that index is bound to that particular
     * submission for the duration of the election. On election finalization, the next index is
     * reset to 0.
     *
     * We can't just use `SignedSubmissionIndices.len()`, because that's a bounded set; past its
     * capacity, it will simply saturate. We can't just iterate over `SignedSubmissionsMap`,
     * because iteration is slow. Instead, we store the value here.
     **/
    signedSubmissionNextIndex(): Promise<number>;
    signedSubmissionNextIndex(callback: Callback<number>): Promise<Unsub>;

    /**
     * A sorted, bounded vector of `(score, block_number, index)`, where each `index` points to a
     * value in `SignedSubmissions`.
     *
     * We never need to process more than a single signed submission at a time. Signed submissions
     * can be quite large, so we're willing to pay the cost of multiple database accesses to access
     * them one at a time instead of reading and decoding all of them at once.
     **/
    signedSubmissionIndices(): Promise<Array<[SpNposElectionsElectionScore, number, number]>>;
    signedSubmissionIndices(callback: Callback<Array<[SpNposElectionsElectionScore, number, number]>>): Promise<Unsub>;

    /**
     * Unchecked, signed solutions.
     *
     * Together with `SubmissionIndices`, this stores a bounded set of `SignedSubmissions` while
     * allowing us to keep only a single one in memory at a time.
     *
     * Twox note: the key of the map is an auto-incrementing index which users cannot inspect or
     * affect; we shouldn't need a cryptographically secure hasher.
     **/
    signedSubmissionsMap(arg: number): Promise<PalletElectionProviderMultiPhaseSignedSignedSubmission | undefined>;
    signedSubmissionsMap(
      arg: number,
      callback: Callback<PalletElectionProviderMultiPhaseSignedSignedSubmission | undefined>,
    ): Promise<Unsub>;

    /**
     * The minimum score that each 'untrusted' solution must attain in order to be considered
     * feasible.
     *
     * Can be set via `set_minimum_untrusted_score`.
     **/
    minimumUntrustedScore(): Promise<SpNposElectionsElectionScore | undefined>;
    minimumUntrustedScore(callback: Callback<SpNposElectionsElectionScore | undefined>): Promise<Unsub>;
  };
  voterList: {
    /**
     * A single node, within some bag.
     *
     * Nodes store links forward and back within their respective bags.
     **/
    listNodes(arg: AccountId32Like): Promise<PalletBagsListListNode | undefined>;
    listNodes(arg: AccountId32Like, callback: Callback<PalletBagsListListNode | undefined>): Promise<Unsub>;

    /**
     * Counter for the related counted storage map
     **/
    counterForListNodes(): Promise<number>;
    counterForListNodes(callback: Callback<number>): Promise<Unsub>;

    /**
     * A bag stored in storage.
     *
     * Stores a `Bag` struct, which stores head and tail pointers to itself.
     **/
    listBags(arg: bigint): Promise<PalletBagsListListBag | undefined>;
    listBags(arg: bigint, callback: Callback<PalletBagsListListBag | undefined>): Promise<Unsub>;
  };
  nominationPools: {
    /**
     * Minimum amount to bond to join a pool.
     **/
    minJoinBond(): Promise<bigint>;
    minJoinBond(callback: Callback<bigint>): Promise<Unsub>;

    /**
     * Minimum bond required to create a pool.
     *
     * This is the amount that the depositor must put as their initial stake in the pool, as an
     * indication of "skin in the game".
     *
     * This is the value that will always exist in the staking ledger of the pool bonded account
     * while all other accounts leave.
     **/
    minCreateBond(): Promise<bigint>;
    minCreateBond(callback: Callback<bigint>): Promise<Unsub>;

    /**
     * Maximum number of nomination pools that can exist. If `None`, then an unbounded number of
     * pools can exist.
     **/
    maxPools(): Promise<number | undefined>;
    maxPools(callback: Callback<number | undefined>): Promise<Unsub>;

    /**
     * Maximum number of members that can exist in the system. If `None`, then the count
     * members are not bound on a system wide basis.
     **/
    maxPoolMembers(): Promise<number | undefined>;
    maxPoolMembers(callback: Callback<number | undefined>): Promise<Unsub>;

    /**
     * Maximum number of members that may belong to pool. If `None`, then the count of
     * members is not bound on a per pool basis.
     **/
    maxPoolMembersPerPool(): Promise<number | undefined>;
    maxPoolMembersPerPool(callback: Callback<number | undefined>): Promise<Unsub>;

    /**
     * The maximum commission that can be charged by a pool. Used on commission payouts to bound
     * pool commissions that are > `GlobalMaxCommission`, necessary if a future
     * `GlobalMaxCommission` is lower than some current pool commissions.
     **/
    globalMaxCommission(): Promise<Perbill | undefined>;
    globalMaxCommission(callback: Callback<Perbill | undefined>): Promise<Unsub>;

    /**
     * Active members.
     *
     * TWOX-NOTE: SAFE since `AccountId` is a secure hash.
     **/
    poolMembers(arg: AccountId32Like): Promise<PalletNominationPoolsPoolMember | undefined>;
    poolMembers(arg: AccountId32Like, callback: Callback<PalletNominationPoolsPoolMember | undefined>): Promise<Unsub>;

    /**
     * Counter for the related counted storage map
     **/
    counterForPoolMembers(): Promise<number>;
    counterForPoolMembers(callback: Callback<number>): Promise<Unsub>;

    /**
     * Storage for bonded pools.
     **/
    bondedPools(arg: number): Promise<PalletNominationPoolsBondedPoolInner | undefined>;
    bondedPools(arg: number, callback: Callback<PalletNominationPoolsBondedPoolInner | undefined>): Promise<Unsub>;

    /**
     * Counter for the related counted storage map
     **/
    counterForBondedPools(): Promise<number>;
    counterForBondedPools(callback: Callback<number>): Promise<Unsub>;

    /**
     * Reward pools. This is where there rewards for each pool accumulate. When a members payout is
     * claimed, the balance comes out fo the reward pool. Keyed by the bonded pools account.
     **/
    rewardPools(arg: number): Promise<PalletNominationPoolsRewardPool | undefined>;
    rewardPools(arg: number, callback: Callback<PalletNominationPoolsRewardPool | undefined>): Promise<Unsub>;

    /**
     * Counter for the related counted storage map
     **/
    counterForRewardPools(): Promise<number>;
    counterForRewardPools(callback: Callback<number>): Promise<Unsub>;

    /**
     * Groups of unbonding pools. Each group of unbonding pools belongs to a
     * bonded pool, hence the name sub-pools. Keyed by the bonded pools account.
     **/
    subPoolsStorage(arg: number): Promise<PalletNominationPoolsSubPools | undefined>;
    subPoolsStorage(arg: number, callback: Callback<PalletNominationPoolsSubPools | undefined>): Promise<Unsub>;

    /**
     * Counter for the related counted storage map
     **/
    counterForSubPoolsStorage(): Promise<number>;
    counterForSubPoolsStorage(callback: Callback<number>): Promise<Unsub>;

    /**
     * Metadata for the pool.
     **/
    metadata(arg: number): Promise<Bytes>;
    metadata(arg: number, callback: Callback<Bytes>): Promise<Unsub>;

    /**
     * Counter for the related counted storage map
     **/
    counterForMetadata(): Promise<number>;
    counterForMetadata(callback: Callback<number>): Promise<Unsub>;

    /**
     * Ever increasing number of all pools created so far.
     **/
    lastPoolId(): Promise<number>;
    lastPoolId(callback: Callback<number>): Promise<Unsub>;

    /**
     * A reverse lookup from the pool's account id to its id.
     *
     * This is only used for slashing. In all other instances, the pool id is used, and the
     * accounts are deterministically derived from it.
     **/
    reversePoolIdLookup(arg: AccountId32Like): Promise<number | undefined>;
    reversePoolIdLookup(arg: AccountId32Like, callback: Callback<number | undefined>): Promise<Unsub>;

    /**
     * Counter for the related counted storage map
     **/
    counterForReversePoolIdLookup(): Promise<number>;
    counterForReversePoolIdLookup(callback: Callback<number>): Promise<Unsub>;

    /**
     * Map from a pool member account to their opted claim permission.
     **/
    claimPermissions(arg: AccountId32Like): Promise<PalletNominationPoolsClaimPermission>;
    claimPermissions(arg: AccountId32Like, callback: Callback<PalletNominationPoolsClaimPermission>): Promise<Unsub>;
  };
  fastUnstake: {
    /**
     * The current "head of the queue" being unstaked.
     *
     * The head in itself can be a batch of up to [`Config::BatchSize`] stakers.
     **/
    head(): Promise<PalletFastUnstakeUnstakeRequest | undefined>;
    head(callback: Callback<PalletFastUnstakeUnstakeRequest | undefined>): Promise<Unsub>;

    /**
     * The map of all accounts wishing to be unstaked.
     *
     * Keeps track of `AccountId` wishing to unstake and it's corresponding deposit.
     **/
    queue(arg: AccountId32Like): Promise<bigint | undefined>;
    queue(arg: AccountId32Like, callback: Callback<bigint | undefined>): Promise<Unsub>;

    /**
     * Counter for the related counted storage map
     **/
    counterForQueue(): Promise<number>;
    counterForQueue(callback: Callback<number>): Promise<Unsub>;

    /**
     * Number of eras to check per block.
     *
     * If set to 0, this pallet does absolutely nothing. Cannot be set to more than
     * [`Config::MaxErasToCheckPerBlock`].
     *
     * Based on the amount of weight available at [`Pallet::on_idle`], up to this many eras are
     * checked. The checking is represented by updating [`UnstakeRequest::checked`], which is
     * stored in [`Head`].
     **/
    erasToCheckPerBlock(): Promise<number>;
    erasToCheckPerBlock(callback: Callback<number>): Promise<Unsub>;
  };
  configuration: {
    /**
     * The active configuration for the current session.
     **/
    activeConfig(): Promise<PolkadotRuntimeParachainsConfigurationHostConfiguration>;
    activeConfig(callback: Callback<PolkadotRuntimeParachainsConfigurationHostConfiguration>): Promise<Unsub>;

    /**
     * Pending configuration changes.
     *
     * This is a list of configuration changes, each with a session index at which it should
     * be applied.
     *
     * The list is sorted ascending by session index. Also, this list can only contain at most
     * 2 items: for the next session and for the `scheduled_session`.
     **/
    pendingConfigs(): Promise<Array<[number, PolkadotRuntimeParachainsConfigurationHostConfiguration]>>;
    pendingConfigs(
      callback: Callback<Array<[number, PolkadotRuntimeParachainsConfigurationHostConfiguration]>>,
    ): Promise<Unsub>;

    /**
     * If this is set, then the configuration setters will bypass the consistency checks. This
     * is meant to be used only as the last resort.
     **/
    bypassConsistencyCheck(): Promise<boolean>;
    bypassConsistencyCheck(callback: Callback<boolean>): Promise<Unsub>;
  };
  parasShared: {
    /**
     * The current session index.
     **/
    currentSessionIndex(): Promise<number>;
    currentSessionIndex(callback: Callback<number>): Promise<Unsub>;

    /**
     * All the validators actively participating in parachain consensus.
     * Indices are into the broader validator set.
     **/
    activeValidatorIndices(): Promise<Array<PolkadotPrimitivesV5ValidatorIndex>>;
    activeValidatorIndices(callback: Callback<Array<PolkadotPrimitivesV5ValidatorIndex>>): Promise<Unsub>;

    /**
     * The parachain attestation keys of the validators actively participating in parachain
     * consensus. This should be the same length as `ActiveValidatorIndices`.
     **/
    activeValidatorKeys(): Promise<Array<PolkadotPrimitivesV5ValidatorAppPublic>>;
    activeValidatorKeys(callback: Callback<Array<PolkadotPrimitivesV5ValidatorAppPublic>>): Promise<Unsub>;

    /**
     * All allowed relay-parents.
     **/
    allowedRelayParents(): Promise<PolkadotRuntimeParachainsSharedAllowedRelayParentsTracker>;
    allowedRelayParents(callback: Callback<PolkadotRuntimeParachainsSharedAllowedRelayParentsTracker>): Promise<Unsub>;
  };
  paraInclusion: {
    /**
     * The latest bitfield for each validator, referred to by their index in the validator set.
     **/
    availabilityBitfields(
      arg: PolkadotPrimitivesV5ValidatorIndex,
    ): Promise<PolkadotRuntimeParachainsInclusionAvailabilityBitfieldRecord | undefined>;
    availabilityBitfields(
      arg: PolkadotPrimitivesV5ValidatorIndex,
      callback: Callback<PolkadotRuntimeParachainsInclusionAvailabilityBitfieldRecord | undefined>,
    ): Promise<Unsub>;

    /**
     * Candidates pending availability by `ParaId`.
     **/
    pendingAvailability(
      arg: PolkadotParachainPrimitivesPrimitivesId,
    ): Promise<PolkadotRuntimeParachainsInclusionCandidatePendingAvailability | undefined>;
    pendingAvailability(
      arg: PolkadotParachainPrimitivesPrimitivesId,
      callback: Callback<PolkadotRuntimeParachainsInclusionCandidatePendingAvailability | undefined>,
    ): Promise<Unsub>;

    /**
     * The commitments of candidates pending availability, by `ParaId`.
     **/
    pendingAvailabilityCommitments(
      arg: PolkadotParachainPrimitivesPrimitivesId,
    ): Promise<PolkadotPrimitivesV5CandidateCommitments | undefined>;
    pendingAvailabilityCommitments(
      arg: PolkadotParachainPrimitivesPrimitivesId,
      callback: Callback<PolkadotPrimitivesV5CandidateCommitments | undefined>,
    ): Promise<Unsub>;
  };
  paraInherent: {
    /**
     * Whether the paras inherent was included within this block.
     *
     * The `Option<()>` is effectively a `bool`, but it never hits storage in the `None` variant
     * due to the guarantees of FRAME's storage APIs.
     *
     * If this is `None` at the end of the block, we panic and render the block invalid.
     **/
    included(): Promise<[] | undefined>;
    included(callback: Callback<[] | undefined>): Promise<Unsub>;

    /**
     * Scraped on chain data for extracting resolved disputes as well as backing votes.
     **/
    onChainVotes(): Promise<PolkadotPrimitivesV5ScrapedOnChainVotes | undefined>;
    onChainVotes(callback: Callback<PolkadotPrimitivesV5ScrapedOnChainVotes | undefined>): Promise<Unsub>;
  };
  paraScheduler: {
    /**
     * All the validator groups. One for each core. Indices are into `ActiveValidators` - not the
     * broader set of Polkadot validators, but instead just the subset used for parachains during
     * this session.
     *
     * Bound: The number of cores is the sum of the numbers of parachains and parathread
     * multiplexers. Reasonably, 100-1000. The dominant factor is the number of validators: safe
     * upper bound at 10k.
     **/
    validatorGroups(): Promise<Array<Array<PolkadotPrimitivesV5ValidatorIndex>>>;
    validatorGroups(callback: Callback<Array<Array<PolkadotPrimitivesV5ValidatorIndex>>>): Promise<Unsub>;

    /**
     * One entry for each availability core. Entries are `None` if the core is not currently
     * occupied. Can be temporarily `Some` if scheduled but not occupied.
     * The i'th parachain belongs to the i'th core, with the remaining cores all being
     * parathread-multiplexers.
     *
     * Bounded by the maximum of either of these two values:
     * * The number of parachains and parathread multiplexers
     * * The number of validators divided by `configuration.max_validators_per_core`.
     **/
    availabilityCores(): Promise<Array<PolkadotPrimitivesV5CoreOccupied>>;
    availabilityCores(callback: Callback<Array<PolkadotPrimitivesV5CoreOccupied>>): Promise<Unsub>;

    /**
     * The block number where the session start occurred. Used to track how many group rotations
     * have occurred.
     *
     * Note that in the context of parachains modules the session change is signaled during
     * the block and enacted at the end of the block (at the finalization stage, to be exact).
     * Thus for all intents and purposes the effect of the session change is observed at the
     * block following the session change, block number of which we save in this storage value.
     **/
    sessionStartBlock(): Promise<number>;
    sessionStartBlock(callback: Callback<number>): Promise<Unsub>;

    /**
     * One entry for each availability core. The `VecDeque` represents the assignments to be
     * scheduled on that core. `None` is used to signal to not schedule the next para of the core
     * as there is one currently being scheduled. Not using `None` here would overwrite the
     * `CoreState` in the runtime API. The value contained here will not be valid after the end of
     * a block. Runtime APIs should be used to determine scheduled cores/ for the upcoming block.
     **/
    claimQueue(): Promise<Array<[PolkadotPrimitivesV5CoreIndex, Array<PolkadotPrimitivesV5ParasEntry | undefined>]>>;
    claimQueue(
      callback: Callback<Array<[PolkadotPrimitivesV5CoreIndex, Array<PolkadotPrimitivesV5ParasEntry | undefined>]>>,
    ): Promise<Unsub>;
  };
  paras: {
    /**
     * All currently active PVF pre-checking votes.
     *
     * Invariant:
     * - There are no PVF pre-checking votes that exists in list but not in the set and vice versa.
     **/
    pvfActiveVoteMap(
      arg: PolkadotParachainPrimitivesPrimitivesValidationCodeHash,
    ): Promise<PolkadotRuntimeParachainsParasPvfCheckActiveVoteState | undefined>;
    pvfActiveVoteMap(
      arg: PolkadotParachainPrimitivesPrimitivesValidationCodeHash,
      callback: Callback<PolkadotRuntimeParachainsParasPvfCheckActiveVoteState | undefined>,
    ): Promise<Unsub>;

    /**
     * The list of all currently active PVF votes. Auxiliary to `PvfActiveVoteMap`.
     **/
    pvfActiveVoteList(): Promise<Array<PolkadotParachainPrimitivesPrimitivesValidationCodeHash>>;
    pvfActiveVoteList(
      callback: Callback<Array<PolkadotParachainPrimitivesPrimitivesValidationCodeHash>>,
    ): Promise<Unsub>;

    /**
     * All lease holding parachains. Ordered ascending by `ParaId`. On demand parachains are not
     * included.
     *
     * Consider using the [`ParachainsCache`] type of modifying.
     **/
    parachains(): Promise<Array<PolkadotParachainPrimitivesPrimitivesId>>;
    parachains(callback: Callback<Array<PolkadotParachainPrimitivesPrimitivesId>>): Promise<Unsub>;

    /**
     * The current lifecycle of a all known Para IDs.
     **/
    paraLifecycles(
      arg: PolkadotParachainPrimitivesPrimitivesId,
    ): Promise<PolkadotRuntimeParachainsParasParaLifecycle | undefined>;
    paraLifecycles(
      arg: PolkadotParachainPrimitivesPrimitivesId,
      callback: Callback<PolkadotRuntimeParachainsParasParaLifecycle | undefined>,
    ): Promise<Unsub>;

    /**
     * The head-data of every registered para.
     **/
    heads(
      arg: PolkadotParachainPrimitivesPrimitivesId,
    ): Promise<PolkadotParachainPrimitivesPrimitivesHeadData | undefined>;
    heads(
      arg: PolkadotParachainPrimitivesPrimitivesId,
      callback: Callback<PolkadotParachainPrimitivesPrimitivesHeadData | undefined>,
    ): Promise<Unsub>;

    /**
     * The context (relay-chain block number) of the most recent parachain head.
     **/
    mostRecentContext(arg: PolkadotParachainPrimitivesPrimitivesId): Promise<number | undefined>;
    mostRecentContext(
      arg: PolkadotParachainPrimitivesPrimitivesId,
      callback: Callback<number | undefined>,
    ): Promise<Unsub>;

    /**
     * The validation code hash of every live para.
     *
     * Corresponding code can be retrieved with [`CodeByHash`].
     **/
    currentCodeHash(
      arg: PolkadotParachainPrimitivesPrimitivesId,
    ): Promise<PolkadotParachainPrimitivesPrimitivesValidationCodeHash | undefined>;
    currentCodeHash(
      arg: PolkadotParachainPrimitivesPrimitivesId,
      callback: Callback<PolkadotParachainPrimitivesPrimitivesValidationCodeHash | undefined>,
    ): Promise<Unsub>;

    /**
     * Actual past code hash, indicated by the para id as well as the block number at which it
     * became outdated.
     *
     * Corresponding code can be retrieved with [`CodeByHash`].
     **/
    pastCodeHash(
      arg: [PolkadotParachainPrimitivesPrimitivesId, number],
    ): Promise<PolkadotParachainPrimitivesPrimitivesValidationCodeHash | undefined>;
    pastCodeHash(
      arg: [PolkadotParachainPrimitivesPrimitivesId, number],
      callback: Callback<PolkadotParachainPrimitivesPrimitivesValidationCodeHash | undefined>,
    ): Promise<Unsub>;

    /**
     * Past code of parachains. The parachains themselves may not be registered anymore,
     * but we also keep their code on-chain for the same amount of time as outdated code
     * to keep it available for approval checkers.
     **/
    pastCodeMeta(arg: PolkadotParachainPrimitivesPrimitivesId): Promise<PolkadotRuntimeParachainsParasParaPastCodeMeta>;
    pastCodeMeta(
      arg: PolkadotParachainPrimitivesPrimitivesId,
      callback: Callback<PolkadotRuntimeParachainsParasParaPastCodeMeta>,
    ): Promise<Unsub>;

    /**
     * Which paras have past code that needs pruning and the relay-chain block at which the code
     * was replaced. Note that this is the actual height of the included block, not the expected
     * height at which the code upgrade would be applied, although they may be equal.
     * This is to ensure the entire acceptance period is covered, not an offset acceptance period
     * starting from the time at which the parachain perceives a code upgrade as having occurred.
     * Multiple entries for a single para are permitted. Ordered ascending by block number.
     **/
    pastCodePruning(): Promise<Array<[PolkadotParachainPrimitivesPrimitivesId, number]>>;
    pastCodePruning(callback: Callback<Array<[PolkadotParachainPrimitivesPrimitivesId, number]>>): Promise<Unsub>;

    /**
     * The block number at which the planned code change is expected for a para.
     * The change will be applied after the first parablock for this ID included which executes
     * in the context of a relay chain block with a number >= `expected_at`.
     **/
    futureCodeUpgrades(arg: PolkadotParachainPrimitivesPrimitivesId): Promise<number | undefined>;
    futureCodeUpgrades(
      arg: PolkadotParachainPrimitivesPrimitivesId,
      callback: Callback<number | undefined>,
    ): Promise<Unsub>;

    /**
     * The actual future code hash of a para.
     *
     * Corresponding code can be retrieved with [`CodeByHash`].
     **/
    futureCodeHash(
      arg: PolkadotParachainPrimitivesPrimitivesId,
    ): Promise<PolkadotParachainPrimitivesPrimitivesValidationCodeHash | undefined>;
    futureCodeHash(
      arg: PolkadotParachainPrimitivesPrimitivesId,
      callback: Callback<PolkadotParachainPrimitivesPrimitivesValidationCodeHash | undefined>,
    ): Promise<Unsub>;

    /**
     * This is used by the relay-chain to communicate to a parachain a go-ahead with in the upgrade
     * procedure.
     *
     * This value is absent when there are no upgrades scheduled or during the time the relay chain
     * performs the checks. It is set at the first relay-chain block when the corresponding
     * parachain can switch its upgrade function. As soon as the parachain's block is included, the
     * value gets reset to `None`.
     *
     * NOTE that this field is used by parachains via merkle storage proofs, therefore changing
     * the format will require migration of parachains.
     **/
    upgradeGoAheadSignal(
      arg: PolkadotParachainPrimitivesPrimitivesId,
    ): Promise<PolkadotPrimitivesV5UpgradeGoAhead | undefined>;
    upgradeGoAheadSignal(
      arg: PolkadotParachainPrimitivesPrimitivesId,
      callback: Callback<PolkadotPrimitivesV5UpgradeGoAhead | undefined>,
    ): Promise<Unsub>;

    /**
     * This is used by the relay-chain to communicate that there are restrictions for performing
     * an upgrade for this parachain.
     *
     * This may be a because the parachain waits for the upgrade cooldown to expire. Another
     * potential use case is when we want to perform some maintenance (such as storage migration)
     * we could restrict upgrades to make the process simpler.
     *
     * NOTE that this field is used by parachains via merkle storage proofs, therefore changing
     * the format will require migration of parachains.
     **/
    upgradeRestrictionSignal(
      arg: PolkadotParachainPrimitivesPrimitivesId,
    ): Promise<PolkadotPrimitivesV5UpgradeRestriction | undefined>;
    upgradeRestrictionSignal(
      arg: PolkadotParachainPrimitivesPrimitivesId,
      callback: Callback<PolkadotPrimitivesV5UpgradeRestriction | undefined>,
    ): Promise<Unsub>;

    /**
     * The list of parachains that are awaiting for their upgrade restriction to cooldown.
     *
     * Ordered ascending by block number.
     **/
    upgradeCooldowns(): Promise<Array<[PolkadotParachainPrimitivesPrimitivesId, number]>>;
    upgradeCooldowns(callback: Callback<Array<[PolkadotParachainPrimitivesPrimitivesId, number]>>): Promise<Unsub>;

    /**
     * The list of upcoming code upgrades. Each item is a pair of which para performs a code
     * upgrade and at which relay-chain block it is expected at.
     *
     * Ordered ascending by block number.
     **/
    upcomingUpgrades(): Promise<Array<[PolkadotParachainPrimitivesPrimitivesId, number]>>;
    upcomingUpgrades(callback: Callback<Array<[PolkadotParachainPrimitivesPrimitivesId, number]>>): Promise<Unsub>;

    /**
     * The actions to perform during the start of a specific session index.
     **/
    actionsQueue(arg: number): Promise<Array<PolkadotParachainPrimitivesPrimitivesId>>;
    actionsQueue(arg: number, callback: Callback<Array<PolkadotParachainPrimitivesPrimitivesId>>): Promise<Unsub>;

    /**
     * Upcoming paras instantiation arguments.
     *
     * NOTE that after PVF pre-checking is enabled the para genesis arg will have it's code set
     * to empty. Instead, the code will be saved into the storage right away via `CodeByHash`.
     **/
    upcomingParasGenesis(
      arg: PolkadotParachainPrimitivesPrimitivesId,
    ): Promise<PolkadotRuntimeParachainsParasParaGenesisArgs | undefined>;
    upcomingParasGenesis(
      arg: PolkadotParachainPrimitivesPrimitivesId,
      callback: Callback<PolkadotRuntimeParachainsParasParaGenesisArgs | undefined>,
    ): Promise<Unsub>;

    /**
     * The number of reference on the validation code in [`CodeByHash`] storage.
     **/
    codeByHashRefs(arg: PolkadotParachainPrimitivesPrimitivesValidationCodeHash): Promise<number>;
    codeByHashRefs(
      arg: PolkadotParachainPrimitivesPrimitivesValidationCodeHash,
      callback: Callback<number>,
    ): Promise<Unsub>;

    /**
     * Validation code stored by its hash.
     *
     * This storage is consistent with [`FutureCodeHash`], [`CurrentCodeHash`] and
     * [`PastCodeHash`].
     **/
    codeByHash(
      arg: PolkadotParachainPrimitivesPrimitivesValidationCodeHash,
    ): Promise<PolkadotParachainPrimitivesPrimitivesValidationCode | undefined>;
    codeByHash(
      arg: PolkadotParachainPrimitivesPrimitivesValidationCodeHash,
      callback: Callback<PolkadotParachainPrimitivesPrimitivesValidationCode | undefined>,
    ): Promise<Unsub>;
  };
  initializer: {
    /**
     * Whether the parachains modules have been initialized within this block.
     *
     * Semantically a `bool`, but this guarantees it should never hit the trie,
     * as this is cleared in `on_finalize` and Frame optimizes `None` values to be empty values.
     *
     * As a `bool`, `set(false)` and `remove()` both lead to the next `get()` being false, but one
     * of them writes to the trie and one does not. This confusion makes `Option<()>` more suitable
     * for the semantics of this variable.
     **/
    hasInitialized(): Promise<[] | undefined>;
    hasInitialized(callback: Callback<[] | undefined>): Promise<Unsub>;

    /**
     * Buffered session changes along with the block number at which they should be applied.
     *
     * Typically this will be empty or one element long. Apart from that this item never hits
     * the storage.
     *
     * However this is a `Vec` regardless to handle various edge cases that may occur at runtime
     * upgrade boundaries or if governance intervenes.
     **/
    bufferedSessionChanges(): Promise<Array<PolkadotRuntimeParachainsInitializerBufferedSessionChange>>;
    bufferedSessionChanges(
      callback: Callback<Array<PolkadotRuntimeParachainsInitializerBufferedSessionChange>>,
    ): Promise<Unsub>;
  };
  dmp: {
    /**
     * The downward messages addressed for a certain para.
     **/
    downwardMessageQueues(
      arg: PolkadotParachainPrimitivesPrimitivesId,
    ): Promise<Array<PolkadotCorePrimitivesInboundDownwardMessage>>;
    downwardMessageQueues(
      arg: PolkadotParachainPrimitivesPrimitivesId,
      callback: Callback<Array<PolkadotCorePrimitivesInboundDownwardMessage>>,
    ): Promise<Unsub>;

    /**
     * A mapping that stores the downward message queue MQC head for each para.
     *
     * Each link in this chain has a form:
     * `(prev_head, B, H(M))`, where
     * - `prev_head`: is the previous head hash or zero if none.
     * - `B`: is the relay-chain block number in which a message was appended.
     * - `H(M)`: is the hash of the message being appended.
     **/
    downwardMessageQueueHeads(arg: PolkadotParachainPrimitivesPrimitivesId): Promise<H256>;
    downwardMessageQueueHeads(arg: PolkadotParachainPrimitivesPrimitivesId, callback: Callback<H256>): Promise<Unsub>;

    /**
     * The number to multiply the base delivery fee by.
     **/
    deliveryFeeFactor(arg: PolkadotParachainPrimitivesPrimitivesId): Promise<FixedU128>;
    deliveryFeeFactor(arg: PolkadotParachainPrimitivesPrimitivesId, callback: Callback<FixedU128>): Promise<Unsub>;
  };
  hrmp: {
    /**
     * The set of pending HRMP open channel requests.
     *
     * The set is accompanied by a list for iteration.
     *
     * Invariant:
     * - There are no channels that exists in list but not in the set and vice versa.
     **/
    hrmpOpenChannelRequests(
      arg: PolkadotParachainPrimitivesPrimitivesHrmpChannelId,
    ): Promise<PolkadotRuntimeParachainsHrmpHrmpOpenChannelRequest | undefined>;
    hrmpOpenChannelRequests(
      arg: PolkadotParachainPrimitivesPrimitivesHrmpChannelId,
      callback: Callback<PolkadotRuntimeParachainsHrmpHrmpOpenChannelRequest | undefined>,
    ): Promise<Unsub>;
    hrmpOpenChannelRequestsList(): Promise<Array<PolkadotParachainPrimitivesPrimitivesHrmpChannelId>>;
    hrmpOpenChannelRequestsList(
      callback: Callback<Array<PolkadotParachainPrimitivesPrimitivesHrmpChannelId>>,
    ): Promise<Unsub>;

    /**
     * This mapping tracks how many open channel requests are initiated by a given sender para.
     * Invariant: `HrmpOpenChannelRequests` should contain the same number of items that has
     * `(X, _)` as the number of `HrmpOpenChannelRequestCount` for `X`.
     **/
    hrmpOpenChannelRequestCount(arg: PolkadotParachainPrimitivesPrimitivesId): Promise<number>;
    hrmpOpenChannelRequestCount(
      arg: PolkadotParachainPrimitivesPrimitivesId,
      callback: Callback<number>,
    ): Promise<Unsub>;

    /**
     * This mapping tracks how many open channel requests were accepted by a given recipient para.
     * Invariant: `HrmpOpenChannelRequests` should contain the same number of items `(_, X)` with
     * `confirmed` set to true, as the number of `HrmpAcceptedChannelRequestCount` for `X`.
     **/
    hrmpAcceptedChannelRequestCount(arg: PolkadotParachainPrimitivesPrimitivesId): Promise<number>;
    hrmpAcceptedChannelRequestCount(
      arg: PolkadotParachainPrimitivesPrimitivesId,
      callback: Callback<number>,
    ): Promise<Unsub>;

    /**
     * A set of pending HRMP close channel requests that are going to be closed during the session
     * change. Used for checking if a given channel is registered for closure.
     *
     * The set is accompanied by a list for iteration.
     *
     * Invariant:
     * - There are no channels that exists in list but not in the set and vice versa.
     **/
    hrmpCloseChannelRequests(arg: PolkadotParachainPrimitivesPrimitivesHrmpChannelId): Promise<[] | undefined>;
    hrmpCloseChannelRequests(
      arg: PolkadotParachainPrimitivesPrimitivesHrmpChannelId,
      callback: Callback<[] | undefined>,
    ): Promise<Unsub>;
    hrmpCloseChannelRequestsList(): Promise<Array<PolkadotParachainPrimitivesPrimitivesHrmpChannelId>>;
    hrmpCloseChannelRequestsList(
      callback: Callback<Array<PolkadotParachainPrimitivesPrimitivesHrmpChannelId>>,
    ): Promise<Unsub>;

    /**
     * The HRMP watermark associated with each para.
     * Invariant:
     * - each para `P` used here as a key should satisfy `Paras::is_valid_para(P)` within a
     * session.
     **/
    hrmpWatermarks(arg: PolkadotParachainPrimitivesPrimitivesId): Promise<number | undefined>;
    hrmpWatermarks(
      arg: PolkadotParachainPrimitivesPrimitivesId,
      callback: Callback<number | undefined>,
    ): Promise<Unsub>;

    /**
     * HRMP channel data associated with each para.
     * Invariant:
     * - each participant in the channel should satisfy `Paras::is_valid_para(P)` within a session.
     **/
    hrmpChannels(
      arg: PolkadotParachainPrimitivesPrimitivesHrmpChannelId,
    ): Promise<PolkadotRuntimeParachainsHrmpHrmpChannel | undefined>;
    hrmpChannels(
      arg: PolkadotParachainPrimitivesPrimitivesHrmpChannelId,
      callback: Callback<PolkadotRuntimeParachainsHrmpHrmpChannel | undefined>,
    ): Promise<Unsub>;

    /**
     * Ingress/egress indexes allow to find all the senders and receivers given the opposite side.
     * I.e.
     *
     * (a) ingress index allows to find all the senders for a given recipient.
     * (b) egress index allows to find all the recipients for a given sender.
     *
     * Invariants:
     * - for each ingress index entry for `P` each item `I` in the index should present in
     * `HrmpChannels` as `(I, P)`.
     * - for each egress index entry for `P` each item `E` in the index should present in
     * `HrmpChannels` as `(P, E)`.
     * - there should be no other dangling channels in `HrmpChannels`.
     * - the vectors are sorted.
     **/
    hrmpIngressChannelsIndex(
      arg: PolkadotParachainPrimitivesPrimitivesId,
    ): Promise<Array<PolkadotParachainPrimitivesPrimitivesId>>;
    hrmpIngressChannelsIndex(
      arg: PolkadotParachainPrimitivesPrimitivesId,
      callback: Callback<Array<PolkadotParachainPrimitivesPrimitivesId>>,
    ): Promise<Unsub>;
    hrmpEgressChannelsIndex(
      arg: PolkadotParachainPrimitivesPrimitivesId,
    ): Promise<Array<PolkadotParachainPrimitivesPrimitivesId>>;
    hrmpEgressChannelsIndex(
      arg: PolkadotParachainPrimitivesPrimitivesId,
      callback: Callback<Array<PolkadotParachainPrimitivesPrimitivesId>>,
    ): Promise<Unsub>;

    /**
     * Storage for the messages for each channel.
     * Invariant: cannot be non-empty if the corresponding channel in `HrmpChannels` is `None`.
     **/
    hrmpChannelContents(
      arg: PolkadotParachainPrimitivesPrimitivesHrmpChannelId,
    ): Promise<Array<PolkadotCorePrimitivesInboundHrmpMessage>>;
    hrmpChannelContents(
      arg: PolkadotParachainPrimitivesPrimitivesHrmpChannelId,
      callback: Callback<Array<PolkadotCorePrimitivesInboundHrmpMessage>>,
    ): Promise<Unsub>;

    /**
     * Maintains a mapping that can be used to answer the question: What paras sent a message at
     * the given block number for a given receiver. Invariants:
     * - The inner `Vec<ParaId>` is never empty.
     * - The inner `Vec<ParaId>` cannot store two same `ParaId`.
     * - The outer vector is sorted ascending by block number and cannot store two items with the
     * same block number.
     **/
    hrmpChannelDigests(
      arg: PolkadotParachainPrimitivesPrimitivesId,
    ): Promise<Array<[number, Array<PolkadotParachainPrimitivesPrimitivesId>]>>;
    hrmpChannelDigests(
      arg: PolkadotParachainPrimitivesPrimitivesId,
      callback: Callback<Array<[number, Array<PolkadotParachainPrimitivesPrimitivesId>]>>,
    ): Promise<Unsub>;
  };
  paraSessionInfo: {
    /**
     * Assignment keys for the current session.
     * Note that this API is private due to it being prone to 'off-by-one' at session boundaries.
     * When in doubt, use `Sessions` API instead.
     **/
    assignmentKeysUnsafe(): Promise<Array<PolkadotPrimitivesV5AssignmentAppPublic>>;
    assignmentKeysUnsafe(callback: Callback<Array<PolkadotPrimitivesV5AssignmentAppPublic>>): Promise<Unsub>;

    /**
     * The earliest session for which previous session info is stored.
     **/
    earliestStoredSession(): Promise<number>;
    earliestStoredSession(callback: Callback<number>): Promise<Unsub>;

    /**
     * Session information in a rolling window.
     * Should have an entry in range `EarliestStoredSession..=CurrentSessionIndex`.
     * Does not have any entries before the session index in the first session change notification.
     **/
    sessions(arg: number): Promise<PolkadotPrimitivesV5SessionInfo | undefined>;
    sessions(arg: number, callback: Callback<PolkadotPrimitivesV5SessionInfo | undefined>): Promise<Unsub>;

    /**
     * The validator account keys of the validators actively participating in parachain consensus.
     **/
    accountKeys(arg: number): Promise<Array<AccountId32> | undefined>;
    accountKeys(arg: number, callback: Callback<Array<AccountId32> | undefined>): Promise<Unsub>;

    /**
     * Executor parameter set for a given session index
     **/
    sessionExecutorParams(arg: number): Promise<PolkadotPrimitivesV5ExecutorParams | undefined>;
    sessionExecutorParams(
      arg: number,
      callback: Callback<PolkadotPrimitivesV5ExecutorParams | undefined>,
    ): Promise<Unsub>;
  };
  parasDisputes: {
    /**
     * The last pruned session, if any. All data stored by this module
     * references sessions.
     **/
    lastPrunedSession(): Promise<number | undefined>;
    lastPrunedSession(callback: Callback<number | undefined>): Promise<Unsub>;

    /**
     * All ongoing or concluded disputes for the last several sessions.
     **/
    disputes(arg: [number, PolkadotCorePrimitivesCandidateHash]): Promise<PolkadotPrimitivesV5DisputeState | undefined>;
    disputes(
      arg: [number, PolkadotCorePrimitivesCandidateHash],
      callback: Callback<PolkadotPrimitivesV5DisputeState | undefined>,
    ): Promise<Unsub>;

    /**
     * Backing votes stored for each dispute.
     * This storage is used for slashing.
     **/
    backersOnDisputes(
      arg: [number, PolkadotCorePrimitivesCandidateHash],
    ): Promise<Array<PolkadotPrimitivesV5ValidatorIndex> | undefined>;
    backersOnDisputes(
      arg: [number, PolkadotCorePrimitivesCandidateHash],
      callback: Callback<Array<PolkadotPrimitivesV5ValidatorIndex> | undefined>,
    ): Promise<Unsub>;

    /**
     * All included blocks on the chain, as well as the block number in this chain that
     * should be reverted back to if the candidate is disputed and determined to be invalid.
     **/
    included(arg: [number, PolkadotCorePrimitivesCandidateHash]): Promise<number | undefined>;
    included(
      arg: [number, PolkadotCorePrimitivesCandidateHash],
      callback: Callback<number | undefined>,
    ): Promise<Unsub>;

    /**
     * Whether the chain is frozen. Starts as `None`. When this is `Some`,
     * the chain will not accept any new parachain blocks for backing or inclusion,
     * and its value indicates the last valid block number in the chain.
     * It can only be set back to `None` by governance intervention.
     **/
    frozen(): Promise<number | undefined>;
    frozen(callback: Callback<number | undefined>): Promise<Unsub>;
  };
  parasSlashing: {
    /**
     * Validators pending dispute slashes.
     **/
    unappliedSlashes(
      arg: [number, PolkadotCorePrimitivesCandidateHash],
    ): Promise<PolkadotPrimitivesV5SlashingPendingSlashes | undefined>;
    unappliedSlashes(
      arg: [number, PolkadotCorePrimitivesCandidateHash],
      callback: Callback<PolkadotPrimitivesV5SlashingPendingSlashes | undefined>,
    ): Promise<Unsub>;

    /**
     * `ValidatorSetCount` per session.
     **/
    validatorSetCounts(arg: number): Promise<number | undefined>;
    validatorSetCounts(arg: number, callback: Callback<number | undefined>): Promise<Unsub>;
  };
  registrar: {
    /**
     * Pending swap operations.
     **/
    pendingSwap(
      arg: PolkadotParachainPrimitivesPrimitivesId,
    ): Promise<PolkadotParachainPrimitivesPrimitivesId | undefined>;
    pendingSwap(
      arg: PolkadotParachainPrimitivesPrimitivesId,
      callback: Callback<PolkadotParachainPrimitivesPrimitivesId | undefined>,
    ): Promise<Unsub>;

    /**
     * Amount held on deposit for each para and the original depositor.
     *
     * The given account ID is responsible for registering the code and initial head data, but may
     * only do so if it isn't yet registered. (After that, it's up to governance to do so.)
     **/
    paras(
      arg: PolkadotParachainPrimitivesPrimitivesId,
    ): Promise<PolkadotRuntimeCommonParasRegistrarParaInfo | undefined>;
    paras(
      arg: PolkadotParachainPrimitivesPrimitivesId,
      callback: Callback<PolkadotRuntimeCommonParasRegistrarParaInfo | undefined>,
    ): Promise<Unsub>;

    /**
     * The next free `ParaId`.
     **/
    nextFreeParaId(): Promise<PolkadotParachainPrimitivesPrimitivesId>;
    nextFreeParaId(callback: Callback<PolkadotParachainPrimitivesPrimitivesId>): Promise<Unsub>;
  };
  slots: {
    /**
     * Amounts held on deposit for each (possibly future) leased parachain.
     *
     * The actual amount locked on its behalf by any account at any time is the maximum of the
     * second values of the items in this list whose first value is the account.
     *
     * The first item in the list is the amount locked for the current Lease Period. Following
     * items are for the subsequent lease periods.
     *
     * The default value (an empty list) implies that the parachain no longer exists (or never
     * existed) as far as this pallet is concerned.
     *
     * If a parachain doesn't exist *yet* but is scheduled to exist in the future, then it
     * will be left-padded with one or more `None`s to denote the fact that nothing is held on
     * deposit for the non-existent chain currently, but is held at some point in the future.
     *
     * It is illegal for a `None` value to trail in the list.
     **/
    leases(arg: PolkadotParachainPrimitivesPrimitivesId): Promise<Array<[AccountId32, bigint] | undefined>>;
    leases(
      arg: PolkadotParachainPrimitivesPrimitivesId,
      callback: Callback<Array<[AccountId32, bigint] | undefined>>,
    ): Promise<Unsub>;
  };
  auctions: {
    /**
     * Number of auctions started so far.
     **/
    auctionCounter(): Promise<number>;
    auctionCounter(callback: Callback<number>): Promise<Unsub>;

    /**
     * Information relating to the current auction, if there is one.
     *
     * The first item in the tuple is the lease period index that the first of the four
     * contiguous lease periods on auction is for. The second is the block number when the
     * auction will "begin to end", i.e. the first block of the Ending Period of the auction.
     **/
    auctionInfo(): Promise<[number, number] | undefined>;
    auctionInfo(callback: Callback<[number, number] | undefined>): Promise<Unsub>;

    /**
     * Amounts currently reserved in the accounts of the bidders currently winning
     * (sub-)ranges.
     **/
    reservedAmounts(arg: [AccountId32Like, PolkadotParachainPrimitivesPrimitivesId]): Promise<bigint | undefined>;
    reservedAmounts(
      arg: [AccountId32Like, PolkadotParachainPrimitivesPrimitivesId],
      callback: Callback<bigint | undefined>,
    ): Promise<Unsub>;

    /**
     * The winning bids for each of the 10 ranges at each sample in the final Ending Period of
     * the current auction. The map's key is the 0-based index into the Sample Size. The
     * first sample of the ending period is 0; the last is `Sample Size - 1`.
     **/
    winning(
      arg: number,
    ): Promise<FixedArray<[AccountId32, PolkadotParachainPrimitivesPrimitivesId, bigint] | undefined, 36> | undefined>;
    winning(
      arg: number,
      callback: Callback<
        FixedArray<[AccountId32, PolkadotParachainPrimitivesPrimitivesId, bigint] | undefined, 36> | undefined
      >,
    ): Promise<Unsub>;
  };
  crowdloan: {
    /**
     * Info on all of the funds.
     **/
    funds(arg: PolkadotParachainPrimitivesPrimitivesId): Promise<PolkadotRuntimeCommonCrowdloanFundInfo | undefined>;
    funds(
      arg: PolkadotParachainPrimitivesPrimitivesId,
      callback: Callback<PolkadotRuntimeCommonCrowdloanFundInfo | undefined>,
    ): Promise<Unsub>;

    /**
     * The funds that have had additional contributions during the last block. This is used
     * in order to determine which funds should submit new or updated bids.
     **/
    newRaise(): Promise<Array<PolkadotParachainPrimitivesPrimitivesId>>;
    newRaise(callback: Callback<Array<PolkadotParachainPrimitivesPrimitivesId>>): Promise<Unsub>;

    /**
     * The number of auctions that have entered into their ending period so far.
     **/
    endingsCount(): Promise<number>;
    endingsCount(callback: Callback<number>): Promise<Unsub>;

    /**
     * Tracker for the next available fund index
     **/
    nextFundIndex(): Promise<number>;
    nextFundIndex(callback: Callback<number>): Promise<Unsub>;
  };
  xcmPallet: {
    /**
     * The latest available query index.
     **/
    queryCounter(): Promise<bigint>;
    queryCounter(callback: Callback<bigint>): Promise<Unsub>;

    /**
     * The ongoing queries.
     **/
    queries(arg: bigint): Promise<PalletXcmQueryStatus | undefined>;
    queries(arg: bigint, callback: Callback<PalletXcmQueryStatus | undefined>): Promise<Unsub>;

    /**
     * The existing asset traps.
     *
     * Key is the blake2 256 hash of (origin, versioned `MultiAssets`) pair. Value is the number of
     * times this pair has been trapped (usually just 1 if it exists at all).
     **/
    assetTraps(arg: H256): Promise<number>;
    assetTraps(arg: H256, callback: Callback<number>): Promise<Unsub>;

    /**
     * Default version to encode XCM when latest version of destination is unknown. If `None`,
     * then the destinations whose XCM version is unknown are considered unreachable.
     **/
    safeXcmVersion(): Promise<number | undefined>;
    safeXcmVersion(callback: Callback<number | undefined>): Promise<Unsub>;

    /**
     * The Latest versions that we know various locations support.
     **/
    supportedVersion(arg: [number, XcmVersionedMultiLocation]): Promise<number | undefined>;
    supportedVersion(arg: [number, XcmVersionedMultiLocation], callback: Callback<number | undefined>): Promise<Unsub>;

    /**
     * All locations that we have requested version notifications from.
     **/
    versionNotifiers(arg: [number, XcmVersionedMultiLocation]): Promise<bigint | undefined>;
    versionNotifiers(arg: [number, XcmVersionedMultiLocation], callback: Callback<bigint | undefined>): Promise<Unsub>;

    /**
     * The target locations that are subscribed to our version changes, as well as the most recent
     * of our versions we informed them of.
     **/
    versionNotifyTargets(
      arg: [number, XcmVersionedMultiLocation],
    ): Promise<[bigint, SpWeightsWeightV2Weight, number] | undefined>;
    versionNotifyTargets(
      arg: [number, XcmVersionedMultiLocation],
      callback: Callback<[bigint, SpWeightsWeightV2Weight, number] | undefined>,
    ): Promise<Unsub>;

    /**
     * Destinations whose latest XCM version we would like to know. Duplicates not allowed, and
     * the `u32` counter is the number of times that a send to the destination has been attempted,
     * which is used as a prioritization.
     **/
    versionDiscoveryQueue(): Promise<Array<[XcmVersionedMultiLocation, number]>>;
    versionDiscoveryQueue(callback: Callback<Array<[XcmVersionedMultiLocation, number]>>): Promise<Unsub>;

    /**
     * The current migration's stage, if any.
     **/
    currentMigration(): Promise<PalletXcmVersionMigrationStage | undefined>;
    currentMigration(callback: Callback<PalletXcmVersionMigrationStage | undefined>): Promise<Unsub>;

    /**
     * Fungible assets which we know are locked on a remote chain.
     **/
    remoteLockedFungibles(
      arg: [number, AccountId32Like, XcmVersionedAssetId],
    ): Promise<PalletXcmRemoteLockedFungibleRecord | undefined>;
    remoteLockedFungibles(
      arg: [number, AccountId32Like, XcmVersionedAssetId],
      callback: Callback<PalletXcmRemoteLockedFungibleRecord | undefined>,
    ): Promise<Unsub>;

    /**
     * Fungible assets which we know are locked on this chain.
     **/
    lockedFungibles(arg: AccountId32Like): Promise<Array<[bigint, XcmVersionedMultiLocation]> | undefined>;
    lockedFungibles(
      arg: AccountId32Like,
      callback: Callback<Array<[bigint, XcmVersionedMultiLocation]> | undefined>,
    ): Promise<Unsub>;

    /**
     * Global suspension state of the XCM executor.
     **/
    xcmExecutionSuspended(): Promise<boolean>;
    xcmExecutionSuspended(callback: Callback<boolean>): Promise<Unsub>;
  };
  messageQueue: {
    /**
     * The index of the first and last (non-empty) pages.
     **/
    bookStateFor(arg: PolkadotRuntimeParachainsInclusionAggregateMessageOrigin): Promise<PalletMessageQueueBookState>;
    bookStateFor(
      arg: PolkadotRuntimeParachainsInclusionAggregateMessageOrigin,
      callback: Callback<PalletMessageQueueBookState>,
    ): Promise<Unsub>;

    /**
     * The origin at which we should begin servicing.
     **/
    serviceHead(): Promise<PolkadotRuntimeParachainsInclusionAggregateMessageOrigin | undefined>;
    serviceHead(
      callback: Callback<PolkadotRuntimeParachainsInclusionAggregateMessageOrigin | undefined>,
    ): Promise<Unsub>;

    /**
     * The map of page indices to pages.
     **/
    pages(
      arg: [PolkadotRuntimeParachainsInclusionAggregateMessageOrigin, number],
    ): Promise<PalletMessageQueuePage | undefined>;
    pages(
      arg: [PolkadotRuntimeParachainsInclusionAggregateMessageOrigin, number],
      callback: Callback<PalletMessageQueuePage | undefined>,
    ): Promise<Unsub>;
  };
}
