// Generated by @delightfuldot/codegen

import type { GenericChainErrors, GenericModuleError } from '@delightfuldot/types';

export interface ChainErrors extends GenericChainErrors {
  system: {
    /**
     * The name of specification does not match between the current runtime
     * and the new runtime.
     **/
    invalidSpecName: GenericModuleError;

    /**
     * The specification version is not allowed to decrease between the current runtime
     * and the new runtime.
     **/
    specVersionNeedsToIncrease: GenericModuleError;

    /**
     * Failed to extract the runtime version from the new runtime.
     *
     * Either calling `Core_version` or decoding `RuntimeVersion` failed.
     **/
    failedToExtractRuntimeVersion: GenericModuleError;

    /**
     * Suicide called when the account has non-default composite data.
     **/
    nonDefaultComposite: GenericModuleError;

    /**
     * There is a non-zero reference count preventing the account from being purged.
     **/
    nonZeroRefCount: GenericModuleError;

    /**
     * The origin filter prevent the call to be dispatched.
     **/
    callFiltered: GenericModuleError;
  };
  babe: {
    /**
     * An equivocation proof provided as part of an equivocation report is invalid.
     **/
    invalidEquivocationProof: GenericModuleError;

    /**
     * A key ownership proof provided as part of an equivocation report is invalid.
     **/
    invalidKeyOwnershipProof: GenericModuleError;

    /**
     * A given equivocation report is valid but already previously reported.
     **/
    duplicateOffenceReport: GenericModuleError;

    /**
     * Submitted configuration is invalid.
     **/
    invalidConfiguration: GenericModuleError;
  };
  indices: {
    /**
     * The index was not already assigned.
     **/
    notAssigned: GenericModuleError;

    /**
     * The index is assigned to another account.
     **/
    notOwner: GenericModuleError;

    /**
     * The index was not available.
     **/
    inUse: GenericModuleError;

    /**
     * The source and destination accounts are identical.
     **/
    notTransfer: GenericModuleError;

    /**
     * The index is permanent and may not be freed/changed.
     **/
    permanent: GenericModuleError;
  };
  balances: {
    /**
     * Vesting balance too high to send value.
     **/
    vestingBalance: GenericModuleError;

    /**
     * Account liquidity restrictions prevent withdrawal.
     **/
    liquidityRestrictions: GenericModuleError;

    /**
     * Balance too low to send value.
     **/
    insufficientBalance: GenericModuleError;

    /**
     * Value too low to create account due to existential deposit.
     **/
    existentialDeposit: GenericModuleError;

    /**
     * Transfer/payment would kill account.
     **/
    expendability: GenericModuleError;

    /**
     * A vesting schedule already exists for this account.
     **/
    existingVestingSchedule: GenericModuleError;

    /**
     * Beneficiary account must pre-exist.
     **/
    deadAccount: GenericModuleError;

    /**
     * Number of named reserves exceed `MaxReserves`.
     **/
    tooManyReserves: GenericModuleError;

    /**
     * Number of holds exceed `MaxHolds`.
     **/
    tooManyHolds: GenericModuleError;

    /**
     * Number of freezes exceed `MaxFreezes`.
     **/
    tooManyFreezes: GenericModuleError;
  };
  staking: {
    /**
     * Not a controller account.
     **/
    notController: GenericModuleError;

    /**
     * Not a stash account.
     **/
    notStash: GenericModuleError;

    /**
     * Stash is already bonded.
     **/
    alreadyBonded: GenericModuleError;

    /**
     * Controller is already paired.
     **/
    alreadyPaired: GenericModuleError;

    /**
     * Targets cannot be empty.
     **/
    emptyTargets: GenericModuleError;

    /**
     * Duplicate index.
     **/
    duplicateIndex: GenericModuleError;

    /**
     * Slash record index out of bounds.
     **/
    invalidSlashIndex: GenericModuleError;

    /**
     * Cannot have a validator or nominator role, with value less than the minimum defined by
     * governance (see `MinValidatorBond` and `MinNominatorBond`). If unbonding is the
     * intention, `chill` first to remove one's role as validator/nominator.
     **/
    insufficientBond: GenericModuleError;

    /**
     * Can not schedule more unlock chunks.
     **/
    noMoreChunks: GenericModuleError;

    /**
     * Can not rebond without unlocking chunks.
     **/
    noUnlockChunk: GenericModuleError;

    /**
     * Attempting to target a stash that still has funds.
     **/
    fundedTarget: GenericModuleError;

    /**
     * Invalid era to reward.
     **/
    invalidEraToReward: GenericModuleError;

    /**
     * Invalid number of nominations.
     **/
    invalidNumberOfNominations: GenericModuleError;

    /**
     * Items are not sorted and unique.
     **/
    notSortedAndUnique: GenericModuleError;

    /**
     * Rewards for this era have already been claimed for this validator.
     **/
    alreadyClaimed: GenericModuleError;

    /**
     * Incorrect previous history depth input provided.
     **/
    incorrectHistoryDepth: GenericModuleError;

    /**
     * Incorrect number of slashing spans provided.
     **/
    incorrectSlashingSpans: GenericModuleError;

    /**
     * Internal state has become somehow corrupted and the operation cannot continue.
     **/
    badState: GenericModuleError;

    /**
     * Too many nomination targets supplied.
     **/
    tooManyTargets: GenericModuleError;

    /**
     * A nomination target was supplied that was blocked or otherwise not a validator.
     **/
    badTarget: GenericModuleError;

    /**
     * The user has enough bond and thus cannot be chilled forcefully by an external person.
     **/
    cannotChillOther: GenericModuleError;

    /**
     * There are too many nominators in the system. Governance needs to adjust the staking
     * settings to keep things safe for the runtime.
     **/
    tooManyNominators: GenericModuleError;

    /**
     * There are too many validator candidates in the system. Governance needs to adjust the
     * staking settings to keep things safe for the runtime.
     **/
    tooManyValidators: GenericModuleError;

    /**
     * Commission is too low. Must be at least `MinCommission`.
     **/
    commissionTooLow: GenericModuleError;

    /**
     * Some bound is not met.
     **/
    boundNotMet: GenericModuleError;
  };
  beefy: {
    /**
     * A key ownership proof provided as part of an equivocation report is invalid.
     **/
    invalidKeyOwnershipProof: GenericModuleError;

    /**
     * An equivocation proof provided as part of an equivocation report is invalid.
     **/
    invalidEquivocationProof: GenericModuleError;

    /**
     * A given equivocation report is valid but already previously reported.
     **/
    duplicateOffenceReport: GenericModuleError;
  };
  session: {
    /**
     * Invalid ownership proof.
     **/
    invalidProof: GenericModuleError;

    /**
     * No associated validator ID for account.
     **/
    noAssociatedValidatorId: GenericModuleError;

    /**
     * Registered duplicate key.
     **/
    duplicatedKey: GenericModuleError;

    /**
     * No keys are associated with this account.
     **/
    noKeys: GenericModuleError;

    /**
     * Key setting account is not live, so it's impossible to associate keys.
     **/
    noAccount: GenericModuleError;
  };
  grandpa: {
    /**
     * Attempt to signal GRANDPA pause when the authority set isn't live
     * (either paused or already pending pause).
     **/
    pauseFailed: GenericModuleError;

    /**
     * Attempt to signal GRANDPA resume when the authority set isn't paused
     * (either live or already pending resume).
     **/
    resumeFailed: GenericModuleError;

    /**
     * Attempt to signal GRANDPA change with one already pending.
     **/
    changePending: GenericModuleError;

    /**
     * Cannot signal forced change so soon after last.
     **/
    tooSoon: GenericModuleError;

    /**
     * A key ownership proof provided as part of an equivocation report is invalid.
     **/
    invalidKeyOwnershipProof: GenericModuleError;

    /**
     * An equivocation proof provided as part of an equivocation report is invalid.
     **/
    invalidEquivocationProof: GenericModuleError;

    /**
     * A given equivocation report is valid but already previously reported.
     **/
    duplicateOffenceReport: GenericModuleError;
  };
  imOnline: {
    /**
     * Non existent public key.
     **/
    invalidKey: GenericModuleError;

    /**
     * Duplicated heartbeat.
     **/
    duplicatedHeartbeat: GenericModuleError;
  };
  treasury: {
    /**
     * Proposer's balance is too low.
     **/
    insufficientProposersBalance: GenericModuleError;

    /**
     * No proposal or bounty at that index.
     **/
    invalidIndex: GenericModuleError;

    /**
     * Too many approvals in the queue.
     **/
    tooManyApprovals: GenericModuleError;

    /**
     * The spend origin is valid but the amount it is allowed to spend is lower than the
     * amount to be spent.
     **/
    insufficientPermission: GenericModuleError;

    /**
     * Proposal has not been approved.
     **/
    proposalNotApproved: GenericModuleError;
  };
  convictionVoting: {
    /**
     * Poll is not ongoing.
     **/
    notOngoing: GenericModuleError;

    /**
     * The given account did not vote on the poll.
     **/
    notVoter: GenericModuleError;

    /**
     * The actor has no permission to conduct the action.
     **/
    noPermission: GenericModuleError;

    /**
     * The actor has no permission to conduct the action right now but will do in the future.
     **/
    noPermissionYet: GenericModuleError;

    /**
     * The account is already delegating.
     **/
    alreadyDelegating: GenericModuleError;

    /**
     * The account currently has votes attached to it and the operation cannot succeed until
     * these are removed, either through `unvote` or `reap_vote`.
     **/
    alreadyVoting: GenericModuleError;

    /**
     * Too high a balance was provided that the account cannot afford.
     **/
    insufficientFunds: GenericModuleError;

    /**
     * The account is not currently delegating.
     **/
    notDelegating: GenericModuleError;

    /**
     * Delegation to oneself makes no sense.
     **/
    nonsense: GenericModuleError;

    /**
     * Maximum number of votes reached.
     **/
    maxVotesReached: GenericModuleError;

    /**
     * The class must be supplied since it is not easily determinable from the state.
     **/
    classNeeded: GenericModuleError;

    /**
     * The class ID supplied is invalid.
     **/
    badClass: GenericModuleError;
  };
  referenda: {
    /**
     * Referendum is not ongoing.
     **/
    notOngoing: GenericModuleError;

    /**
     * Referendum's decision deposit is already paid.
     **/
    hasDeposit: GenericModuleError;

    /**
     * The track identifier given was invalid.
     **/
    badTrack: GenericModuleError;

    /**
     * There are already a full complement of referenda in progress for this track.
     **/
    full: GenericModuleError;

    /**
     * The queue of the track is empty.
     **/
    queueEmpty: GenericModuleError;

    /**
     * The referendum index provided is invalid in this context.
     **/
    badReferendum: GenericModuleError;

    /**
     * There was nothing to do in the advancement.
     **/
    nothingToDo: GenericModuleError;

    /**
     * No track exists for the proposal origin.
     **/
    noTrack: GenericModuleError;

    /**
     * Any deposit cannot be refunded until after the decision is over.
     **/
    unfinished: GenericModuleError;

    /**
     * The deposit refunder is not the depositor.
     **/
    noPermission: GenericModuleError;

    /**
     * The deposit cannot be refunded since none was made.
     **/
    noDeposit: GenericModuleError;

    /**
     * The referendum status is invalid for this operation.
     **/
    badStatus: GenericModuleError;

    /**
     * The preimage does not exist.
     **/
    preimageNotExist: GenericModuleError;
  };
  fellowshipCollective: {
    /**
     * Account is already a member.
     **/
    alreadyMember: GenericModuleError;

    /**
     * Account is not a member.
     **/
    notMember: GenericModuleError;

    /**
     * The given poll index is unknown or has closed.
     **/
    notPolling: GenericModuleError;

    /**
     * The given poll is still ongoing.
     **/
    ongoing: GenericModuleError;

    /**
     * There are no further records to be removed.
     **/
    noneRemaining: GenericModuleError;

    /**
     * Unexpected error in state.
     **/
    corruption: GenericModuleError;

    /**
     * The member's rank is too low to vote.
     **/
    rankTooLow: GenericModuleError;

    /**
     * The information provided is incorrect.
     **/
    invalidWitness: GenericModuleError;

    /**
     * The origin is not sufficiently privileged to do the operation.
     **/
    noPermission: GenericModuleError;
  };
  fellowshipReferenda: {
    /**
     * Referendum is not ongoing.
     **/
    notOngoing: GenericModuleError;

    /**
     * Referendum's decision deposit is already paid.
     **/
    hasDeposit: GenericModuleError;

    /**
     * The track identifier given was invalid.
     **/
    badTrack: GenericModuleError;

    /**
     * There are already a full complement of referenda in progress for this track.
     **/
    full: GenericModuleError;

    /**
     * The queue of the track is empty.
     **/
    queueEmpty: GenericModuleError;

    /**
     * The referendum index provided is invalid in this context.
     **/
    badReferendum: GenericModuleError;

    /**
     * There was nothing to do in the advancement.
     **/
    nothingToDo: GenericModuleError;

    /**
     * No track exists for the proposal origin.
     **/
    noTrack: GenericModuleError;

    /**
     * Any deposit cannot be refunded until after the decision is over.
     **/
    unfinished: GenericModuleError;

    /**
     * The deposit refunder is not the depositor.
     **/
    noPermission: GenericModuleError;

    /**
     * The deposit cannot be refunded since none was made.
     **/
    noDeposit: GenericModuleError;

    /**
     * The referendum status is invalid for this operation.
     **/
    badStatus: GenericModuleError;

    /**
     * The preimage does not exist.
     **/
    preimageNotExist: GenericModuleError;
  };
  whitelist: {
    /**
     * The preimage of the call hash could not be loaded.
     **/
    unavailablePreImage: GenericModuleError;

    /**
     * The call could not be decoded.
     **/
    undecodableCall: GenericModuleError;

    /**
     * The weight of the decoded call was higher than the witness.
     **/
    invalidCallWeightWitness: GenericModuleError;

    /**
     * The call was not whitelisted.
     **/
    callIsNotWhitelisted: GenericModuleError;

    /**
     * The call was already whitelisted; No-Op.
     **/
    callAlreadyWhitelisted: GenericModuleError;
  };
  claims: {
    /**
     * Invalid Ethereum signature.
     **/
    invalidEthereumSignature: GenericModuleError;

    /**
     * Ethereum address has no claim.
     **/
    signerHasNoClaim: GenericModuleError;

    /**
     * Account ID sending transaction has no claim.
     **/
    senderHasNoClaim: GenericModuleError;

    /**
     * There's not enough in the pot to pay out some unvested amount. Generally implies a
     * logic error.
     **/
    potUnderflow: GenericModuleError;

    /**
     * A needed statement was not included.
     **/
    invalidStatement: GenericModuleError;

    /**
     * The account already has a vested balance.
     **/
    vestedBalanceExists: GenericModuleError;
  };
  utility: {
    /**
     * Too many calls batched.
     **/
    tooManyCalls: GenericModuleError;
  };
  identity: {
    /**
     * Too many subs-accounts.
     **/
    tooManySubAccounts: GenericModuleError;

    /**
     * Account isn't found.
     **/
    notFound: GenericModuleError;

    /**
     * Account isn't named.
     **/
    notNamed: GenericModuleError;

    /**
     * Empty index.
     **/
    emptyIndex: GenericModuleError;

    /**
     * Fee is changed.
     **/
    feeChanged: GenericModuleError;

    /**
     * No identity found.
     **/
    noIdentity: GenericModuleError;

    /**
     * Sticky judgement.
     **/
    stickyJudgement: GenericModuleError;

    /**
     * Judgement given.
     **/
    judgementGiven: GenericModuleError;

    /**
     * Invalid judgement.
     **/
    invalidJudgement: GenericModuleError;

    /**
     * The index is invalid.
     **/
    invalidIndex: GenericModuleError;

    /**
     * The target is invalid.
     **/
    invalidTarget: GenericModuleError;

    /**
     * Too many additional fields.
     **/
    tooManyFields: GenericModuleError;

    /**
     * Maximum amount of registrars reached. Cannot add any more.
     **/
    tooManyRegistrars: GenericModuleError;

    /**
     * Account ID is already named.
     **/
    alreadyClaimed: GenericModuleError;

    /**
     * Sender is not a sub-account.
     **/
    notSub: GenericModuleError;

    /**
     * Sub-account isn't owned by sender.
     **/
    notOwned: GenericModuleError;

    /**
     * The provided judgement was for a different identity.
     **/
    judgementForDifferentIdentity: GenericModuleError;

    /**
     * Error that occurs when there is an issue paying for judgement.
     **/
    judgementPaymentFailed: GenericModuleError;
  };
  society: {
    /**
     * User is not a member.
     **/
    notMember: GenericModuleError;

    /**
     * User is already a member.
     **/
    alreadyMember: GenericModuleError;

    /**
     * User is suspended.
     **/
    suspended: GenericModuleError;

    /**
     * User is not suspended.
     **/
    notSuspended: GenericModuleError;

    /**
     * Nothing to payout.
     **/
    noPayout: GenericModuleError;

    /**
     * Society already founded.
     **/
    alreadyFounded: GenericModuleError;

    /**
     * Not enough in pot to accept candidate.
     **/
    insufficientPot: GenericModuleError;

    /**
     * Member is already vouching or banned from vouching again.
     **/
    alreadyVouching: GenericModuleError;

    /**
     * Member is not vouching.
     **/
    notVouchingOnBidder: GenericModuleError;

    /**
     * Cannot remove the head of the chain.
     **/
    head: GenericModuleError;

    /**
     * Cannot remove the founder.
     **/
    founder: GenericModuleError;

    /**
     * User has already made a bid.
     **/
    alreadyBid: GenericModuleError;

    /**
     * User is already a candidate.
     **/
    alreadyCandidate: GenericModuleError;

    /**
     * User is not a candidate.
     **/
    notCandidate: GenericModuleError;

    /**
     * Too many members in the society.
     **/
    maxMembers: GenericModuleError;

    /**
     * The caller is not the founder.
     **/
    notFounder: GenericModuleError;

    /**
     * The caller is not the head.
     **/
    notHead: GenericModuleError;

    /**
     * The membership cannot be claimed as the candidate was not clearly approved.
     **/
    notApproved: GenericModuleError;

    /**
     * The candidate cannot be kicked as the candidate was not clearly rejected.
     **/
    notRejected: GenericModuleError;

    /**
     * The candidacy cannot be dropped as the candidate was clearly approved.
     **/
    approved: GenericModuleError;

    /**
     * The candidacy cannot be bestowed as the candidate was clearly rejected.
     **/
    rejected: GenericModuleError;

    /**
     * The candidacy cannot be concluded as the voting is still in progress.
     **/
    inProgress: GenericModuleError;

    /**
     * The candidacy cannot be pruned until a full additional intake period has passed.
     **/
    tooEarly: GenericModuleError;

    /**
     * The skeptic already voted.
     **/
    voted: GenericModuleError;

    /**
     * The skeptic need not vote on candidates from expired rounds.
     **/
    expired: GenericModuleError;

    /**
     * User is not a bidder.
     **/
    notBidder: GenericModuleError;

    /**
     * There is no defender currently.
     **/
    noDefender: GenericModuleError;

    /**
     * Group doesn't exist.
     **/
    notGroup: GenericModuleError;

    /**
     * The member is already elevated to this rank.
     **/
    alreadyElevated: GenericModuleError;

    /**
     * The skeptic has already been punished for this offence.
     **/
    alreadyPunished: GenericModuleError;

    /**
     * Funds are insufficient to pay off society debts.
     **/
    insufficientFunds: GenericModuleError;

    /**
     * The candidate/defender has no stale votes to remove.
     **/
    noVotes: GenericModuleError;
  };
  recovery: {
    /**
     * User is not allowed to make a call on behalf of this account
     **/
    notAllowed: GenericModuleError;

    /**
     * Threshold must be greater than zero
     **/
    zeroThreshold: GenericModuleError;

    /**
     * Friends list must be greater than zero and threshold
     **/
    notEnoughFriends: GenericModuleError;

    /**
     * Friends list must be less than max friends
     **/
    maxFriends: GenericModuleError;

    /**
     * Friends list must be sorted and free of duplicates
     **/
    notSorted: GenericModuleError;

    /**
     * This account is not set up for recovery
     **/
    notRecoverable: GenericModuleError;

    /**
     * This account is already set up for recovery
     **/
    alreadyRecoverable: GenericModuleError;

    /**
     * A recovery process has already started for this account
     **/
    alreadyStarted: GenericModuleError;

    /**
     * A recovery process has not started for this rescuer
     **/
    notStarted: GenericModuleError;

    /**
     * This account is not a friend who can vouch
     **/
    notFriend: GenericModuleError;

    /**
     * The friend must wait until the delay period to vouch for this recovery
     **/
    delayPeriod: GenericModuleError;

    /**
     * This user has already vouched for this recovery
     **/
    alreadyVouched: GenericModuleError;

    /**
     * The threshold for recovering this account has not been met
     **/
    threshold: GenericModuleError;

    /**
     * There are still active recovery attempts that need to be closed
     **/
    stillActive: GenericModuleError;

    /**
     * This account is already set up for recovery
     **/
    alreadyProxy: GenericModuleError;

    /**
     * Some internal state is broken.
     **/
    badState: GenericModuleError;
  };
  vesting: {
    /**
     * The account given is not vesting.
     **/
    notVesting: GenericModuleError;

    /**
     * The account already has `MaxVestingSchedules` count of schedules and thus
     * cannot add another one. Consider merging existing schedules in order to add another.
     **/
    atMaxVestingSchedules: GenericModuleError;

    /**
     * Amount being transferred is too low to create a vesting schedule.
     **/
    amountLow: GenericModuleError;

    /**
     * An index was out of bounds of the vesting schedules.
     **/
    scheduleIndexOutOfBounds: GenericModuleError;

    /**
     * Failed to create a new schedule because some parameter was invalid.
     **/
    invalidScheduleParams: GenericModuleError;
  };
  scheduler: {
    /**
     * Failed to schedule a call
     **/
    failedToSchedule: GenericModuleError;

    /**
     * Cannot find the scheduled call.
     **/
    notFound: GenericModuleError;

    /**
     * Given target block number is in the past.
     **/
    targetBlockNumberInPast: GenericModuleError;

    /**
     * Reschedule failed because it does not change scheduled time.
     **/
    rescheduleNoChange: GenericModuleError;

    /**
     * Attempt to use a non-named function on a named task.
     **/
    named: GenericModuleError;
  };
  proxy: {
    /**
     * There are too many proxies registered or too many announcements pending.
     **/
    tooMany: GenericModuleError;

    /**
     * Proxy registration not found.
     **/
    notFound: GenericModuleError;

    /**
     * Sender is not a proxy of the account to be proxied.
     **/
    notProxy: GenericModuleError;

    /**
     * A call which is incompatible with the proxy type's filter was attempted.
     **/
    unproxyable: GenericModuleError;

    /**
     * Account is already a proxy.
     **/
    duplicate: GenericModuleError;

    /**
     * Call may not be made by proxy because it may escalate its privileges.
     **/
    noPermission: GenericModuleError;

    /**
     * Announcement, if made at all, was made too recently.
     **/
    unannounced: GenericModuleError;

    /**
     * Cannot add self as proxy.
     **/
    noSelfProxy: GenericModuleError;
  };
  multisig: {
    /**
     * Threshold must be 2 or greater.
     **/
    minimumThreshold: GenericModuleError;

    /**
     * Call is already approved by this signatory.
     **/
    alreadyApproved: GenericModuleError;

    /**
     * Call doesn't need any (more) approvals.
     **/
    noApprovalsNeeded: GenericModuleError;

    /**
     * There are too few signatories in the list.
     **/
    tooFewSignatories: GenericModuleError;

    /**
     * There are too many signatories in the list.
     **/
    tooManySignatories: GenericModuleError;

    /**
     * The signatories were provided out of order; they should be ordered.
     **/
    signatoriesOutOfOrder: GenericModuleError;

    /**
     * The sender was contained in the other signatories; it shouldn't be.
     **/
    senderInSignatories: GenericModuleError;

    /**
     * Multisig operation not found when attempting to cancel.
     **/
    notFound: GenericModuleError;

    /**
     * Only the account that originally created the multisig is able to cancel it.
     **/
    notOwner: GenericModuleError;

    /**
     * No timepoint was given, yet the multisig operation is already underway.
     **/
    noTimepoint: GenericModuleError;

    /**
     * A different timepoint was given to the multisig operation that is underway.
     **/
    wrongTimepoint: GenericModuleError;

    /**
     * A timepoint was given, yet no multisig operation is underway.
     **/
    unexpectedTimepoint: GenericModuleError;

    /**
     * The maximum weight information provided was too low.
     **/
    maxWeightTooLow: GenericModuleError;

    /**
     * The data to be stored is already stored.
     **/
    alreadyStored: GenericModuleError;
  };
  preimage: {
    /**
     * Preimage is too large to store on-chain.
     **/
    tooBig: GenericModuleError;

    /**
     * Preimage has already been noted on-chain.
     **/
    alreadyNoted: GenericModuleError;

    /**
     * The user is not authorized to perform this action.
     **/
    notAuthorized: GenericModuleError;

    /**
     * The preimage cannot be removed since it has not yet been noted.
     **/
    notNoted: GenericModuleError;

    /**
     * A preimage may not be removed when there are outstanding requests.
     **/
    requested: GenericModuleError;

    /**
     * The preimage request cannot be removed since no outstanding requests exist.
     **/
    notRequested: GenericModuleError;
  };
  bounties: {
    /**
     * Proposer's balance is too low.
     **/
    insufficientProposersBalance: GenericModuleError;

    /**
     * No proposal or bounty at that index.
     **/
    invalidIndex: GenericModuleError;

    /**
     * The reason given is just too big.
     **/
    reasonTooBig: GenericModuleError;

    /**
     * The bounty status is unexpected.
     **/
    unexpectedStatus: GenericModuleError;

    /**
     * Require bounty curator.
     **/
    requireCurator: GenericModuleError;

    /**
     * Invalid bounty value.
     **/
    invalidValue: GenericModuleError;

    /**
     * Invalid bounty fee.
     **/
    invalidFee: GenericModuleError;

    /**
     * A bounty payout is pending.
     * To cancel the bounty, you must unassign and slash the curator.
     **/
    pendingPayout: GenericModuleError;

    /**
     * The bounties cannot be claimed/closed because it's still in the countdown period.
     **/
    premature: GenericModuleError;

    /**
     * The bounty cannot be closed because it has active child bounties.
     **/
    hasActiveChildBounty: GenericModuleError;

    /**
     * Too many approvals are already queued.
     **/
    tooManyQueued: GenericModuleError;
  };
  childBounties: {
    /**
     * The parent bounty is not in active state.
     **/
    parentBountyNotActive: GenericModuleError;

    /**
     * The bounty balance is not enough to add new child-bounty.
     **/
    insufficientBountyBalance: GenericModuleError;

    /**
     * Number of child bounties exceeds limit `MaxActiveChildBountyCount`.
     **/
    tooManyChildBounties: GenericModuleError;
  };
  electionProviderMultiPhase: {
    /**
     * Submission was too early.
     **/
    preDispatchEarlySubmission: GenericModuleError;

    /**
     * Wrong number of winners presented.
     **/
    preDispatchWrongWinnerCount: GenericModuleError;

    /**
     * Submission was too weak, score-wise.
     **/
    preDispatchWeakSubmission: GenericModuleError;

    /**
     * The queue was full, and the solution was not better than any of the existing ones.
     **/
    signedQueueFull: GenericModuleError;

    /**
     * The origin failed to pay the deposit.
     **/
    signedCannotPayDeposit: GenericModuleError;

    /**
     * Witness data to dispatchable is invalid.
     **/
    signedInvalidWitness: GenericModuleError;

    /**
     * The signed submission consumes too much weight
     **/
    signedTooMuchWeight: GenericModuleError;

    /**
     * OCW submitted solution for wrong round
     **/
    ocwCallWrongEra: GenericModuleError;

    /**
     * Snapshot metadata should exist but didn't.
     **/
    missingSnapshotMetadata: GenericModuleError;

    /**
     * `Self::insert_submission` returned an invalid index.
     **/
    invalidSubmissionIndex: GenericModuleError;

    /**
     * The call is not allowed at this point.
     **/
    callNotAllowed: GenericModuleError;

    /**
     * The fallback failed
     **/
    fallbackFailed: GenericModuleError;

    /**
     * Some bound not met
     **/
    boundNotMet: GenericModuleError;

    /**
     * Submitted solution has too many winners
     **/
    tooManyWinners: GenericModuleError;
  };
  nis: {
    /**
     * The duration of the bid is less than one.
     **/
    durationTooSmall: GenericModuleError;

    /**
     * The duration is the bid is greater than the number of queues.
     **/
    durationTooBig: GenericModuleError;

    /**
     * The amount of the bid is less than the minimum allowed.
     **/
    amountTooSmall: GenericModuleError;

    /**
     * The queue for the bid's duration is full and the amount bid is too low to get in
     * through replacing an existing bid.
     **/
    bidTooLow: GenericModuleError;

    /**
     * Receipt index is unknown.
     **/
    unknownReceipt: GenericModuleError;

    /**
     * Not the owner of the receipt.
     **/
    notOwner: GenericModuleError;

    /**
     * Bond not yet at expiry date.
     **/
    notExpired: GenericModuleError;

    /**
     * The given bid for retraction is not found.
     **/
    unknownBid: GenericModuleError;

    /**
     * The portion supplied is beyond the value of the receipt.
     **/
    portionTooBig: GenericModuleError;

    /**
     * Not enough funds are held to pay out.
     **/
    unfunded: GenericModuleError;

    /**
     * There are enough funds for what is required.
     **/
    alreadyFunded: GenericModuleError;

    /**
     * The thaw throttle has been reached for this period.
     **/
    throttled: GenericModuleError;

    /**
     * The operation would result in a receipt worth an insignficant value.
     **/
    makesDust: GenericModuleError;

    /**
     * The receipt is already communal.
     **/
    alreadyCommunal: GenericModuleError;

    /**
     * The receipt is already private.
     **/
    alreadyPrivate: GenericModuleError;
  };
  nisCounterpartBalances: {
    /**
     * Vesting balance too high to send value.
     **/
    vestingBalance: GenericModuleError;

    /**
     * Account liquidity restrictions prevent withdrawal.
     **/
    liquidityRestrictions: GenericModuleError;

    /**
     * Balance too low to send value.
     **/
    insufficientBalance: GenericModuleError;

    /**
     * Value too low to create account due to existential deposit.
     **/
    existentialDeposit: GenericModuleError;

    /**
     * Transfer/payment would kill account.
     **/
    expendability: GenericModuleError;

    /**
     * A vesting schedule already exists for this account.
     **/
    existingVestingSchedule: GenericModuleError;

    /**
     * Beneficiary account must pre-exist.
     **/
    deadAccount: GenericModuleError;

    /**
     * Number of named reserves exceed `MaxReserves`.
     **/
    tooManyReserves: GenericModuleError;

    /**
     * Number of holds exceed `MaxHolds`.
     **/
    tooManyHolds: GenericModuleError;

    /**
     * Number of freezes exceed `MaxFreezes`.
     **/
    tooManyFreezes: GenericModuleError;
  };
  voterList: {
    /**
     * A error in the list interface implementation.
     **/
    list: GenericModuleError;
  };
  nominationPools: {
    /**
     * A (bonded) pool id does not exist.
     **/
    poolNotFound: GenericModuleError;

    /**
     * An account is not a member.
     **/
    poolMemberNotFound: GenericModuleError;

    /**
     * A reward pool does not exist. In all cases this is a system logic error.
     **/
    rewardPoolNotFound: GenericModuleError;

    /**
     * A sub pool does not exist.
     **/
    subPoolsNotFound: GenericModuleError;

    /**
     * An account is already delegating in another pool. An account may only belong to one
     * pool at a time.
     **/
    accountBelongsToOtherPool: GenericModuleError;

    /**
     * The member is fully unbonded (and thus cannot access the bonded and reward pool
     * anymore to, for example, collect rewards).
     **/
    fullyUnbonding: GenericModuleError;

    /**
     * The member cannot unbond further chunks due to reaching the limit.
     **/
    maxUnbondingLimit: GenericModuleError;

    /**
     * None of the funds can be withdrawn yet because the bonding duration has not passed.
     **/
    cannotWithdrawAny: GenericModuleError;

    /**
     * The amount does not meet the minimum bond to either join or create a pool.
     *
     * The depositor can never unbond to a value less than
     * `Pallet::depositor_min_bond`. The caller does not have nominating
     * permissions for the pool. Members can never unbond to a value below `MinJoinBond`.
     **/
    minimumBondNotMet: GenericModuleError;

    /**
     * The transaction could not be executed due to overflow risk for the pool.
     **/
    overflowRisk: GenericModuleError;

    /**
     * A pool must be in [`PoolState::Destroying`] in order for the depositor to unbond or for
     * other members to be permissionlessly unbonded.
     **/
    notDestroying: GenericModuleError;

    /**
     * The caller does not have nominating permissions for the pool.
     **/
    notNominator: GenericModuleError;

    /**
     * Either a) the caller cannot make a valid kick or b) the pool is not destroying.
     **/
    notKickerOrDestroying: GenericModuleError;

    /**
     * The pool is not open to join
     **/
    notOpen: GenericModuleError;

    /**
     * The system is maxed out on pools.
     **/
    maxPools: GenericModuleError;

    /**
     * Too many members in the pool or system.
     **/
    maxPoolMembers: GenericModuleError;

    /**
     * The pools state cannot be changed.
     **/
    canNotChangeState: GenericModuleError;

    /**
     * The caller does not have adequate permissions.
     **/
    doesNotHavePermission: GenericModuleError;

    /**
     * Metadata exceeds [`Config::MaxMetadataLen`]
     **/
    metadataExceedsMaxLen: GenericModuleError;

    /**
     * Some error occurred that should never happen. This should be reported to the
     * maintainers.
     **/
    defensive: GenericModuleError;

    /**
     * Partial unbonding now allowed permissionlessly.
     **/
    partialUnbondNotAllowedPermissionlessly: GenericModuleError;

    /**
     * The pool's max commission cannot be set higher than the existing value.
     **/
    maxCommissionRestricted: GenericModuleError;

    /**
     * The supplied commission exceeds the max allowed commission.
     **/
    commissionExceedsMaximum: GenericModuleError;

    /**
     * The supplied commission exceeds global maximum commission.
     **/
    commissionExceedsGlobalMaximum: GenericModuleError;

    /**
     * Not enough blocks have surpassed since the last commission update.
     **/
    commissionChangeThrottled: GenericModuleError;

    /**
     * The submitted changes to commission change rate are not allowed.
     **/
    commissionChangeRateNotAllowed: GenericModuleError;

    /**
     * There is no pending commission to claim.
     **/
    noPendingCommission: GenericModuleError;

    /**
     * No commission current has been set.
     **/
    noCommissionCurrentSet: GenericModuleError;

    /**
     * Pool id currently in use.
     **/
    poolIdInUse: GenericModuleError;

    /**
     * Pool id provided is not correct/usable.
     **/
    invalidPoolId: GenericModuleError;

    /**
     * Bonding extra is restricted to the exact pending reward amount.
     **/
    bondExtraRestricted: GenericModuleError;
  };
  fastUnstake: {
    /**
     * The provided Controller account was not found.
     *
     * This means that the given account is not bonded.
     **/
    notController: GenericModuleError;

    /**
     * The bonded account has already been queued.
     **/
    alreadyQueued: GenericModuleError;

    /**
     * The bonded account has active unlocking chunks.
     **/
    notFullyBonded: GenericModuleError;

    /**
     * The provided un-staker is not in the `Queue`.
     **/
    notQueued: GenericModuleError;

    /**
     * The provided un-staker is already in Head, and cannot deregister.
     **/
    alreadyHead: GenericModuleError;

    /**
     * The call is not allowed at this point because the pallet is not active.
     **/
    callNotAllowed: GenericModuleError;
  };
  configuration: {
    /**
     * The new value for a configuration parameter is invalid.
     **/
    invalidNewValue: GenericModuleError;
  };
  paraInclusion: {
    /**
     * Validator indices are out of order or contains duplicates.
     **/
    unsortedOrDuplicateValidatorIndices: GenericModuleError;

    /**
     * Dispute statement sets are out of order or contain duplicates.
     **/
    unsortedOrDuplicateDisputeStatementSet: GenericModuleError;

    /**
     * Backed candidates are out of order (core index) or contain duplicates.
     **/
    unsortedOrDuplicateBackedCandidates: GenericModuleError;

    /**
     * A different relay parent was provided compared to the on-chain stored one.
     **/
    unexpectedRelayParent: GenericModuleError;

    /**
     * Availability bitfield has unexpected size.
     **/
    wrongBitfieldSize: GenericModuleError;

    /**
     * Bitfield consists of zeros only.
     **/
    bitfieldAllZeros: GenericModuleError;

    /**
     * Multiple bitfields submitted by same validator or validators out of order by index.
     **/
    bitfieldDuplicateOrUnordered: GenericModuleError;

    /**
     * Validator index out of bounds.
     **/
    validatorIndexOutOfBounds: GenericModuleError;

    /**
     * Invalid signature
     **/
    invalidBitfieldSignature: GenericModuleError;

    /**
     * Candidate submitted but para not scheduled.
     **/
    unscheduledCandidate: GenericModuleError;

    /**
     * Candidate scheduled despite pending candidate already existing for the para.
     **/
    candidateScheduledBeforeParaFree: GenericModuleError;

    /**
     * Scheduled cores out of order.
     **/
    scheduledOutOfOrder: GenericModuleError;

    /**
     * Head data exceeds the configured maximum.
     **/
    headDataTooLarge: GenericModuleError;

    /**
     * Code upgrade prematurely.
     **/
    prematureCodeUpgrade: GenericModuleError;

    /**
     * Output code is too large
     **/
    newCodeTooLarge: GenericModuleError;

    /**
     * The candidate's relay-parent was not allowed. Either it was
     * not recent enough or it didn't advance based on the last parachain block.
     **/
    disallowedRelayParent: GenericModuleError;

    /**
     * Failed to compute group index for the core: either it's out of bounds
     * or the relay parent doesn't belong to the current session.
     **/
    invalidAssignment: GenericModuleError;

    /**
     * Invalid group index in core assignment.
     **/
    invalidGroupIndex: GenericModuleError;

    /**
     * Insufficient (non-majority) backing.
     **/
    insufficientBacking: GenericModuleError;

    /**
     * Invalid (bad signature, unknown validator, etc.) backing.
     **/
    invalidBacking: GenericModuleError;

    /**
     * Collator did not sign PoV.
     **/
    notCollatorSigned: GenericModuleError;

    /**
     * The validation data hash does not match expected.
     **/
    validationDataHashMismatch: GenericModuleError;

    /**
     * The downward message queue is not processed correctly.
     **/
    incorrectDownwardMessageHandling: GenericModuleError;

    /**
     * At least one upward message sent does not pass the acceptance criteria.
     **/
    invalidUpwardMessages: GenericModuleError;

    /**
     * The candidate didn't follow the rules of HRMP watermark advancement.
     **/
    hrmpWatermarkMishandling: GenericModuleError;

    /**
     * The HRMP messages sent by the candidate is not valid.
     **/
    invalidOutboundHrmp: GenericModuleError;

    /**
     * The validation code hash of the candidate is not valid.
     **/
    invalidValidationCodeHash: GenericModuleError;

    /**
     * The `para_head` hash in the candidate descriptor doesn't match the hash of the actual
     * para head in the commitments.
     **/
    paraHeadMismatch: GenericModuleError;

    /**
     * A bitfield that references a freed core,
     * either intentionally or as part of a concluded
     * invalid dispute.
     **/
    bitfieldReferencesFreedCore: GenericModuleError;
  };
  paraInherent: {
    /**
     * Inclusion inherent called more than once per block.
     **/
    tooManyInclusionInherents: GenericModuleError;

    /**
     * The hash of the submitted parent header doesn't correspond to the saved block hash of
     * the parent.
     **/
    invalidParentHeader: GenericModuleError;

    /**
     * Disputed candidate that was concluded invalid.
     **/
    candidateConcludedInvalid: GenericModuleError;

    /**
     * The data given to the inherent will result in an overweight block.
     **/
    inherentOverweight: GenericModuleError;

    /**
     * The ordering of dispute statements was invalid.
     **/
    disputeStatementsUnsortedOrDuplicates: GenericModuleError;

    /**
     * A dispute statement was invalid.
     **/
    disputeInvalid: GenericModuleError;
  };
  paras: {
    /**
     * Para is not registered in our system.
     **/
    notRegistered: GenericModuleError;

    /**
     * Para cannot be onboarded because it is already tracked by our system.
     **/
    cannotOnboard: GenericModuleError;

    /**
     * Para cannot be offboarded at this time.
     **/
    cannotOffboard: GenericModuleError;

    /**
     * Para cannot be upgraded to a lease holding parachain.
     **/
    cannotUpgrade: GenericModuleError;

    /**
     * Para cannot be downgraded to an on-demand parachain.
     **/
    cannotDowngrade: GenericModuleError;

    /**
     * The statement for PVF pre-checking is stale.
     **/
    pvfCheckStatementStale: GenericModuleError;

    /**
     * The statement for PVF pre-checking is for a future session.
     **/
    pvfCheckStatementFuture: GenericModuleError;

    /**
     * Claimed validator index is out of bounds.
     **/
    pvfCheckValidatorIndexOutOfBounds: GenericModuleError;

    /**
     * The signature for the PVF pre-checking is invalid.
     **/
    pvfCheckInvalidSignature: GenericModuleError;

    /**
     * The given validator already has cast a vote.
     **/
    pvfCheckDoubleVote: GenericModuleError;

    /**
     * The given PVF does not exist at the moment of process a vote.
     **/
    pvfCheckSubjectInvalid: GenericModuleError;

    /**
     * Parachain cannot currently schedule a code upgrade.
     **/
    cannotUpgradeCode: GenericModuleError;
  };
  hrmp: {
    /**
     * The sender tried to open a channel to themselves.
     **/
    openHrmpChannelToSelf: GenericModuleError;

    /**
     * The recipient is not a valid para.
     **/
    openHrmpChannelInvalidRecipient: GenericModuleError;

    /**
     * The requested capacity is zero.
     **/
    openHrmpChannelZeroCapacity: GenericModuleError;

    /**
     * The requested capacity exceeds the global limit.
     **/
    openHrmpChannelCapacityExceedsLimit: GenericModuleError;

    /**
     * The requested maximum message size is 0.
     **/
    openHrmpChannelZeroMessageSize: GenericModuleError;

    /**
     * The open request requested the message size that exceeds the global limit.
     **/
    openHrmpChannelMessageSizeExceedsLimit: GenericModuleError;

    /**
     * The channel already exists
     **/
    openHrmpChannelAlreadyExists: GenericModuleError;

    /**
     * There is already a request to open the same channel.
     **/
    openHrmpChannelAlreadyRequested: GenericModuleError;

    /**
     * The sender already has the maximum number of allowed outbound channels.
     **/
    openHrmpChannelLimitExceeded: GenericModuleError;

    /**
     * The channel from the sender to the origin doesn't exist.
     **/
    acceptHrmpChannelDoesntExist: GenericModuleError;

    /**
     * The channel is already confirmed.
     **/
    acceptHrmpChannelAlreadyConfirmed: GenericModuleError;

    /**
     * The recipient already has the maximum number of allowed inbound channels.
     **/
    acceptHrmpChannelLimitExceeded: GenericModuleError;

    /**
     * The origin tries to close a channel where it is neither the sender nor the recipient.
     **/
    closeHrmpChannelUnauthorized: GenericModuleError;

    /**
     * The channel to be closed doesn't exist.
     **/
    closeHrmpChannelDoesntExist: GenericModuleError;

    /**
     * The channel close request is already requested.
     **/
    closeHrmpChannelAlreadyUnderway: GenericModuleError;

    /**
     * Canceling is requested by neither the sender nor recipient of the open channel request.
     **/
    cancelHrmpOpenChannelUnauthorized: GenericModuleError;

    /**
     * The open request doesn't exist.
     **/
    openHrmpChannelDoesntExist: GenericModuleError;

    /**
     * Cannot cancel an HRMP open channel request because it is already confirmed.
     **/
    openHrmpChannelAlreadyConfirmed: GenericModuleError;

    /**
     * The provided witness data is wrong.
     **/
    wrongWitness: GenericModuleError;
  };
  parasDisputes: {
    /**
     * Duplicate dispute statement sets provided.
     **/
    duplicateDisputeStatementSets: GenericModuleError;

    /**
     * Ancient dispute statement provided.
     **/
    ancientDisputeStatement: GenericModuleError;

    /**
     * Validator index on statement is out of bounds for session.
     **/
    validatorIndexOutOfBounds: GenericModuleError;

    /**
     * Invalid signature on statement.
     **/
    invalidSignature: GenericModuleError;

    /**
     * Validator vote submitted more than once to dispute.
     **/
    duplicateStatement: GenericModuleError;

    /**
     * A dispute where there are only votes on one side.
     **/
    singleSidedDispute: GenericModuleError;

    /**
     * A dispute vote from a malicious backer.
     **/
    maliciousBacker: GenericModuleError;

    /**
     * No backing votes were provides along dispute statements.
     **/
    missingBackingVotes: GenericModuleError;

    /**
     * Unconfirmed dispute statement sets provided.
     **/
    unconfirmedDispute: GenericModuleError;
  };
  parasSlashing: {
    /**
     * The key ownership proof is invalid.
     **/
    invalidKeyOwnershipProof: GenericModuleError;

    /**
     * The session index is too old or invalid.
     **/
    invalidSessionIndex: GenericModuleError;

    /**
     * The candidate hash is invalid.
     **/
    invalidCandidateHash: GenericModuleError;

    /**
     * There is no pending slash for the given validator index and time
     * slot.
     **/
    invalidValidatorIndex: GenericModuleError;

    /**
     * The validator index does not match the validator id.
     **/
    validatorIndexIdMismatch: GenericModuleError;

    /**
     * The given slashing report is valid but already previously reported.
     **/
    duplicateSlashingReport: GenericModuleError;
  };
  registrar: {
    /**
     * The ID is not registered.
     **/
    notRegistered: GenericModuleError;

    /**
     * The ID is already registered.
     **/
    alreadyRegistered: GenericModuleError;

    /**
     * The caller is not the owner of this Id.
     **/
    notOwner: GenericModuleError;

    /**
     * Invalid para code size.
     **/
    codeTooLarge: GenericModuleError;

    /**
     * Invalid para head data size.
     **/
    headDataTooLarge: GenericModuleError;

    /**
     * Para is not a Parachain.
     **/
    notParachain: GenericModuleError;

    /**
     * Para is not a Parathread (on-demand parachain).
     **/
    notParathread: GenericModuleError;

    /**
     * Cannot deregister para
     **/
    cannotDeregister: GenericModuleError;

    /**
     * Cannot schedule downgrade of lease holding parachain to on-demand parachain
     **/
    cannotDowngrade: GenericModuleError;

    /**
     * Cannot schedule upgrade of on-demand parachain to lease holding parachain
     **/
    cannotUpgrade: GenericModuleError;

    /**
     * Para is locked from manipulation by the manager. Must use parachain or relay chain
     * governance.
     **/
    paraLocked: GenericModuleError;

    /**
     * The ID given for registration has not been reserved.
     **/
    notReserved: GenericModuleError;

    /**
     * Registering parachain with empty code is not allowed.
     **/
    emptyCode: GenericModuleError;

    /**
     * Cannot perform a parachain slot / lifecycle swap. Check that the state of both paras
     * are correct for the swap to work.
     **/
    cannotSwap: GenericModuleError;
  };
  slots: {
    /**
     * The parachain ID is not onboarding.
     **/
    paraNotOnboarding: GenericModuleError;

    /**
     * There was an error with the lease.
     **/
    leaseError: GenericModuleError;
  };
  auctions: {
    /**
     * This auction is already in progress.
     **/
    auctionInProgress: GenericModuleError;

    /**
     * The lease period is in the past.
     **/
    leasePeriodInPast: GenericModuleError;

    /**
     * Para is not registered
     **/
    paraNotRegistered: GenericModuleError;

    /**
     * Not a current auction.
     **/
    notCurrentAuction: GenericModuleError;

    /**
     * Not an auction.
     **/
    notAuction: GenericModuleError;

    /**
     * Auction has already ended.
     **/
    auctionEnded: GenericModuleError;

    /**
     * The para is already leased out for part of this range.
     **/
    alreadyLeasedOut: GenericModuleError;
  };
  crowdloan: {
    /**
     * The current lease period is more than the first lease period.
     **/
    firstPeriodInPast: GenericModuleError;

    /**
     * The first lease period needs to at least be less than 3 `max_value`.
     **/
    firstPeriodTooFarInFuture: GenericModuleError;

    /**
     * Last lease period must be greater than first lease period.
     **/
    lastPeriodBeforeFirstPeriod: GenericModuleError;

    /**
     * The last lease period cannot be more than 3 periods after the first period.
     **/
    lastPeriodTooFarInFuture: GenericModuleError;

    /**
     * The campaign ends before the current block number. The end must be in the future.
     **/
    cannotEndInPast: GenericModuleError;

    /**
     * The end date for this crowdloan is not sensible.
     **/
    endTooFarInFuture: GenericModuleError;

    /**
     * There was an overflow.
     **/
    overflow: GenericModuleError;

    /**
     * The contribution was below the minimum, `MinContribution`.
     **/
    contributionTooSmall: GenericModuleError;

    /**
     * Invalid fund index.
     **/
    invalidParaId: GenericModuleError;

    /**
     * Contributions exceed maximum amount.
     **/
    capExceeded: GenericModuleError;

    /**
     * The contribution period has already ended.
     **/
    contributionPeriodOver: GenericModuleError;

    /**
     * The origin of this call is invalid.
     **/
    invalidOrigin: GenericModuleError;

    /**
     * This crowdloan does not correspond to a parachain.
     **/
    notParachain: GenericModuleError;

    /**
     * This parachain lease is still active and retirement cannot yet begin.
     **/
    leaseActive: GenericModuleError;

    /**
     * This parachain's bid or lease is still active and withdraw cannot yet begin.
     **/
    bidOrLeaseActive: GenericModuleError;

    /**
     * The crowdloan has not yet ended.
     **/
    fundNotEnded: GenericModuleError;

    /**
     * There are no contributions stored in this crowdloan.
     **/
    noContributions: GenericModuleError;

    /**
     * The crowdloan is not ready to dissolve. Potentially still has a slot or in retirement
     * period.
     **/
    notReadyToDissolve: GenericModuleError;

    /**
     * Invalid signature.
     **/
    invalidSignature: GenericModuleError;

    /**
     * The provided memo is too large.
     **/
    memoTooLarge: GenericModuleError;

    /**
     * The fund is already in `NewRaise`
     **/
    alreadyInNewRaise: GenericModuleError;

    /**
     * No contributions allowed during the VRF delay
     **/
    vrfDelayInProgress: GenericModuleError;

    /**
     * A lease period has not started yet, due to an offset in the starting block.
     **/
    noLeasePeriod: GenericModuleError;
  };
  stateTrieMigration: {
    /**
     * Max signed limits not respected.
     **/
    maxSignedLimits: GenericModuleError;

    /**
     * A key was longer than the configured maximum.
     *
     * This means that the migration halted at the current [`Progress`] and
     * can be resumed with a larger [`crate::Config::MaxKeyLen`] value.
     * Retrying with the same [`crate::Config::MaxKeyLen`] value will not work.
     * The value should only be increased to avoid a storage migration for the currently
     * stored [`crate::Progress::LastKey`].
     **/
    keyTooLong: GenericModuleError;

    /**
     * submitter does not have enough funds.
     **/
    notEnoughFunds: GenericModuleError;

    /**
     * Bad witness data provided.
     **/
    badWitness: GenericModuleError;

    /**
     * Signed migration is not allowed because the maximum limit is not set yet.
     **/
    signedMigrationNotAllowed: GenericModuleError;

    /**
     * Bad child root provided.
     **/
    badChildRoot: GenericModuleError;
  };
  xcmPallet: {
    /**
     * The desired destination was unreachable, generally because there is a no way of routing
     * to it.
     **/
    unreachable: GenericModuleError;

    /**
     * There was some other issue (i.e. not to do with routing) in sending the message.
     * Perhaps a lack of space for buffering the message.
     **/
    sendFailure: GenericModuleError;

    /**
     * The message execution fails the filter.
     **/
    filtered: GenericModuleError;

    /**
     * The message's weight could not be determined.
     **/
    unweighableMessage: GenericModuleError;

    /**
     * The destination `MultiLocation` provided cannot be inverted.
     **/
    destinationNotInvertible: GenericModuleError;

    /**
     * The assets to be sent are empty.
     **/
    empty: GenericModuleError;

    /**
     * Could not re-anchor the assets to declare the fees for the destination chain.
     **/
    cannotReanchor: GenericModuleError;

    /**
     * Too many assets have been attempted for transfer.
     **/
    tooManyAssets: GenericModuleError;

    /**
     * Origin is invalid for sending.
     **/
    invalidOrigin: GenericModuleError;

    /**
     * The version of the `Versioned` value used is not able to be interpreted.
     **/
    badVersion: GenericModuleError;

    /**
     * The given location could not be used (e.g. because it cannot be expressed in the
     * desired version of XCM).
     **/
    badLocation: GenericModuleError;

    /**
     * The referenced subscription could not be found.
     **/
    noSubscription: GenericModuleError;

    /**
     * The location is invalid since it already has a subscription from us.
     **/
    alreadySubscribed: GenericModuleError;

    /**
     * Invalid asset for the operation.
     **/
    invalidAsset: GenericModuleError;

    /**
     * The owner does not own (all) of the asset that they wish to do the operation on.
     **/
    lowBalance: GenericModuleError;

    /**
     * The asset owner has too many locks on the asset.
     **/
    tooManyLocks: GenericModuleError;

    /**
     * The given account is not an identifiable sovereign account for any location.
     **/
    accountNotSovereign: GenericModuleError;

    /**
     * The operation required fees to be paid which the initiator could not meet.
     **/
    feesNotMet: GenericModuleError;

    /**
     * A remote lock with the corresponding data could not be found.
     **/
    lockNotFound: GenericModuleError;

    /**
     * The unlock operation cannot succeed because there are still consumers of the lock.
     **/
    inUse: GenericModuleError;
  };
  messageQueue: {
    /**
     * Page is not reapable because it has items remaining to be processed and is not old
     * enough.
     **/
    notReapable: GenericModuleError;

    /**
     * Page to be reaped does not exist.
     **/
    noPage: GenericModuleError;

    /**
     * The referenced message could not be found.
     **/
    noMessage: GenericModuleError;

    /**
     * The message was already processed and cannot be processed again.
     **/
    alreadyProcessed: GenericModuleError;

    /**
     * The message is queued for future execution.
     **/
    queued: GenericModuleError;

    /**
     * There is temporarily not enough weight to continue servicing messages.
     **/
    insufficientWeight: GenericModuleError;

    /**
     * This message is temporarily unprocessable.
     *
     * Such errors are expected, but not guaranteed, to resolve themselves eventually through
     * retrying.
     **/
    temporarilyUnprocessable: GenericModuleError;

    /**
     * The queue is paused and no message can be executed from it.
     *
     * This can change at any time and may resolve in the future by re-trying.
     **/
    queuePaused: GenericModuleError;
  };
}
